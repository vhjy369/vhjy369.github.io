<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[地球上的星星]]></title>
    <url>%2F2018%2F03%2F04%2F%E8%AF%BB%E4%B9%A6%E8%A7%82%E5%BD%B1%2F%E7%94%B5%E5%BD%B1%2F%E5%9C%B0%E7%90%83%E4%B8%8A%E7%9A%84%E6%98%9F%E6%98%9F%2F</url>
    <content type="text"><![CDATA[何为阅读障碍症一种大脑综合处理视觉和听觉信息不能协调而引起的一种阅读和拼写障碍症。注意区分它和那种因为智力低下而引起的阅读障碍症，相反很多患者是智商极高，甚至包括天才型的人。达芬奇，爱迪生，爱因斯坦，肯尼迪在儿童时代都被认为成绩极差的“笨孩子”，最后科学家发现他们都属于阅读障碍症的典型例子。换句话说，阅读障碍的人，不是智障，就是IQ奇高的天才 表现一、表现为阅读习惯不良，例如，朗读时，摇头晃脑、情绪不安或读着读着不知读到何处，或用手指着字读，或捧书太近或太远，或头部歪斜、书本歪斜。二、表现为朗读声音过高或过低、音色单调、声调过高或过低、不能清晰地发音。三、表现朗读错误，朗读时添加字词、遗漏字词、重复字词、某些字词用其它字词代替、经常自己错了又纠正等。 感受特殊儿童有着不同别人规律的思维，像一颗颗星星，需要机会才能释放。想到小时候的自己，父母外出打工，没人管，调皮爱玩，小学一二年级从没及格过，面对的也只有批评。感谢后来郭老师的引导，如大姐姐一般，也许正是有时不经意的一句鼓励可以让自己慢慢对学习感兴趣吧。也正是享受到了处于top中的优越感，可以一直有动力去努力追寻。]]></content>
      <categories>
        <category>生活</category>
        <category>电影</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不同垃圾收集器比较]]></title>
    <url>%2F2018%2F03%2F02%2Fjava%2FJVM%2F%E4%B8%8D%E5%90%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[串行收集器单线程环境，工作时所有应用线程全部暂停打开-XX:+UseSerialGC这个JVM参数来使用 并行/吞吐量收集器JVM默认收集器，使用多个线程l的扫描和压缩堆，缺点就是不管是minor GC还是full GC都会暂停应用线程。适合那些可以允许暂停的应用。可以减少收集器所引起的CPU开销 CMS收集器使用多个线程来扫描并标记那些不在使用的可以回收的对象。但是在两个阶段会进入‘stop the world’，进行根对象的初始标记，和在并发运行时应用程序改变了堆的状态，需要再次确认标记的是否正确时。问题：会碰到晋升失败的情况。新生代和老生带出现竞争，新生代需要晋升，老生代空间不够，会进行一次full GC。解决：增加老生代的大小，或者给回收器分配一些线程与分配对象的速度赛跑。缺点：消耗更多的CPU指定XX:+UseConcMarkSweepGC来启用假设堆小于4G，又希望分配更多的CPU资源以避免应用暂停，可以选择的回收器。然而，如果堆大于4G的话，可以选择G1回收器。 G1收集器G1回收器将堆分为多个区域，大小从1MB到32MB不等，并使用多个后台线程来扫描它们。G1回收器会优先扫描那些包含垃圾最多的区域，这正是它的名字的由来（Garbage first）。可以通过-XX:UseG1GC标记来启用。减少了后台线程还未扫描完无用对象前堆就已经用光的可能性，而那种情况回收器就必须得暂停应用，这就会导致STW回收。G1的另一个好处就是它总是会进行堆的压缩，而CMS回收器只有在full GC的时候才会干这事。 Java 8及G1回收器Java 8 update 20所引入的一个很棒的优化，G1回收器中的字符串去重（String deduplication）。由于字符串(包括它们内部的char[]数组）占用了大多数的堆空间，这项新的优化旨在使得G1回收器能识别出堆中那些重复出现的字符串并将它们指向同一个内部的char[]数组，以避免同一个字符串的多份拷贝，那样堆的使用效率会变得很低。使用-XX:+UseStringDeduplication这个JVM参数 Java 8及持久代Java 8中最大的改变就是持久代的移除，它原本是用来给类元数据，驻留字符串，静态变量来分配空间的。以前需要开发人员来针对那些会加载大量类的应用来专门进行堆比例的优化及调整。]]></content>
      <categories>
        <category>java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Condition实现分析]]></title>
    <url>%2F2018%2F03%2F02%2Fjava%2F%E6%BA%90%E7%A0%81%2FJ.U.C%E6%BA%90%E7%A0%81%2F%E9%94%81%2FCondition%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[概述ConditionObject是Condition在java并发中的具体的实现，它是AQS的内部类。因为Condition相关操作都需要获取锁，所以作为AQS的内部类也比较合理。 等待队列ConditionObject的等待队列是一个FIFO队列，队列的每个节点都是等待在Condition对象上的线程的引用，在调用Condition的await()方法之后，线程释放锁，构造成相应的节点进入等待队列等待。其中节点的定义复用AQS的Node定义。 ConditionObject包含等待队列的首节点firstWaiter和尾节点lastWaiter线程调用await()方法时，调用addConditionWaiter()方法入队：step1：将线程构造成Node；step2：将Node加入到等待队列中。插入节点只需要将原有尾节点的nextWaiter指向当前节点，并且更新尾节点。更新节点并没有像AQS更新同步队列使用CAS是因为调用await()方法的线程必定是获取了锁的线程，锁保证了操作的线程安全。 等待调用Condition的await开头的系列方法，当前线程进入等待队列等待，那么Condition的等待实质是await系列方法的具体实现。具体执行流程如下：调用addConditionWaiter将当前线程加入等待队列；调用fullRelease释放当前线程节点的同步状态，唤醒后继节点；线程进入等待状态；线程被唤醒后，从while循环中退出，调用acquireQueued尝试获取同步状态；同步状态获取成功后，线程从await方法返回。 唤醒调用Condition的signal()方法将会唤醒再等待队列中的首节点，该节点也是到目前为止等待时间最长的节点。 signal实现step1：前置检查，判断当前线程是否是获取了锁的线程，如果不是抛出异常IllegalMonitorStateException，否则，执行step2；step2：取得等待队列的头结点，头结点不为空执行doSignal，否则，signal结束。可以看出，doSignal方法是整个signal方法实现的核心，它完成了将线程从唤醒的所有操作。 doSignal实现整个doSignal完成了这两个操作：调用transferForSignal将节点从等待队列移动到同步队列，并且，将该节点从等待队列删除。 transferForSignal实现step1：将节点waitStatus设置为0，设置成功执行step2，否则返回false；step2：调用enq方法将该节点加入同步队列；step3：使用LockSuppor.unpark()方法唤醒该节点的线程。Condition的signalAll()方法，将等待队列中的所有节点全部唤醒，相当于将等待队列中的每一个节点都执行一次signal()。整个signal系列方法将线程从等待队列移动到同步队列]]></content>
      <categories>
        <category>java</category>
        <category>jdk源码分析</category>
        <category>J.U.C源码</category>
      </categories>
      <tags>
        <tag>jdk源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试实战问题记录]]></title>
    <url>%2F2018%2F02%2F26%2F%E9%9D%A2%E8%AF%95%2F%E9%9D%A2%E8%AF%95%E5%AE%9E%E6%88%98%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[百度一面 synchronized和lock区别，各自实现原理，使用 有没有自己通过java底层实现一些东西，说一说 JVM 内存模型，回收 堆栈，如何让堆溢出，如何让栈溢出 类加载机制 java 反射，动态代理，反射在框架中的使用 项目中用到的设计模式，模板，观察者 redis在项目中怎么用的 负载均衡（7层负载，4层。。。） 做过的项目某个模块 hive，mapreduce 最近读过哪些书 二面 项目分布式系统中如果运行一半宕机的时候，一致性如何保证 有没有设计过系统的哪个模块，能扛多少并发，有没有做过压测 除了java，有没有了解其他的技术栈 linux熟不熟悉，了解linux编程吗 netty的什么东西，没答出来，忘记了 美团点评一面： stringbuffer和stringbuilder String和string对象的区别 string运行期间将新的常量放入池中？java.lang.String.intern() 安全的单例模式 如何让一个线程安全的停止http://ibruce.info/2013/12/19/how-to-stop-a-java-thread/ redis数据结构 跨域注入？sql注入？原理。为啥#可以防sql注入？$不行 线程池，coresize=10，maxsize=50，queue=20，100个请求，几个线程？40个请求呢？ 一致性hash算法？真实节点挂了，虚拟节点如何分配？ hashmap，concurrenthashmap底层结构 concurrenthashmap get是否加锁 http格式，状态码？403？302？502？等 countdownlatch，cyclicbarrier，semaphore Jvm内存结构，一个对象怎么进入老年代？ sychronized和reentrantlock实现原理 对象A依赖B，B依赖C，C依赖A，ioc容器如何加载 Spring用到的动态代理？区别？jdk动态代理入参？ 二面： 项目讨论 mvn jar包依赖，冲突jar包选哪一个？ 通过域名请求mvc接口的处理流程 模板设计模式 Mysql索引左匹配原则 如何优化一条sql语句 一个接口比较耗时，如何定位哪里耗时？ 饿了吗一面： 自我介绍 信贷、反欺诈介绍 反欺诈实现方式讨论 Java面向对象三大特性，解释 drools版本讨论，drools并行执行研究？ Jvm内存模型？对象的生命周期？ spring ioc原理？ spring bean的加载过程？ 二面： 跳台阶算法 硬币算法 linux：线程数？ 三面： Redis数据类型？用到的版本？不同版本的区别？增加经纬度功能？ Mybatis mapper的sql，如何做单元测试？用到了多少配置文件？每个配置文件如何加载（原理）？ 公众号如何知道用户处于登录态的？oauth的原理？ 公众号下单如何实现的？ 虚拟系统的讨论。。。 毕业论文做的什么？英文翻译翻译的什么？ 四面： 遇到的技术难点？如何解决？你做了什么？ 反转链表 阿里一面 信贷介绍 风控数据流程如何控制的？ drools原理 innodb锁、索引，事务（特性），隔离级别，mvcc如何实现？一致性非锁定读 你觉得自己对java基础掌握的怎么样？ java锁介绍，轻量级-&gt;重量级 concurrenthashmap，hashtable区别，都是线程安全的，实现方式有啥区别？。hashmap， 二面内存模型虚拟机多线程 mysql索引如何设计where条件如何利用索引 事务的四大特性和隔离级别 项目难点及解决分布式系统一致性问题，幂等jvm虚拟机内存模型gc分代回收和gc算法代码最重要什么地方java死锁及解决接口超时，排查 小米金融一面： 信贷项目介绍 drools讨论 链表反转算法 数组合并算法 手写单例模式 二面： redis哪些场景使用？Redis分布式锁和zk的区别 哪些场景用到线程池？和单线程的区别？ 冒泡排序算法 手写工厂模式 画泳道图 好的代码？ 对账系统怎么处理异常的？ 三面： 项目中做了那一块？那一块有难点？怎么解决的？ 你认为java那一块比较熟悉？多线程？io？网络？ 链表查找中间节点算法 平时读什么书？读了哪些知识？ 学习java读的什么书？那一章让你印象深刻？ 2345 list：arraylist，linkedlist spring ioc aop 单例模式 合并有序链表，二分查找 Jvm引用类型 线程状态 N个线程n个资源如何解决死锁 平安 除了redis，是否了解其他缓存？ 使用到redis的什么？ Redis分布式锁导致的问题讨论？ http和https的区别？https的原理？ http使用的版本？各版本区别？网络调优？ nio，bio 了解其他的哪些网络协议？比如thrift Redis集群如何部署的？ Mysql集群如何部署的？]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试知识点整理]]></title>
    <url>%2F2018%2F02%2F26%2F%E9%9D%A2%E8%AF%95%2F%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[java基础集合IO(BIO和NIO)并发web基础springIOCAOP事务mysqlredis设计模式单例算法项目用了什么技术， 遇到了什么难点， 是怎么解决的包括：设计、技术等等]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20-骰子求和]]></title>
    <url>%2F2018%2F02%2F23%2F%E7%AE%97%E6%B3%95%2Flintcode%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F20-%E9%AA%B0%E5%AD%90%E6%B1%82%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目扔 n 个骰子，向上面的数字之和为 S。给定 Given n，请列出所有可能的 S 值及其相应的概率。You do not care about the accuracy of the result, we will help you to output results.样例给定 n = 1，返回 [ [1, 0.17], [2, 0.17], [3, 0.17], [4, 0.17], [5, 0.17], [6, 0.17]]。 分析 1、如果是n个骰子，那么可能的区间是n到6*n，不会出现n~6n中某个数字表达不出来的情况证明：有n个相同的容量为6的豌豆筒，6n个豌豆刚好放在这n个筒中，所以n个骰子可以表达出6n，当从任意筒中去一个豌豆，还剩6n-1个豌豆，所以n个骰子可以表达6n-1。如果某个筒中只剩一个豌豆则不再取，因为是一个一个取出的，所以6n-1到n都可以表示。 2创建一个数组，每一行代表每一种情况，第一行代表一个骰子的情况，第二行代表两个投资的情况，第三行代表三个骰子的情况。。。假设有n个骰子，总的点数和为sum，那么在前面n-1个骰子的情况，最后一个可以有Sum-1、Sum-2、Sum-3、Sum-4、Sum-5、Sum-6的六种情况，而最后的那个骰子有下面的情况：（n-1，sum-1）：第n个骰子扔出了1，等同n-1个骰子扔出了sum-1的情况。（n-1，sum-2）：第n个骰子扔出了2，等同n-1个骰子扔出了sum-2的情况。（n-1，sum-3）：第n个骰子扔出了3，等同n-1个骰子扔出了sum-3的情况。（n-1，sum-4）：第n个骰子扔出了4，等同n-1个骰子扔出了sum-4的情况。（n-1，sum-5）：第n个骰子扔出了5，等同n-1个骰子扔出了sum-5的情况。（n-1，sum-6）：第n个骰子扔出了6，等同n-1个骰子扔出了sum-6的情况。 那么n个骰子扔出了sum的情况等于上面六种情况相加。 n = 1时：f(1,1) = f(1,2) = f(1,3) = f(1,4) = f(1,5) = f(1,6) = 1而 n = 2时：f(2,2) = f(1,1) = 1f(2,3) = f(1,2) + f(1,1) = 2…f(2,6) = f(1,5) + f(1,4) + f(1,3) + f(1,2) + f(1,1)f(2,7) = f(1,6) + f(1,5) + f(1,4) + f(1,3) + f(1,2) + f(1,1) = 6 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Solution &#123; /** * @param n an integer * @return a list of Map.Entry&lt;sum, probability&gt; */ public List&lt;Map.Entry&lt;Integer, Double&gt;&gt; dicesSum(int n) &#123; long[][] dp = new long[n + 1][6 * n + 1]; dp[1][1] = 1; dp[1][2] = 1; dp[1][3] = 1; dp[1][4] = 1; dp[1][5] = 1; dp[1][6] = 1; for (int i = 2; i &lt;= n; i++) &#123; for (int j = i; j &lt;= i * 6; j++) &#123; long x1 = 0, x2 = 0, x3 = 0, x4 = 0, x5 = 0, x6 = 0; if (j - 1 &gt; 0) &#123; x1 = dp[i - 1][j - 1]; &#125; if (j - 2 &gt; 0) &#123; x2 = dp[i - 1][j - 2]; &#125; if (j - 3 &gt; 0) &#123; x3 = dp[i - 1][j - 3]; &#125; if (j - 4 &gt; 0) &#123; x4 = dp[i - 1][j - 4]; &#125; if (j - 5 &gt; 0) &#123; x5 = dp[i - 1][j - 5]; &#125; if (j - 6 &gt; 0) &#123; x6 = dp[i - 1][j - 6]; &#125; dp[i][j] = x1 + x2 + x3 + x4 + x5 + x6; &#125; &#125; List&lt;Map.Entry&lt;Integer, Double&gt;&gt; result = new ArrayList&lt;&gt;(); for (int i = n; i &lt;= 6 * n; i++) &#123; AbstractMap.SimpleEntry&lt;Integer, Double&gt; entry = new AbstractMap.SimpleEntry&lt;&gt;(i, dp[n][i] / Math.pow(6, n)); result.add(entry); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>lintcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摔跤吧，爸爸]]></title>
    <url>%2F2018%2F02%2F17%2F%E8%AF%BB%E4%B9%A6%E8%A7%82%E5%BD%B1%2F%E7%94%B5%E5%BD%B1%2F%E6%91%94%E8%B7%A4%E5%90%A7%EF%BC%8C%E7%88%B8%E7%88%B8%2F</url>
    <content type="text"><![CDATA[1、印度很多人为什么不吃肉在印度的观念里，肉是不洁的，吃肉会污染身体，会受到神的厌恶，吃肉的就只有下等人 种姓制度（贱籍制度）一种以血统论为基础的社会体系，曾在印度、孟加拉国、斯里兰卡等国普遍存在，其中以印度最为严重，随雅利安人入侵印度而创立的社会制度，可以确保本身雅利安人的执政权和保持各种工作都有一定的人数，1947年印度脱离殖民体系独立后，种姓制度的法律地位正式被废除，各种种姓分类与歧视被视为非法，然而在实际社会运作与生活上，其仍扮演相当重要的角色 印度种姓制度里面，婆罗门（僧侣贵族），刹帝利（军事贵族和行政贵族），吠舍（普通雅利安人，政治上没有特权），首陀罗（被征服的土著居民，属于非雅利安人）实际上就是一个比较洁与不结的分类。越是高种姓越是素食主义者。四种性之下还有贱民，只有贱民才吃肉。(来自百度百科) 2、一位伟大的父亲运用自己的智慧，在每次吉塔即将脱轨的时候，都把她拉回来了1）、童年与父亲对抗，后来，父亲大闹婚礼，女儿们极为不爽，但新娘告诉吉塔，现在停下，只会像她一样，和一个不认识的男人结婚，从此失去自由。2）、吉塔进入体育学院后，开始放纵自己。后来比赛一再败北，与父亲通话后剪了长发3）、与教练冲突，父亲教导，正面迎战 3、不忘初心，方得始终再厉害的人，也都会有过迷茫。唯一能做的就是不断改变并清晰了解自己，且在一件事上长久坚持。始终明确自己的方向]]></content>
      <categories>
        <category>生活</category>
        <category>电影</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重新定义团队]]></title>
    <url>%2F2018%2F02%2F17%2F%E8%AF%BB%E4%B9%A6%E8%A7%82%E5%BD%B1%2F%E4%B9%A6%E7%B1%8D%2F%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E5%9B%A2%E9%98%9F%2F</url>
    <content type="text"><![CDATA[1、在工作中竭尽所能的工人是最难得的。如果得不到应有的认可，就不能寄希望于他们毫无保留地奉献……]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[激荡十年，水大鱼大]]></title>
    <url>%2F2018%2F02%2F08%2F%E8%AF%BB%E4%B9%A6%E8%A7%82%E5%BD%B1%2F%E4%B9%A6%E7%B1%8D%2F%E6%BF%80%E8%8D%A1%E5%8D%81%E5%B9%B4%EF%BC%8C%E6%B0%B4%E5%A4%A7%E9%B1%BC%E5%A4%A7%2F</url>
    <content type="text"><![CDATA[1、成功了，就是一道风景，失败了，就是美好回忆。这世界上总有一些人好像老在做着让人察觉不到的小事，还总是失败，还总是不放弃。 2、书中引李白诗：却顾所来径，苍苍横翠微作为90后，未曾参与其中的浩荡，却为前人叹息 3、腾讯创造的是生态链式服务，将熟人圈效应放大。阿里建造的是一体化的帝国，完全展现出了互联网的能量。滴滴，美团则是腕足用户的刚需。手机已成为身体一部分。 4、书中文：青春年代的每一次荒唐都是闪光的，它也许经不起推敲，却没有人有资格去嘲笑它。一直泡在产品里的马化腾对此的体会也许最深，他在今年的一次演讲中感慨地说：“创新永远属于年轻人。可能你什么错都没有，最后就是错在自己太老了。”不必等待，在下一个时间窗口到来之前做好当前时间窗口的事情，这个时间窗口可以是一天，一周或者一月 5、平凡的自己，不必强求伟大的人生，社会的发展必然存在各种压迫，不公，不必做无谓的抱怨，只要自身努力做到前20%就可以活的很开心。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南京有意思的餐厅整理-新街口]]></title>
    <url>%2F2018%2F02%2F07%2F%E7%94%9F%E6%B4%BB%2F%E5%90%83%E5%96%9D%E7%8E%A9%E4%B9%90%2F%E5%8D%97%E4%BA%AC%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E9%A4%90%E5%8E%85-%E6%96%B0%E8%A1%97%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[1、初见-淮海路50号(南京银行楼上)这货不是冰淇淋，罗密欧与朱丽叶，荷塘月色，芝士奶油焗番薯，主厨最爱蒜爆鱼 2、壹树轻食-石鼓路环亚广场东方名苑B座2609室3、桂满陇-中山路德基广场一期7楼4、伦敦茶馆来源：http://www.sohu.com/a/115128284_378183]]></content>
      <categories>
        <category>生活</category>
        <category>吃喝玩乐</category>
      </categories>
      <tags>
        <tag>吃喝玩乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机详解]]></title>
    <url>%2F2018%2F02%2F01%2Fjava%2FJVM%2F%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、JVM原理 Java编译器只要面向JVM，生成JVM能理解的代码或字节码文件。Java源文件经编译成字节码程序，通过JVM将每一条指令翻译成不同平台机器码，通过特定平台运行。 二、JVM体系结构 {width=650 height=330 title=”JVM体系结构”} 1、JVM栈内存 - Stack 栈中存储的是StackFrame(栈帧), StackFrame包含三类信息 局部变量表： 存储一个类中方法所用到的局部变量。 执行环境： 保存解析器对java字节码解释过程中需要的信息。包括：上次调用的方法，局部变量指针，操作数栈的栈顶和栈底指针 操作数栈: 用于存储运算所需要的操作数和结果。 栈之间关系以及栈和非堆内存的关系图 {width=324, height=552} StackFrame在方法被调用时创建，在某个线程中，某个时间点上，只有一个 框架是活跃的，该框架被称为Current Frame，而框架中的方法被称为Current Method，其中定义的类为Current Class。局部变量和操作数栈上的操作总是引用当前框架。当Stack Frame中方法被执行完之后，或者调用别的StackFrame中的方法时，则当前栈变为另外一个StackFrame。Stack的大小是由两种类 型，固定和动态的，动态类型的栈可以按照线程的需要分配。 2、 Java堆 - Heap 用来存放对象信息，stack代表一种运行时的状态，栈是运行时单位，解决程序如何执行的问题，堆是存储的单位，解决数据存储的问题。heap伴随JVM启动创建，负责存储所有对象实例和数组，堆的存储空间和栈一样是不需要连续的 3、程序计数器 - Program Counter Register 当前线程所执行的字节码的行号指示器。在虚拟机的概念模型中，字节码解释器通过这个值去取下一条需要执行的字节码指令 如果线程正在执行的是一个Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java 虚拟机规范中没有规定任何OutOfMemoryError 情况的区域。 4、方法区 - Method Area 在Sun JDK中这块区域对应的为PermanetGeneration，又称为持久代。方法区域存放了所加载的类的信息（名称、修饰符等）、类中的静态变量、类中定义为final类型的常量、类中的Field信息、类中的方法信息，当开发人员在程序中通过Class对象中的getName、isInterface等方法来获取信息时，这些数据都来源于方法区域，同时方法区域也是全局共享的，在一定的条件下它也会被GC，当方法区域需要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息。 5、运行时常量池 - Runtime Constant Pool 存放的为类中的固定的常量信息、方法和Field的引用信息等，其空间从方法区域中分配。 6、本地方法堆栈 - Native Method Stacks JVM采用本地方法堆栈来支持native方法的执行，此区域用于存储每个native方法调用的状态。]]></content>
      <categories>
        <category>java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用]]></title>
    <url>%2F2018%2F01%2F26%2F%E5%B7%A5%E5%85%B7%2Fgit%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[git命令删除分支删除本地分支git branch -d branchNamegit push origin :branchName 删除远程分支git branch -d -r origin/branchNamegit push origin :branchName]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ByteBuf源码解析]]></title>
    <url>%2F2018%2F01%2F26%2Fjava%E6%A1%86%E6%9E%B6%2Fnetty%2FByteBuf%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一、ByteBuf概述1、ByteBuf和ByteBuffer的区别 ByteBuf重新实现了一个缓冲区，ByteBuffer只使用一个position指针来记录当前的读写位置，ByteBuf使用了两个指针readerIndex和writerIndex分别记录读写位置 ByteBuffer是一个固定长度的缓冲区，当put方法要写的数据大于可写的容量时会抛出异常。ByteBuf支持自动扩容。 和ByteBuffer一样，ByteBuf也支持堆内缓冲区和堆外直接缓冲区，如果是底层IO处理线程的缓冲区使用堆外直接缓冲区，减少一次IO复制。业务消息的编解码使用堆内缓冲区，提高分配效率，而且不涉及内核缓冲区的复制问题。 ByteBuf的堆内缓冲区分为内存池缓冲区PooledByteBuf和普通内存缓冲区UnpooledHeapByteBuf。PooledByteBuf采用二叉树来实现一个内存池，几种管理内存的分配和释放，不用每次都新建一个缓冲区对象。UnpooledHeapByteBuf每次都会新建一个缓冲区对象。高并发下可以使用PooledByteBuf节约内存的分配 2、ByteBuf的特点可以自定义缓冲类型通过内置的复合缓冲类型，实现零拷贝不需要flip()切换读写模式读取和写入索引分来引用计数Pooling(池) 3、实现机制 ByteBuf实际是在一个抽象的字节数组byte[]上进行读写的集合。提供两个指针变量支持读写操作：readerIndex和writerIndex。 在对象初始化时，readerIndex和writerIndex的值为0，随着读写操作的进行。会增加，不过readerIndex不能超过writerIndex。 在进行读取操作后，0到readerIndex之间的空间会被discard，调用ByteBuf的discardReadBytes方法可以对这部分空间释放重用。类似ByteBuffer的compact操作，对缓冲区进行压缩。 readerIndex到writerIndex的空间相当于ByteBuffer的position到limit的空间，可以对其进行读取，writerIndex到capacity的空间相当于ByteBuffer的limit到capacity的空间，可以继续写入。 二、四种内存分配方式1、UnpooledHeapByteBufUnppooledHeapByteBuf是一个非线程池实现的在堆内存进行内存分配的字节缓冲区，在每次IO操作时都会去创建UnpooledHeapByteBuf对象，如果频繁会对性能有影响。 2、PooledByteBuf在Netty4后加入了内存池管理，比ByteBuf的创建性能有所提高1）、PoolArena在内存分配中，为了能够集中管理内存的分配和释放，同时提高分配和释放的性能，一般都会预先分配一大块连续的内存。就叫做memory Arena。PoolArena是Netty的内存池实现类。在Netty中，PoolArena是由多个Chunk组成的，每个Chunk由多个Page组成。PoolArena是由Chunk和Page共同组织和管理的。2）、PoolChunkpage 可以用来分配的最小内存块单位Chunk page的集合PoolChunk主要负责内存块的分配和释放，chunk中的page会构成一颗二叉树，默认page是8k，chunk的大小是2^11page，即16M，构成11层的二叉树。最下面一层叶子节点有8192个，和page数目一样每个节点会记录自己在Memory Area的偏移地址，当一个节点表示的内存区域被分配后该节点会标识为已分配。该节点的所有子节点的内存请求会被忽略。3）、PoolSubpage当对于小于一个Page的内存分配的时候，每个Page会被划分为大小相等的内存块，他的大小是根据第一次申请内存分配的内存块大小决定一个Page只能分配与第一次内存分配的内存块大小相等的内存块，如果想申请大小不相等的内存块，只能在新的Page上申请内存分配。Page中的存储区域的使用情况是通过一个Long数组bitmap来维护的，每一位表示一个区域的占用情况 3、PooledDirectByteBuf1）、创建字节缓冲区由于内存池实现，每次创建字节缓冲区的时候，不是直接new，而是从内存池中去获取，然后设置引用计数器和读写Index，和缓冲区最大容量返回。2）、复制字节缓冲区实例copy方法可以复制一个字节缓冲区实例，与原缓冲区独立首先要对index和length进行合法性判断，然后调用PooledByteBufAllocator的directBuffer方法分配一个新的缓冲区。newDirectBuffer方法是一个抽象方法，对于不同的子类有不同的实现。如果是unpooled的话，会直接创建一个新的缓冲区，如果是pooled的话，它会从内存池中获取一个可用的缓冲区。 4、UnpooledDirectByteBufUnpooledDirectByteBuf是一个聚合对象，内部维护了一个java.nio.ByteBuffer的直接对外内存空间，释放UnpooledDirectByteBuf中堆外内存的时机，就是在UnpooledDirectByteBuf被java垃圾回收的时候，应该于此同时需要释放指向的堆外内存，但堆外内存不受JVM GC的管理，所以我们只有感知到UnpooledDirectByteBuf被JVM虚拟机回收后（虚引用），手动去释放堆外内存 三、规避内存泄漏1、为什么要有引用计数器 Netty里四种主要的ByteBuf 其中UnpooledHeapByteBuf底下的byte[]能够依赖JVM GC自然回收，而UnpooledDirectByteBuf底下u吃DirectByteBuf，除了等JVM GC，最好也能主动进行回收；而PooledHeapByteBuf和PoolDirectByteBuf，则必须要主动将用完的byte[]/ByteBuffer放回到池里，否则内存就要爆掉。所以，Netty的ByteBuf需要在JVM的GC机制之外，有自己的引用计数器和回收过程 2、引用计数器常识 计数器基于 AtomicIntegerFieldUpdater，因为ByteBuf对象很多，如果都把int包一层AtomicInteger花销较大，而AtomicIntegerFieldUpdater只需要一个全局的静态变量。所有ByteBuf的引用计数器初始值为1。 调用release()，将计数器减1，等于零时， deallocate()被调用，各种回收。 调用retain()，将计数器加1，即使ByteBuf在别的地方被人release()了，在本Class没喊cut之前，不要把它释放掉。 由duplicate(), slice()和order(ByteOrder)所创建的ByteBuf，与原对象共享底下的buffer，也共享引用计数器，所以它们经常需要调用retain()来显示自己的存在。 当引用计数器为0，底下的buffer已被回收，即使ByteBuf对象还在，对它的各种访问操作都会抛出异常。 3、谁来负责Release 在C时代，我们喜欢让malloc和free成对出现，而在Netty里，因为Handler链的存在，ByteBuf经常要传递到下一个Hanlder去而不复还，所以规则变成了谁是最后使用者，谁负责释放。 若出现异常情况，ByteBuf没有成功传递到下一个Hanlder，还在自己地界里的话，一定要进行释放。 谁最后谁负责 InBound Message假设每一个Handler都把消息往下传，Handler并也不知道谁是启动Netty时所设定的Handler链的最后一员，所以Netty会在Handler链的最末补一个TailHandler，如果此时消息仍然是ReferenceCounted类型就会被release掉。 OutBound Message要发送的消息通常由应用所创建，并调用 ctx.writeAndFlush(msg) 进入Handler链。在每一个Handler中的处理类似InBound Message，最后消息会来到HeadHandler，再经过一轮复杂的调用，在flush完成后终将被release掉。 4、内存泄漏检测 内存泄漏，主要是针对池化的ByteBuf。ByteBuf对象被JVM GC掉之前，没有调用release()去把底下的DirectByteBuffer或byte[]归还到池里，会导致池越来越大。 非池化的ByteBuf，即使像DirectByteBuf那样可能会用到System.gc()，但终归会被release掉的，不会出大事。 四、堆外内存的回收机制1、堆外内存JVM启动时分配的内存，称为堆内存，与之相对，在代码中可以使用堆外内存，但是这部分内存不归JVM管理，GC算法不会对其进行回收 2、堆外内存的申请和释放JDK的ByteBuffer类提供一个接口allocateDirect(int capacity)进行堆外内存的申请，底层通过unsafe.allocateMemory(size)实现 最底层是通过malloc方法申请的，但是这块内存需要进行手动释放，JVM并不会进行回收，Unsafe提供了另一个接口freeMemory可以对申请的堆外内存进行释放。 3、堆外内存的回收机制JDK中使用DirectByteBuffer对象来表示堆外内存，每个DirectByteBuffer对象在初始化时，都会创建一个对用的Cleaner对象，这个Cleaner对象会在合适的时候执行unsafe.freeMemory(address)，从而回收这块堆外内存。 当初始化一块堆外内存时，对象的引用关系如下：其中first是Cleaner类的静态变量，Cleaner对象在初始化时会被添加到Clener链表中，和first形成引用关系，ReferenceQueue是用来保存需要回收的Cleaner对象。 如果该DirectByteBuffer对象在一次GC中被回收了此时，只有Cleaner对象唯一保存了堆外内存的数据（开始地址、大小和容量），在下一次FGC时，把该Cleaner对象放入到ReferenceQueue中，并触发clean方法。 Cleaner对象的clean方法主要有两个作用：1、把自身从Clener链表删除，从而在下次GC时能够被回收2、释放堆外内存 123456789public void run() &#123; if (address == 0) &#123; // Paranoia return; &#125; unsafe.freeMemory(address); address = 0; Bits.unreserveMemory(size, capacity);&#125; 如果JVM一直没有执行FGC的话，无效的Cleaner对象就无法放入到ReferenceQueue中，从而堆外内存也一直得不到释放，内存岂不是会爆？ 其实在初始化DirectByteBuffer对象时，如果当前堆外内存的条件很苛刻时，会主动调用System.gc()强制执行FGC。]]></content>
      <categories>
        <category>java框架</category>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap源码分析]]></title>
    <url>%2F2018%2F01%2F24%2Fjava%2F%E6%BA%90%E7%A0%81%2F%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%2FhashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1、HashMap的几个成员变量 transient Node[] table;table是一个Node[]数组类型，而Node实际上就是一个单向链表。哈希表的”key-value键值对”都是存储在Node数组中的。 transient int size;size是HashMap的大小，它是HashMap保存的键值对的数量。 int threshold;threshold是HashMap的阈值，用于判断是否需要调整HashMap的容量。threshold的值=”容量*加载因子”，当HashMap中存储数据的数量达到threshold时（size&gt;=threshold），就需要将HashMap的容量加倍。 final float loadFactor;loadFactor就是加载因子。 2、构造函数1234567891011121314151617181920212223242526272829303132333435363738394041//找出“大于Capacity”的最小的2的幂,使Hash表的容量保持为2的次方倍//算法的思想：通过使用逻辑运算来替代取余，这里有一个规律，就是当N为2的次方（Power of two），那么X％N==X&amp;(N-1)。static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; //&gt;&gt;&gt; 无符号右移,高位补0 n |= n &gt;&gt;&gt; 2; //a|=b的意思就是把a和b按位或然后赋值给a n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125;//构造一个带指定初始容量和加载因子的空HashMappublic HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);&#125;//构造一个带指定初始容量和默认加载因子(0.75)的空 HashMappublic HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;//构造一个具有默认初始容量 (16)和默认加载因子 (0.75)的空 HashMappublic HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted&#125;//构造一个映射关系与指定 Map相同的新 HashMap,容量与指定Map容量相同，加载因子为默认的0.75public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);&#125; 3.put函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public V put(K key, V value) &#123; // 对key的hashCode()做hash return putVal(hash(key), key, value, false, true);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //判断数组table是否为空，或者tab长度为0，否则执行resize进行扩容 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //根据键值key计算hash值得到插入的索引i，若为空则新建节点添加， if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; //判断table[i]的首个元素是否和key一样，相同直接覆盖， if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //table[i]是否为红黑树，是则直接在树中插入键值对 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); //遍历table[i],判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作； //遍历过程中若发现key已经存在直接覆盖value即可； else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; //插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 4.扩容机制123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 超过最大值就不再扩充了，就只好随便碰撞 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 没超过最大值，就扩充为原来的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 计算新的resize上限 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; // 为每个原bucket计算新bucket，把每个bucket都移动到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; // 原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // 原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 5、hashmap的线程安全问题1)、并发的多线程使用场景中使用HashMap，在resize过程中可能造成死循环2)、fail-fast在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，fail-fast策略 6、hashCode和equals1234567/** JNI，调用底层其它语言实现 */ public native int hashCode(); /** 默认同==，直接比较对象 */ public boolean equals(Object obj) &#123; return (this == obj); &#125; 重写equals方法 自反性： 对于任何非空引用值 x，x.equals(x) 都应返回true 对称性： 对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回true 传递性： 对于任何非空引用值x、y和z，如果x.equals(y) 返回true，并且y.equals(z)返回true，那么x.equals(z)应返回true 一致性： 对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。 对于任何非空引用值x,x.equals(null)都应返回false hashCode要求 同一对象上多次调用hashCode方法，必须返回相同的整数，前提是对象上 equals 比较中所用的信息没有被修改。 如果根据 equals(Object) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode 方法都必须生成相同的整数结果。]]></content>
      <categories>
        <category>java</category>
        <category>jdk源码分析</category>
        <category>集合源码</category>
      </categories>
      <tags>
        <tag>jdk源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AbstractQueuedSynchronizer源码解析]]></title>
    <url>%2F2018%2F01%2F24%2Fjava%2F%E6%BA%90%E7%A0%81%2FJ.U.C%E6%BA%90%E7%A0%81%2FAbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319132013211322132313241325132613271328132913301331133213331334133513361337133813391340134113421343134413451346134713481349135013511352135313541355135613571358135913601361136213631364136513661367136813691370137113721373137413751376137713781379138013811382138313841385138613871388138913901391139213931394139513961397139813991400140114021403140414051406140714081409141014111412141314141415141614171418141914201421142214231424142514261427142814291430143114321433143414351436143714381439144014411442144314441445144614471448144914501451145214531454145514561457145814591460146114621463146414651466146714681469147014711472147314741475147614771478147914801481148214831484148514861487148814891490149114921493149414951496149714981499150015011502150315041505150615071508150915101511151215131514151515161517151815191520152115221523152415251526152715281529153015311532153315341535153615371538153915401541154215431544154515461547154815491550155115521553155415551556155715581559156015611562156315641565156615671568156915701571157215731574157515761577157815791580158115821583158415851586158715881589159015911592159315941595159615971598159916001601160216031604160516061607160816091610161116121613161416151616161716181619162016211622162316241625162616271628162916301631163216331634163516361637163816391640164116421643164416451646164716481649165016511652165316541655165616571658165916601661166216631664166516661667166816691670167116721673167416751676167716781679168016811682168316841685168616871688168916901691169216931694169516961697169816991700170117021703170417051706170717081709171017111712171317141715171617171718171917201721172217231724172517261727172817291730173117321733173417351736173717381739174017411742174317441745174617471748174917501751175217531754175517561757175817591760176117621763176417651766176717681769177017711772177317741775177617771778177917801781178217831784178517861787178817891790179117921793179417951796179717981799180018011802180318041805180618071808180918101811181218131814181518161817181818191820182118221823182418251826182718281829183018311832183318341835183618371838183918401841184218431844184518461847184818491850185118521853185418551856185718581859186018611862186318641865186618671868186918701871187218731874187518761877187818791880188118821883188418851886188718881889189018911892189318941895189618971898189919001901190219031904190519061907190819091910191119121913191419151916191719181919192019211922192319241925192619271928192919301931193219331934193519361937193819391940194119421943194419451946194719481949195019511952195319541955195619571958195919601961196219631964196519661967196819691970197119721973197419751976197719781979198019811982198319841985198619871988198919901991199219931994199519961997199819992000200120022003200420052006200720082009201020112012201320142015201620172018201920202021202220232024202520262027202820292030203120322033203420352036203720382039204020412042204320442045204620472048204920502051205220532054205520562057205820592060206120622063206420652066206720682069207020712072207320742075207620772078207920802081208220832084208520862087208820892090209120922093209420952096209720982099210021012102210321042105210621072108210921102111211221132114211521162117211821192120212121222123212421252126212721282129213021312132213321342135213621372138213921402141214221432144214521462147214821492150215121522153215421552156215721582159216021612162216321642165216621672168216921702171217221732174217521762177217821792180218121822183218421852186218721882189219021912192219321942195219621972198219922002201220222032204220522062207220822092210221122122213221422152216221722182219222022212222222322242225222622272228222922302231223222332234223522362237223822392240224122422243224422452246224722482249225022512252225322542255225622572258225922602261226222632264226522662267226822692270227122722273/** * Provides a framework for implementing blocking locks and related * synchronizers (semaphores, events, etc) that rely on * first-in-first-out (FIFO) wait queues. This class is designed to * be a useful basis for most kinds of synchronizers that rely on a * single atomic &#123;@code int&#125; value to represent state. Subclasses * must define the protected methods that change this state, and which * define what that state means in terms of this object being acquired * or released. Given these, the other methods in this class carry * out all queuing and blocking mechanics. Subclasses can maintain * other state fields, but only the atomically updated &#123;@code int&#125; * value manipulated using methods &#123;@link #getState&#125;, &#123;@link * #setState&#125; and &#123;@link #compareAndSetState&#125; is tracked with respect * to synchronization. * * &lt;p&gt;Subclasses should be defined as non-public internal helper * classes that are used to implement the synchronization properties * of their enclosing class. Class * &#123;@code AbstractQueuedSynchronizer&#125; does not implement any * synchronization interface. Instead it defines methods such as * &#123;@link #acquireInterruptibly&#125; that can be invoked as * appropriate by concrete locks and related synchronizers to * implement their public methods. * * &lt;p&gt;This class supports either or both a default &lt;em&gt;exclusive&lt;/em&gt; * mode and a &lt;em&gt;shared&lt;/em&gt; mode. When acquired in exclusive mode, * attempted acquires by other threads cannot succeed. Shared mode * acquires by multiple threads may (but need not) succeed. This class * does not &amp;quot;understand&amp;quot; these differences except in the * mechanical sense that when a shared mode acquire succeeds, the next * waiting thread (if one exists) must also determine whether it can * acquire as well. Threads waiting in the different modes share the * same FIFO queue. Usually, implementation subclasses support only * one of these modes, but both can come into play for example in a * &#123;@link ReadWriteLock&#125;. Subclasses that support only exclusive or * only shared modes need not define the methods supporting the unused mode. * * &lt;p&gt;This class defines a nested &#123;@link ConditionObject&#125; class that * can be used as a &#123;@link Condition&#125; implementation by subclasses * supporting exclusive mode for which method &#123;@link * #isHeldExclusively&#125; reports whether synchronization is exclusively * held with respect to the current thread, method &#123;@link #release&#125; * invoked with the current &#123;@link #getState&#125; value fully releases * this object, and &#123;@link #acquire&#125;, given this saved state value, * eventually restores this object to its previous acquired state. No * &#123;@code AbstractQueuedSynchronizer&#125; method otherwise creates such a * condition, so if this constraint cannot be met, do not use it. The * behavior of &#123;@link ConditionObject&#125; depends of course on the * semantics of its synchronizer implementation. * * &lt;p&gt;This class provides inspection, instrumentation, and monitoring * methods for the internal queue, as well as similar methods for * condition objects. These can be exported as desired into classes * using an &#123;@code AbstractQueuedSynchronizer&#125; for their * synchronization mechanics. * * &lt;p&gt;Serialization of this class stores only the underlying atomic * integer maintaining state, so deserialized objects have empty * thread queues. Typical subclasses requiring serializability will * define a &#123;@code readObject&#125; method that restores this to a known * initial state upon deserialization. * * &lt;h3&gt;Usage&lt;/h3&gt; * * &lt;p&gt;To use this class as the basis of a synchronizer, redefine the * following methods, as applicable, by inspecting and/or modifying * the synchronization state using &#123;@link #getState&#125;, &#123;@link * #setState&#125; and/or &#123;@link #compareAndSetState&#125;: * * &lt;ul&gt; * &lt;li&gt; &#123;@link #tryAcquire&#125; * &lt;li&gt; &#123;@link #tryRelease&#125; * &lt;li&gt; &#123;@link #tryAcquireShared&#125; * &lt;li&gt; &#123;@link #tryReleaseShared&#125; * &lt;li&gt; &#123;@link #isHeldExclusively&#125; * &lt;/ul&gt; * * Each of these methods by default throws &#123;@link * UnsupportedOperationException&#125;. Implementations of these methods * must be internally thread-safe, and should in general be short and * not block. Defining these methods is the &lt;em&gt;only&lt;/em&gt; supported * means of using this class. All other methods are declared * &#123;@code final&#125; because they cannot be independently varied. * * &lt;p&gt;You may also find the inherited methods from &#123;@link * AbstractOwnableSynchronizer&#125; useful to keep track of the thread * owning an exclusive synchronizer. You are encouraged to use them * -- this enables monitoring and diagnostic tools to assist users in * determining which threads hold locks. * * &lt;p&gt;Even though this class is based on an internal FIFO queue, it * does not automatically enforce FIFO acquisition policies. The core * of exclusive synchronization takes the form: * * &lt;pre&gt; * Acquire: * while (!tryAcquire(arg)) &#123; * &lt;em&gt;enqueue thread if it is not already queued&lt;/em&gt;; * &lt;em&gt;possibly block current thread&lt;/em&gt;; * &#125; * * Release: * if (tryRelease(arg)) * &lt;em&gt;unblock the first queued thread&lt;/em&gt;; * &lt;/pre&gt; * * (Shared mode is similar but may involve cascading signals.) * * &lt;p id="barging"&gt;Because checks in acquire are invoked before * enqueuing, a newly acquiring thread may &lt;em&gt;barge&lt;/em&gt; ahead of * others that are blocked and queued. However, you can, if desired, * define &#123;@code tryAcquire&#125; and/or &#123;@code tryAcquireShared&#125; to * disable barging by internally invoking one or more of the inspection * methods, thereby providing a &lt;em&gt;fair&lt;/em&gt; FIFO acquisition order. * In particular, most fair synchronizers can define &#123;@code tryAcquire&#125; * to return &#123;@code false&#125; if &#123;@link #hasQueuedPredecessors&#125; (a method * specifically designed to be used by fair synchronizers) returns * &#123;@code true&#125;. Other variations are possible. * * &lt;p&gt;Throughput and scalability are generally highest for the * default barging (also known as &lt;em&gt;greedy&lt;/em&gt;, * &lt;em&gt;renouncement&lt;/em&gt;, and &lt;em&gt;convoy-avoidance&lt;/em&gt;) strategy. * While this is not guaranteed to be fair or starvation-free, earlier * queued threads are allowed to recontend before later queued * threads, and each recontention has an unbiased chance to succeed * against incoming threads. Also, while acquires do not * &amp;quot;spin&amp;quot; in the usual sense, they may perform multiple * invocations of &#123;@code tryAcquire&#125; interspersed with other * computations before blocking. This gives most of the benefits of * spins when exclusive synchronization is only briefly held, without * most of the liabilities when it isn't. If so desired, you can * augment this by preceding calls to acquire methods with * "fast-path" checks, possibly prechecking &#123;@link #hasContended&#125; * and/or &#123;@link #hasQueuedThreads&#125; to only do so if the synchronizer * is likely not to be contended. * * &lt;p&gt;This class provides an efficient and scalable basis for * synchronization in part by specializing its range of use to * synchronizers that can rely on &#123;@code int&#125; state, acquire, and * release parameters, and an internal FIFO wait queue. When this does * not suffice, you can build synchronizers from a lower level using * &#123;@link java.util.concurrent.atomic atomic&#125; classes, your own custom * &#123;@link java.util.Queue&#125; classes, and &#123;@link LockSupport&#125; blocking * support. * * &lt;h3&gt;Usage Examples&lt;/h3&gt; * * &lt;p&gt;Here is a non-reentrant mutual exclusion lock class that uses * the value zero to represent the unlocked state, and one to * represent the locked state. While a non-reentrant lock * does not strictly require recording of the current owner * thread, this class does so anyway to make usage easier to monitor. * It also supports conditions and exposes * one of the instrumentation methods: * * &lt;pre&gt; &#123;@code * class Mutex implements Lock, java.io.Serializable &#123; * * // Our internal helper class * private static class Sync extends AbstractQueuedSynchronizer &#123; * // Reports whether in locked state * protected boolean isHeldExclusively() &#123; * return getState() == 1; * &#125; * * // Acquires the lock if state is zero * public boolean tryAcquire(int acquires) &#123; * assert acquires == 1; // Otherwise unused * if (compareAndSetState(0, 1)) &#123; * setExclusiveOwnerThread(Thread.currentThread()); * return true; * &#125; * return false; * &#125; * * // Releases the lock by setting state to zero * protected boolean tryRelease(int releases) &#123; * assert releases == 1; // Otherwise unused * if (getState() == 0) throw new IllegalMonitorStateException(); * setExclusiveOwnerThread(null); * setState(0); * return true; * &#125; * * // Provides a Condition * Condition newCondition() &#123; return new ConditionObject(); &#125; * * // Deserializes properly * private void readObject(ObjectInputStream s) * throws IOException, ClassNotFoundException &#123; * s.defaultReadObject(); * setState(0); // reset to unlocked state * &#125; * &#125; * * // The sync object does all the hard work. We just forward to it. * private final Sync sync = new Sync(); * * public void lock() &#123; sync.acquire(1); &#125; * public boolean tryLock() &#123; return sync.tryAcquire(1); &#125; * public void unlock() &#123; sync.release(1); &#125; * public Condition newCondition() &#123; return sync.newCondition(); &#125; * public boolean isLocked() &#123; return sync.isHeldExclusively(); &#125; * public boolean hasQueuedThreads() &#123; return sync.hasQueuedThreads(); &#125; * public void lockInterruptibly() throws InterruptedException &#123; * sync.acquireInterruptibly(1); * &#125; * public boolean tryLock(long timeout, TimeUnit unit) * throws InterruptedException &#123; * return sync.tryAcquireNanos(1, unit.toNanos(timeout)); * &#125; * &#125;&#125;&lt;/pre&gt; * * &lt;p&gt;Here is a latch class that is like a * &#123;@link java.util.concurrent.CountDownLatch CountDownLatch&#125; * except that it only requires a single &#123;@code signal&#125; to * fire. Because a latch is non-exclusive, it uses the &#123;@code shared&#125; * acquire and release methods. * * &lt;pre&gt; &#123;@code * class BooleanLatch &#123; * * private static class Sync extends AbstractQueuedSynchronizer &#123; * boolean isSignalled() &#123; return getState() != 0; &#125; * * protected int tryAcquireShared(int ignore) &#123; * return isSignalled() ? 1 : -1; * &#125; * * protected boolean tryReleaseShared(int ignore) &#123; * setState(1); * return true; * &#125; * &#125; * * private final Sync sync = new Sync(); * public boolean isSignalled() &#123; return sync.isSignalled(); &#125; * public void signal() &#123; sync.releaseShared(1); &#125; * public void await() throws InterruptedException &#123; * sync.acquireSharedInterruptibly(1); * &#125; * &#125;&#125;&lt;/pre&gt; * * @since 1.5 * @author Doug Lea */public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable &#123; private static final long serialVersionUID = 7373984972572414691L; /** * Creates a new &#123;@code AbstractQueuedSynchronizer&#125; instance * with initial synchronization state of zero. */ protected AbstractQueuedSynchronizer() &#123; &#125; /** * Wait queue node class. * * &lt;p&gt;The wait queue is a variant of a "CLH" (Craig, Landin, and * Hagersten) lock queue. CLH locks are normally used for * spinlocks. We instead use them for blocking synchronizers, but * use the same basic tactic of holding some of the control * information about a thread in the predecessor of its node. A * "status" field in each node keeps track of whether a thread * should block. A node is signalled when its predecessor * releases. Each node of the queue otherwise serves as a * specific-notification-style monitor holding a single waiting * thread. The status field does NOT control whether threads are * granted locks etc though. A thread may try to acquire if it is * first in the queue. But being first does not guarantee success; * it only gives the right to contend. So the currently released * contender thread may need to rewait. * * &lt;p&gt;To enqueue into a CLH lock, you atomically splice it in as new * tail. To dequeue, you just set the head field. * &lt;pre&gt; * +------+ prev +-----+ +-----+ * head | | &lt;---- | | &lt;---- | | tail * +------+ +-----+ +-----+ * &lt;/pre&gt; * * &lt;p&gt;Insertion into a CLH queue requires only a single atomic * operation on "tail", so there is a simple atomic point of * demarcation from unqueued to queued. Similarly, dequeuing * involves only updating the "head". However, it takes a bit * more work for nodes to determine who their successors are, * in part to deal with possible cancellation due to timeouts * and interrupts. * * &lt;p&gt;The "prev" links (not used in original CLH locks), are mainly * needed to handle cancellation. If a node is cancelled, its * successor is (normally) relinked to a non-cancelled * predecessor. For explanation of similar mechanics in the case * of spin locks, see the papers by Scott and Scherer at * http://www.cs.rochester.edu/u/scott/synchronization/ * * &lt;p&gt;We also use "next" links to implement blocking mechanics. * The thread id for each node is kept in its own node, so a * predecessor signals the next node to wake up by traversing * next link to determine which thread it is. Determination of * successor must avoid races with newly queued nodes to set * the "next" fields of their predecessors. This is solved * when necessary by checking backwards from the atomically * updated "tail" when a node's successor appears to be null. * (Or, said differently, the next-links are an optimization * so that we don't usually need a backward scan.) * * &lt;p&gt;Cancellation introduces some conservatism to the basic * algorithms. Since we must poll for cancellation of other * nodes, we can miss noticing whether a cancelled node is * ahead or behind us. This is dealt with by always unparking * successors upon cancellation, allowing them to stabilize on * a new predecessor, unless we can identify an uncancelled * predecessor who will carry this responsibility. * * &lt;p&gt;CLH queues need a dummy header node to get started. But * we don't create them on construction, because it would be wasted * effort if there is never contention. Instead, the node * is constructed and head and tail pointers are set upon first * contention. * * &lt;p&gt;Threads waiting on Conditions use the same nodes, but * use an additional link. Conditions only need to link nodes * in simple (non-concurrent) linked queues because they are * only accessed when exclusively held. Upon await, a node is * inserted into a condition queue. Upon signal, the node is * transferred to the main queue. A special value of status * field is used to mark which queue a node is on. * * &lt;p&gt;Thanks go to Dave Dice, Mark Moir, Victor Luchangco, Bill * Scherer and Michael Scott, along with members of JSR-166 * expert group, for helpful ideas, discussions, and critiques * on the design of this class. */ static final class Node &#123; /** Marker to indicate a node is waiting in shared mode */ static final Node SHARED = new Node(); /** Marker to indicate a node is waiting in exclusive mode */ static final Node EXCLUSIVE = null; /** waitStatus value to indicate thread has cancelled */ static final int CANCELLED = 1; /** waitStatus value to indicate successor's thread needs unparking */ static final int SIGNAL = -1; /** waitStatus value to indicate thread is waiting on condition */ static final int CONDITION = -2; /** * waitStatus value to indicate the next acquireShared should * unconditionally propagate */ static final int PROPAGATE = -3; /** * Status field, taking on only the values: * SIGNAL: The successor of this node is (or will soon be) * blocked (via park), so the current node must * unpark its successor when it releases or * cancels. To avoid races, acquire methods must * first indicate they need a signal, * then retry the atomic acquire, and then, * on failure, block. * CANCELLED: This node is cancelled due to timeout or interrupt. * Nodes never leave this state. In particular, * a thread with cancelled node never again blocks. * CONDITION: This node is currently on a condition queue. * It will not be used as a sync queue node * until transferred, at which time the status * will be set to 0. (Use of this value here has * nothing to do with the other uses of the * field, but simplifies mechanics.) * PROPAGATE: A releaseShared should be propagated to other * nodes. This is set (for head node only) in * doReleaseShared to ensure propagation * continues, even if other operations have * since intervened. * 0: None of the above * * The values are arranged numerically to simplify use. * Non-negative values mean that a node doesn't need to * signal. So, most code doesn't need to check for particular * values, just for sign. * * The field is initialized to 0 for normal sync nodes, and * CONDITION for condition nodes. It is modified using CAS * (or when possible, unconditional volatile writes). */ volatile int waitStatus; /** * Link to predecessor node that current node/thread relies on * for checking waitStatus. Assigned during enqueuing, and nulled * out (for sake of GC) only upon dequeuing. Also, upon * cancellation of a predecessor, we short-circuit while * finding a non-cancelled one, which will always exist * because the head node is never cancelled: A node becomes * head only as a result of successful acquire. A * cancelled thread never succeeds in acquiring, and a thread only * cancels itself, not any other node. */ volatile Node prev; /** * Link to the successor node that the current node/thread * unparks upon release. Assigned during enqueuing, adjusted * when bypassing cancelled predecessors, and nulled out (for * sake of GC) when dequeued. The enq operation does not * assign next field of a predecessor until after attachment, * so seeing a null next field does not necessarily mean that * node is at end of queue. However, if a next field appears * to be null, we can scan prev's from the tail to * double-check. The next field of cancelled nodes is set to * point to the node itself instead of null, to make life * easier for isOnSyncQueue. */ volatile Node next; /** * The thread that enqueued this node. Initialized on * construction and nulled out after use. */ volatile Thread thread; /** * Link to next node waiting on condition, or the special * value SHARED. Because condition queues are accessed only * when holding in exclusive mode, we just need a simple * linked queue to hold nodes while they are waiting on * conditions. They are then transferred to the queue to * re-acquire. And because conditions can only be exclusive, * we save a field by using special value to indicate shared * mode. */ Node nextWaiter; /** * Returns true if node is waiting in shared mode. */ final boolean isShared() &#123; return nextWaiter == SHARED; &#125; /** * Returns previous node, or throws NullPointerException if null. * Use when predecessor cannot be null. The null check could * be elided, but is present to help the VM. * * @return the predecessor of this node */ final Node predecessor() throws NullPointerException &#123; Node p = prev; if (p == null) throw new NullPointerException(); else return p; &#125; Node() &#123; // Used to establish initial head or SHARED marker &#125; Node(Thread thread, Node mode) &#123; // Used by addWaiter this.nextWaiter = mode; this.thread = thread; &#125; Node(Thread thread, int waitStatus) &#123; // Used by Condition this.waitStatus = waitStatus; this.thread = thread; &#125; &#125; /** * Head of the wait queue, lazily initialized. Except for * initialization, it is modified only via method setHead. Note: * If head exists, its waitStatus is guaranteed not to be * CANCELLED. */ private transient volatile Node head; /** * Tail of the wait queue, lazily initialized. Modified only via * method enq to add new wait node. */ private transient volatile Node tail; /** * The synchronization state. */ private volatile int state; /** * Returns the current value of synchronization state. * This operation has memory semantics of a &#123;@code volatile&#125; read. * @return current state value */ protected final int getState() &#123; return state; &#125; /** * Sets the value of synchronization state. * This operation has memory semantics of a &#123;@code volatile&#125; write. * @param newState the new state value */ protected final void setState(int newState) &#123; state = newState; &#125; /** * Atomically sets synchronization state to the given updated * value if the current state value equals the expected value. * This operation has memory semantics of a &#123;@code volatile&#125; read * and write. * * @param expect the expected value * @param update the new value * @return &#123;@code true&#125; if successful. False return indicates that the actual * value was not equal to the expected value. */ protected final boolean compareAndSetState(int expect, int update) &#123; // See below for intrinsics setup to support this return unsafe.compareAndSwapInt(this, stateOffset, expect, update); &#125; // Queuing utilities /** * The number of nanoseconds for which it is faster to spin * rather than to use timed park. A rough estimate suffices * to improve responsiveness with very short timeouts. */ static final long spinForTimeoutThreshold = 1000L; /** * Inserts node into queue, initializing if necessary. See picture above. * @param node the node to insert * @return node's predecessor */ private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125; &#125; /** * Creates and enqueues node for current thread and given mode. * * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared * @return the new node */ private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; enq(node); return node; &#125; /** * Sets head of queue to be node, thus dequeuing. Called only by * acquire methods. Also nulls out unused fields for sake of GC * and to suppress unnecessary signals and traversals. * * @param node the node */ private void setHead(Node node) &#123; head = node; node.thread = null; node.prev = null; &#125; /** * Wakes up node's successor, if one exists. * * @param node the node */ private void unparkSuccessor(Node node) &#123; /* * If status is negative (i.e., possibly needing signal) try * to clear in anticipation of signalling. It is OK if this * fails or if status is changed by waiting thread. */ int ws = node.waitStatus; if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); /* * Thread to unpark is held in successor, which is normally * just the next node. But if cancelled or apparently null, * traverse backwards from tail to find the actual * non-cancelled successor. */ Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) LockSupport.unpark(s.thread); &#125; /** * Release action for shared mode -- signals successor and ensures * propagation. (Note: For exclusive mode, release just amounts * to calling unparkSuccessor of head if it needs signal.) */ private void doReleaseShared() &#123; /* * Ensure that a release propagates, even if there are other * in-progress acquires/releases. This proceeds in the usual * way of trying to unparkSuccessor of head if it needs * signal. But if it does not, status is set to PROPAGATE to * ensure that upon release, propagation continues. * Additionally, we must loop in case a new node is added * while we are doing this. Also, unlike other uses of * unparkSuccessor, we need to know if CAS to reset status * fails, if so rechecking. */ for (;;) &#123; Node h = head; if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; if (ws == Node.SIGNAL) &#123; if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases unparkSuccessor(h); &#125; else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; if (h == head) // loop if head changed break; &#125; &#125; /** * Sets head of queue, and checks if successor may be waiting * in shared mode, if so propagating if either propagate &gt; 0 or * PROPAGATE status was set. * * @param node the node * @param propagate the return value from a tryAcquireShared */ private void setHeadAndPropagate(Node node, int propagate) &#123; Node h = head; // Record old head for check below setHead(node); /* * Try to signal next queued node if: * Propagation was indicated by caller, * or was recorded (as h.waitStatus either before * or after setHead) by a previous operation * (note: this uses sign-check of waitStatus because * PROPAGATE status may transition to SIGNAL.) * and * The next node is waiting in shared mode, * or we don't know, because it appears null * * The conservatism in both of these checks may cause * unnecessary wake-ups, but only when there are multiple * racing acquires/releases, so most need signals now or soon * anyway. */ if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) &#123; Node s = node.next; if (s == null || s.isShared()) doReleaseShared(); &#125; &#125; // Utilities for various versions of acquire /** * Cancels an ongoing attempt to acquire. * * @param node the node */ private void cancelAcquire(Node node) &#123; // Ignore if node doesn't exist if (node == null) return; node.thread = null; // Skip cancelled predecessors Node pred = node.prev; while (pred.waitStatus &gt; 0) node.prev = pred = pred.prev; // predNext is the apparent node to unsplice. CASes below will // fail if not, in which case, we lost race vs another cancel // or signal, so no further action is necessary. Node predNext = pred.next; // Can use unconditional write instead of CAS here. // After this atomic step, other Nodes can skip past us. // Before, we are free of interference from other threads. node.waitStatus = Node.CANCELLED; // If we are the tail, remove ourselves. if (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123; compareAndSetNext(pred, predNext, null); &#125; else &#123; // If successor needs signal, try to set pred's next-link // so it will get one. Otherwise wake it up to propagate. int ws; if (pred != head &amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread != null) &#123; Node next = node.next; if (next != null &amp;&amp; next.waitStatus &lt;= 0) compareAndSetNext(pred, predNext, next); &#125; else &#123; unparkSuccessor(node); &#125; node.next = node; // help GC &#125; &#125; /** * Checks and updates status for a node that failed to acquire. * Returns true if thread should block. This is the main signal * control in all acquire loops. Requires that pred == node.prev. * * @param pred node's predecessor holding status * @param node the node * @return &#123;@code true&#125; if thread should block */ private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; int ws = pred.waitStatus; if (ws == Node.SIGNAL) /* * This node has already set status asking a release * to signal it, so it can safely park. */ return true; if (ws &gt; 0) &#123; /* * Predecessor was cancelled. Skip over predecessors and * indicate retry. */ do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; /* * waitStatus must be 0 or PROPAGATE. Indicate that we * need a signal, but don't park yet. Caller will need to * retry to make sure it cannot acquire before parking. */ compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false; &#125; /** * Convenience method to interrupt current thread. */ static void selfInterrupt() &#123; Thread.currentThread().interrupt(); &#125; /** * Convenience method to park and then check if interrupted * * @return &#123;@code true&#125; if interrupted */ private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); return Thread.interrupted(); &#125; /* * Various flavors of acquire, varying in exclusive/shared and * control modes. Each is mostly the same, but annoyingly * different. Only a little bit of factoring is possible due to * interactions of exception mechanics (including ensuring that we * cancel if tryAcquire throws exception) and other control, at * least not without hurting performance too much. */ /** * Acquires in exclusive uninterruptible mode for thread already in * queue. Used by condition wait methods as well as acquire. * * @param node the node * @param arg the acquire argument * @return &#123;@code true&#125; if interrupted while waiting */ final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; /** * Acquires in exclusive interruptible mode. * @param arg the acquire argument */ private void doAcquireInterruptibly(int arg) throws InterruptedException &#123; final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; /** * Acquires in exclusive timed mode. * * @param arg the acquire argument * @param nanosTimeout max wait time * @return &#123;@code true&#125; if acquired */ private boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (nanosTimeout &lt;= 0L) return false; final long deadline = System.nanoTime() + nanosTimeout; final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return true; &#125; nanosTimeout = deadline - System.nanoTime(); if (nanosTimeout &lt;= 0L) return false; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold) LockSupport.parkNanos(this, nanosTimeout); if (Thread.interrupted()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; /** * Acquires in shared uninterruptible mode. * @param arg the acquire argument */ private void doAcquireShared(int arg) &#123; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; /** * Acquires in shared interruptible mode. * @param arg the acquire argument */ private void doAcquireSharedInterruptibly(int arg) throws InterruptedException &#123; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; /** * Acquires in shared timed mode. * * @param arg the acquire argument * @param nanosTimeout max wait time * @return &#123;@code true&#125; if acquired */ private boolean doAcquireSharedNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (nanosTimeout &lt;= 0L) return false; final long deadline = System.nanoTime() + nanosTimeout; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return true; &#125; &#125; nanosTimeout = deadline - System.nanoTime(); if (nanosTimeout &lt;= 0L) return false; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold) LockSupport.parkNanos(this, nanosTimeout); if (Thread.interrupted()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; // Main exported methods /** * Attempts to acquire in exclusive mode. This method should query * if the state of the object permits it to be acquired in the * exclusive mode, and if so to acquire it. * * &lt;p&gt;This method is always invoked by the thread performing * acquire. If this method reports failure, the acquire method * may queue the thread, if it is not already queued, until it is * signalled by a release from some other thread. This can be used * to implement method &#123;@link Lock#tryLock()&#125;. * * &lt;p&gt;The default * implementation throws &#123;@link UnsupportedOperationException&#125;. * * @param arg the acquire argument. This value is always the one * passed to an acquire method, or is the value saved on entry * to a condition wait. The value is otherwise uninterpreted * and can represent anything you like. * @return &#123;@code true&#125; if successful. Upon success, this object has * been acquired. * @throws IllegalMonitorStateException if acquiring would place this * synchronizer in an illegal state. This exception must be * thrown in a consistent fashion for synchronization to work * correctly. * @throws UnsupportedOperationException if exclusive mode is not supported */ protected boolean tryAcquire(int arg) &#123; throw new UnsupportedOperationException(); &#125; /** * Attempts to set the state to reflect a release in exclusive * mode. * * &lt;p&gt;This method is always invoked by the thread performing release. * * &lt;p&gt;The default implementation throws * &#123;@link UnsupportedOperationException&#125;. * * @param arg the release argument. This value is always the one * passed to a release method, or the current state value upon * entry to a condition wait. The value is otherwise * uninterpreted and can represent anything you like. * @return &#123;@code true&#125; if this object is now in a fully released * state, so that any waiting threads may attempt to acquire; * and &#123;@code false&#125; otherwise. * @throws IllegalMonitorStateException if releasing would place this * synchronizer in an illegal state. This exception must be * thrown in a consistent fashion for synchronization to work * correctly. * @throws UnsupportedOperationException if exclusive mode is not supported */ protected boolean tryRelease(int arg) &#123; throw new UnsupportedOperationException(); &#125; /** * Attempts to acquire in shared mode. This method should query if * the state of the object permits it to be acquired in the shared * mode, and if so to acquire it. * * &lt;p&gt;This method is always invoked by the thread performing * acquire. If this method reports failure, the acquire method * may queue the thread, if it is not already queued, until it is * signalled by a release from some other thread. * * &lt;p&gt;The default implementation throws &#123;@link * UnsupportedOperationException&#125;. * * @param arg the acquire argument. This value is always the one * passed to an acquire method, or is the value saved on entry * to a condition wait. The value is otherwise uninterpreted * and can represent anything you like. * @return a negative value on failure; zero if acquisition in shared * mode succeeded but no subsequent shared-mode acquire can * succeed; and a positive value if acquisition in shared * mode succeeded and subsequent shared-mode acquires might * also succeed, in which case a subsequent waiting thread * must check availability. (Support for three different * return values enables this method to be used in contexts * where acquires only sometimes act exclusively.) Upon * success, this object has been acquired. * @throws IllegalMonitorStateException if acquiring would place this * synchronizer in an illegal state. This exception must be * thrown in a consistent fashion for synchronization to work * correctly. * @throws UnsupportedOperationException if shared mode is not supported */ protected int tryAcquireShared(int arg) &#123; throw new UnsupportedOperationException(); &#125; /** * Attempts to set the state to reflect a release in shared mode. * * &lt;p&gt;This method is always invoked by the thread performing release. * * &lt;p&gt;The default implementation throws * &#123;@link UnsupportedOperationException&#125;. * * @param arg the release argument. This value is always the one * passed to a release method, or the current state value upon * entry to a condition wait. The value is otherwise * uninterpreted and can represent anything you like. * @return &#123;@code true&#125; if this release of shared mode may permit a * waiting acquire (shared or exclusive) to succeed; and * &#123;@code false&#125; otherwise * @throws IllegalMonitorStateException if releasing would place this * synchronizer in an illegal state. This exception must be * thrown in a consistent fashion for synchronization to work * correctly. * @throws UnsupportedOperationException if shared mode is not supported */ protected boolean tryReleaseShared(int arg) &#123; throw new UnsupportedOperationException(); &#125; /** * Returns &#123;@code true&#125; if synchronization is held exclusively with * respect to the current (calling) thread. This method is invoked * upon each call to a non-waiting &#123;@link ConditionObject&#125; method. * (Waiting methods instead invoke &#123;@link #release&#125;.) * * &lt;p&gt;The default implementation throws &#123;@link * UnsupportedOperationException&#125;. This method is invoked * internally only within &#123;@link ConditionObject&#125; methods, so need * not be defined if conditions are not used. * * @return &#123;@code true&#125; if synchronization is held exclusively; * &#123;@code false&#125; otherwise * @throws UnsupportedOperationException if conditions are not supported */ protected boolean isHeldExclusively() &#123; throw new UnsupportedOperationException(); &#125; /** * Acquires in exclusive mode, ignoring interrupts. Implemented * by invoking at least once &#123;@link #tryAcquire&#125;, * returning on success. Otherwise the thread is queued, possibly * repeatedly blocking and unblocking, invoking &#123;@link * #tryAcquire&#125; until success. This method can be used * to implement method &#123;@link Lock#lock&#125;. * * @param arg the acquire argument. This value is conveyed to * &#123;@link #tryAcquire&#125; but is otherwise uninterpreted and * can represent anything you like. */ public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); &#125; /** * Acquires in exclusive mode, aborting if interrupted. * Implemented by first checking interrupt status, then invoking * at least once &#123;@link #tryAcquire&#125;, returning on * success. Otherwise the thread is queued, possibly repeatedly * blocking and unblocking, invoking &#123;@link #tryAcquire&#125; * until success or the thread is interrupted. This method can be * used to implement method &#123;@link Lock#lockInterruptibly&#125;. * * @param arg the acquire argument. This value is conveyed to * &#123;@link #tryAcquire&#125; but is otherwise uninterpreted and * can represent anything you like. * @throws InterruptedException if the current thread is interrupted */ public final void acquireInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (!tryAcquire(arg)) doAcquireInterruptibly(arg); &#125; /** * Attempts to acquire in exclusive mode, aborting if interrupted, * and failing if the given timeout elapses. Implemented by first * checking interrupt status, then invoking at least once &#123;@link * #tryAcquire&#125;, returning on success. Otherwise, the thread is * queued, possibly repeatedly blocking and unblocking, invoking * &#123;@link #tryAcquire&#125; until success or the thread is interrupted * or the timeout elapses. This method can be used to implement * method &#123;@link Lock#tryLock(long, TimeUnit)&#125;. * * @param arg the acquire argument. This value is conveyed to * &#123;@link #tryAcquire&#125; but is otherwise uninterpreted and * can represent anything you like. * @param nanosTimeout the maximum number of nanoseconds to wait * @return &#123;@code true&#125; if acquired; &#123;@code false&#125; if timed out * @throws InterruptedException if the current thread is interrupted */ public final boolean tryAcquireNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); return tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout); &#125; /** * Releases in exclusive mode. Implemented by unblocking one or * more threads if &#123;@link #tryRelease&#125; returns true. * This method can be used to implement method &#123;@link Lock#unlock&#125;. * * @param arg the release argument. This value is conveyed to * &#123;@link #tryRelease&#125; but is otherwise uninterpreted and * can represent anything you like. * @return the value returned from &#123;@link #tryRelease&#125; */ public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false; &#125; /** * Acquires in shared mode, ignoring interrupts. Implemented by * first invoking at least once &#123;@link #tryAcquireShared&#125;, * returning on success. Otherwise the thread is queued, possibly * repeatedly blocking and unblocking, invoking &#123;@link * #tryAcquireShared&#125; until success. * * @param arg the acquire argument. This value is conveyed to * &#123;@link #tryAcquireShared&#125; but is otherwise uninterpreted * and can represent anything you like. */ public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg); &#125; /** * Acquires in shared mode, aborting if interrupted. Implemented * by first checking interrupt status, then invoking at least once * &#123;@link #tryAcquireShared&#125;, returning on success. Otherwise the * thread is queued, possibly repeatedly blocking and unblocking, * invoking &#123;@link #tryAcquireShared&#125; until success or the thread * is interrupted. * @param arg the acquire argument. * This value is conveyed to &#123;@link #tryAcquireShared&#125; but is * otherwise uninterpreted and can represent anything * you like. * @throws InterruptedException if the current thread is interrupted */ public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg); &#125; /** * Attempts to acquire in shared mode, aborting if interrupted, and * failing if the given timeout elapses. Implemented by first * checking interrupt status, then invoking at least once &#123;@link * #tryAcquireShared&#125;, returning on success. Otherwise, the * thread is queued, possibly repeatedly blocking and unblocking, * invoking &#123;@link #tryAcquireShared&#125; until success or the thread * is interrupted or the timeout elapses. * * @param arg the acquire argument. This value is conveyed to * &#123;@link #tryAcquireShared&#125; but is otherwise uninterpreted * and can represent anything you like. * @param nanosTimeout the maximum number of nanoseconds to wait * @return &#123;@code true&#125; if acquired; &#123;@code false&#125; if timed out * @throws InterruptedException if the current thread is interrupted */ public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); return tryAcquireShared(arg) &gt;= 0 || doAcquireSharedNanos(arg, nanosTimeout); &#125; /** * Releases in shared mode. Implemented by unblocking one or more * threads if &#123;@link #tryReleaseShared&#125; returns true. * * @param arg the release argument. This value is conveyed to * &#123;@link #tryReleaseShared&#125; but is otherwise uninterpreted * and can represent anything you like. * @return the value returned from &#123;@link #tryReleaseShared&#125; */ public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false; &#125; // Queue inspection methods /** * Queries whether any threads are waiting to acquire. Note that * because cancellations due to interrupts and timeouts may occur * at any time, a &#123;@code true&#125; return does not guarantee that any * other thread will ever acquire. * * &lt;p&gt;In this implementation, this operation returns in * constant time. * * @return &#123;@code true&#125; if there may be other threads waiting to acquire */ public final boolean hasQueuedThreads() &#123; return head != tail; &#125; /** * Queries whether any threads have ever contended to acquire this * synchronizer; that is if an acquire method has ever blocked. * * &lt;p&gt;In this implementation, this operation returns in * constant time. * * @return &#123;@code true&#125; if there has ever been contention */ public final boolean hasContended() &#123; return head != null; &#125; /** * Returns the first (longest-waiting) thread in the queue, or * &#123;@code null&#125; if no threads are currently queued. * * &lt;p&gt;In this implementation, this operation normally returns in * constant time, but may iterate upon contention if other threads are * concurrently modifying the queue. * * @return the first (longest-waiting) thread in the queue, or * &#123;@code null&#125; if no threads are currently queued */ public final Thread getFirstQueuedThread() &#123; // handle only fast path, else relay return (head == tail) ? null : fullGetFirstQueuedThread(); &#125; /** * Version of getFirstQueuedThread called when fastpath fails */ private Thread fullGetFirstQueuedThread() &#123; /* * The first node is normally head.next. Try to get its * thread field, ensuring consistent reads: If thread * field is nulled out or s.prev is no longer head, then * some other thread(s) concurrently performed setHead in * between some of our reads. We try this twice before * resorting to traversal. */ Node h, s; Thread st; if (((h = head) != null &amp;&amp; (s = h.next) != null &amp;&amp; s.prev == head &amp;&amp; (st = s.thread) != null) || ((h = head) != null &amp;&amp; (s = h.next) != null &amp;&amp; s.prev == head &amp;&amp; (st = s.thread) != null)) return st; /* * Head's next field might not have been set yet, or may have * been unset after setHead. So we must check to see if tail * is actually first node. If not, we continue on, safely * traversing from tail back to head to find first, * guaranteeing termination. */ Node t = tail; Thread firstThread = null; while (t != null &amp;&amp; t != head) &#123; Thread tt = t.thread; if (tt != null) firstThread = tt; t = t.prev; &#125; return firstThread; &#125; /** * Returns true if the given thread is currently queued. * * &lt;p&gt;This implementation traverses the queue to determine * presence of the given thread. * * @param thread the thread * @return &#123;@code true&#125; if the given thread is on the queue * @throws NullPointerException if the thread is null */ public final boolean isQueued(Thread thread) &#123; if (thread == null) throw new NullPointerException(); for (Node p = tail; p != null; p = p.prev) if (p.thread == thread) return true; return false; &#125; /** * Returns &#123;@code true&#125; if the apparent first queued thread, if one * exists, is waiting in exclusive mode. If this method returns * &#123;@code true&#125;, and the current thread is attempting to acquire in * shared mode (that is, this method is invoked from &#123;@link * #tryAcquireShared&#125;) then it is guaranteed that the current thread * is not the first queued thread. Used only as a heuristic in * ReentrantReadWriteLock. */ final boolean apparentlyFirstQueuedIsExclusive() &#123; Node h, s; return (h = head) != null &amp;&amp; (s = h.next) != null &amp;&amp; !s.isShared() &amp;&amp; s.thread != null; &#125; /** * Queries whether any threads have been waiting to acquire longer * than the current thread. * * &lt;p&gt;An invocation of this method is equivalent to (but may be * more efficient than): * &lt;pre&gt; &#123;@code * getFirstQueuedThread() != Thread.currentThread() &amp;&amp; * hasQueuedThreads()&#125;&lt;/pre&gt; * * &lt;p&gt;Note that because cancellations due to interrupts and * timeouts may occur at any time, a &#123;@code true&#125; return does not * guarantee that some other thread will acquire before the current * thread. Likewise, it is possible for another thread to win a * race to enqueue after this method has returned &#123;@code false&#125;, * due to the queue being empty. * * &lt;p&gt;This method is designed to be used by a fair synchronizer to * avoid &lt;a href="AbstractQueuedSynchronizer#barging"&gt;barging&lt;/a&gt;. * Such a synchronizer's &#123;@link #tryAcquire&#125; method should return * &#123;@code false&#125;, and its &#123;@link #tryAcquireShared&#125; method should * return a negative value, if this method returns &#123;@code true&#125; * (unless this is a reentrant acquire). For example, the &#123;@code * tryAcquire&#125; method for a fair, reentrant, exclusive mode * synchronizer might look like this: * * &lt;pre&gt; &#123;@code * protected boolean tryAcquire(int arg) &#123; * if (isHeldExclusively()) &#123; * // A reentrant acquire; increment hold count * return true; * &#125; else if (hasQueuedPredecessors()) &#123; * return false; * &#125; else &#123; * // try to acquire normally * &#125; * &#125;&#125;&lt;/pre&gt; * * @return &#123;@code true&#125; if there is a queued thread preceding the * current thread, and &#123;@code false&#125; if the current thread * is at the head of the queue or the queue is empty * @since 1.7 */ public final boolean hasQueuedPredecessors() &#123; // The correctness of this depends on head being initialized // before tail and on head.next being accurate if the current // thread is first in queue. Node t = tail; // Read fields in reverse initialization order Node h = head; Node s; return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread()); &#125; // Instrumentation and monitoring methods /** * Returns an estimate of the number of threads waiting to * acquire. The value is only an estimate because the number of * threads may change dynamically while this method traverses * internal data structures. This method is designed for use in * monitoring system state, not for synchronization * control. * * @return the estimated number of threads waiting to acquire */ public final int getQueueLength() &#123; int n = 0; for (Node p = tail; p != null; p = p.prev) &#123; if (p.thread != null) ++n; &#125; return n; &#125; /** * Returns a collection containing threads that may be waiting to * acquire. Because the actual set of threads may change * dynamically while constructing this result, the returned * collection is only a best-effort estimate. The elements of the * returned collection are in no particular order. This method is * designed to facilitate construction of subclasses that provide * more extensive monitoring facilities. * * @return the collection of threads */ public final Collection&lt;Thread&gt; getQueuedThreads() &#123; ArrayList&lt;Thread&gt; list = new ArrayList&lt;Thread&gt;(); for (Node p = tail; p != null; p = p.prev) &#123; Thread t = p.thread; if (t != null) list.add(t); &#125; return list; &#125; /** * Returns a collection containing threads that may be waiting to * acquire in exclusive mode. This has the same properties * as &#123;@link #getQueuedThreads&#125; except that it only returns * those threads waiting due to an exclusive acquire. * * @return the collection of threads */ public final Collection&lt;Thread&gt; getExclusiveQueuedThreads() &#123; ArrayList&lt;Thread&gt; list = new ArrayList&lt;Thread&gt;(); for (Node p = tail; p != null; p = p.prev) &#123; if (!p.isShared()) &#123; Thread t = p.thread; if (t != null) list.add(t); &#125; &#125; return list; &#125; /** * Returns a collection containing threads that may be waiting to * acquire in shared mode. This has the same properties * as &#123;@link #getQueuedThreads&#125; except that it only returns * those threads waiting due to a shared acquire. * * @return the collection of threads */ public final Collection&lt;Thread&gt; getSharedQueuedThreads() &#123; ArrayList&lt;Thread&gt; list = new ArrayList&lt;Thread&gt;(); for (Node p = tail; p != null; p = p.prev) &#123; if (p.isShared()) &#123; Thread t = p.thread; if (t != null) list.add(t); &#125; &#125; return list; &#125; /** * Returns a string identifying this synchronizer, as well as its state. * The state, in brackets, includes the String &#123;@code "State ="&#125; * followed by the current value of &#123;@link #getState&#125;, and either * &#123;@code "nonempty"&#125; or &#123;@code "empty"&#125; depending on whether the * queue is empty. * * @return a string identifying this synchronizer, as well as its state */ public String toString() &#123; int s = getState(); String q = hasQueuedThreads() ? "non" : ""; return super.toString() + "[State = " + s + ", " + q + "empty queue]"; &#125; // Internal support methods for Conditions /** * Returns true if a node, always one that was initially placed on * a condition queue, is now waiting to reacquire on sync queue. * @param node the node * @return true if is reacquiring */ final boolean isOnSyncQueue(Node node) &#123; if (node.waitStatus == Node.CONDITION || node.prev == null) return false; if (node.next != null) // If has successor, it must be on queue return true; /* * node.prev can be non-null, but not yet on queue because * the CAS to place it on queue can fail. So we have to * traverse from tail to make sure it actually made it. It * will always be near the tail in calls to this method, and * unless the CAS failed (which is unlikely), it will be * there, so we hardly ever traverse much. */ return findNodeFromTail(node); &#125; /** * Returns true if node is on sync queue by searching backwards from tail. * Called only when needed by isOnSyncQueue. * @return true if present */ private boolean findNodeFromTail(Node node) &#123; Node t = tail; for (;;) &#123; if (t == node) return true; if (t == null) return false; t = t.prev; &#125; &#125; /** * Transfers a node from a condition queue onto sync queue. * Returns true if successful. * @param node the node * @return true if successfully transferred (else the node was * cancelled before signal) */ final boolean transferForSignal(Node node) &#123; /* * If cannot change waitStatus, the node has been cancelled. */ if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) return false; /* * Splice onto queue and try to set waitStatus of predecessor to * indicate that thread is (probably) waiting. If cancelled or * attempt to set waitStatus fails, wake up to resync (in which * case the waitStatus can be transiently and harmlessly wrong). */ Node p = enq(node); int ws = p.waitStatus; if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) LockSupport.unpark(node.thread); return true; &#125; /** * Transfers node, if necessary, to sync queue after a cancelled wait. * Returns true if thread was cancelled before being signalled. * * @param node the node * @return true if cancelled before the node was signalled */ final boolean transferAfterCancelledWait(Node node) &#123; if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) &#123; enq(node); return true; &#125; /* * If we lost out to a signal(), then we can't proceed * until it finishes its enq(). Cancelling during an * incomplete transfer is both rare and transient, so just * spin. */ while (!isOnSyncQueue(node)) Thread.yield(); return false; &#125; /** * Invokes release with current state value; returns saved state. * Cancels node and throws exception on failure. * @param node the condition node for this wait * @return previous sync state */ final int fullyRelease(Node node) &#123; boolean failed = true; try &#123; int savedState = getState(); if (release(savedState)) &#123; failed = false; return savedState; &#125; else &#123; throw new IllegalMonitorStateException(); &#125; &#125; finally &#123; if (failed) node.waitStatus = Node.CANCELLED; &#125; &#125; // Instrumentation methods for conditions /** * Queries whether the given ConditionObject * uses this synchronizer as its lock. * * @param condition the condition * @return &#123;@code true&#125; if owned * @throws NullPointerException if the condition is null */ public final boolean owns(ConditionObject condition) &#123; return condition.isOwnedBy(this); &#125; /** * Queries whether any threads are waiting on the given condition * associated with this synchronizer. Note that because timeouts * and interrupts may occur at any time, a &#123;@code true&#125; return * does not guarantee that a future &#123;@code signal&#125; will awaken * any threads. This method is designed primarily for use in * monitoring of the system state. * * @param condition the condition * @return &#123;@code true&#125; if there are any waiting threads * @throws IllegalMonitorStateException if exclusive synchronization * is not held * @throws IllegalArgumentException if the given condition is * not associated with this synchronizer * @throws NullPointerException if the condition is null */ public final boolean hasWaiters(ConditionObject condition) &#123; if (!owns(condition)) throw new IllegalArgumentException("Not owner"); return condition.hasWaiters(); &#125; /** * Returns an estimate of the number of threads waiting on the * given condition associated with this synchronizer. Note that * because timeouts and interrupts may occur at any time, the * estimate serves only as an upper bound on the actual number of * waiters. This method is designed for use in monitoring of the * system state, not for synchronization control. * * @param condition the condition * @return the estimated number of waiting threads * @throws IllegalMonitorStateException if exclusive synchronization * is not held * @throws IllegalArgumentException if the given condition is * not associated with this synchronizer * @throws NullPointerException if the condition is null */ public final int getWaitQueueLength(ConditionObject condition) &#123; if (!owns(condition)) throw new IllegalArgumentException("Not owner"); return condition.getWaitQueueLength(); &#125; /** * Returns a collection containing those threads that may be * waiting on the given condition associated with this * synchronizer. Because the actual set of threads may change * dynamically while constructing this result, the returned * collection is only a best-effort estimate. The elements of the * returned collection are in no particular order. * * @param condition the condition * @return the collection of threads * @throws IllegalMonitorStateException if exclusive synchronization * is not held * @throws IllegalArgumentException if the given condition is * not associated with this synchronizer * @throws NullPointerException if the condition is null */ public final Collection&lt;Thread&gt; getWaitingThreads(ConditionObject condition) &#123; if (!owns(condition)) throw new IllegalArgumentException("Not owner"); return condition.getWaitingThreads(); &#125; /** * Condition implementation for a &#123;@link * AbstractQueuedSynchronizer&#125; serving as the basis of a &#123;@link * Lock&#125; implementation. * * &lt;p&gt;Method documentation for this class describes mechanics, * not behavioral specifications from the point of view of Lock * and Condition users. Exported versions of this class will in * general need to be accompanied by documentation describing * condition semantics that rely on those of the associated * &#123;@code AbstractQueuedSynchronizer&#125;. * * &lt;p&gt;This class is Serializable, but all fields are transient, * so deserialized conditions have no waiters. */ public class ConditionObject implements Condition, java.io.Serializable &#123; private static final long serialVersionUID = 1173984872572414699L; /** First node of condition queue. */ private transient Node firstWaiter; /** Last node of condition queue. */ private transient Node lastWaiter; /** * Creates a new &#123;@code ConditionObject&#125; instance. */ public ConditionObject() &#123; &#125; // Internal methods /** * Adds a new waiter to wait queue. * @return its new wait node */ private Node addConditionWaiter() &#123; Node t = lastWaiter; // If lastWaiter is cancelled, clean out. if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123; unlinkCancelledWaiters(); t = lastWaiter; &#125; Node node = new Node(Thread.currentThread(), Node.CONDITION); if (t == null) firstWaiter = node; else t.nextWaiter = node; lastWaiter = node; return node; &#125; /** * Removes and transfers nodes until hit non-cancelled one or * null. Split out from signal in part to encourage compilers * to inline the case of no waiters. * @param first (non-null) the first node on condition queue */ private void doSignal(Node first) &#123; do &#123; if ( (firstWaiter = first.nextWaiter) == null) lastWaiter = null; first.nextWaiter = null; &#125; while (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != null); &#125; /** * Removes and transfers all nodes. * @param first (non-null) the first node on condition queue */ private void doSignalAll(Node first) &#123; lastWaiter = firstWaiter = null; do &#123; Node next = first.nextWaiter; first.nextWaiter = null; transferForSignal(first); first = next; &#125; while (first != null); &#125; /** * Unlinks cancelled waiter nodes from condition queue. * Called only while holding lock. This is called when * cancellation occurred during condition wait, and upon * insertion of a new waiter when lastWaiter is seen to have * been cancelled. This method is needed to avoid garbage * retention in the absence of signals. So even though it may * require a full traversal, it comes into play only when * timeouts or cancellations occur in the absence of * signals. It traverses all nodes rather than stopping at a * particular target to unlink all pointers to garbage nodes * without requiring many re-traversals during cancellation * storms. */ private void unlinkCancelledWaiters() &#123; Node t = firstWaiter; Node trail = null; while (t != null) &#123; Node next = t.nextWaiter; if (t.waitStatus != Node.CONDITION) &#123; t.nextWaiter = null; if (trail == null) firstWaiter = next; else trail.nextWaiter = next; if (next == null) lastWaiter = trail; &#125; else trail = t; t = next; &#125; &#125; // public methods /** * Moves the longest-waiting thread, if one exists, from the * wait queue for this condition to the wait queue for the * owning lock. * * @throws IllegalMonitorStateException if &#123;@link #isHeldExclusively&#125; * returns &#123;@code false&#125; */ public final void signal() &#123; if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) doSignal(first); &#125; /** * Moves all threads from the wait queue for this condition to * the wait queue for the owning lock. * * @throws IllegalMonitorStateException if &#123;@link #isHeldExclusively&#125; * returns &#123;@code false&#125; */ public final void signalAll() &#123; if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) doSignalAll(first); &#125; /** * Implements uninterruptible condition wait. * &lt;ol&gt; * &lt;li&gt; Save lock state returned by &#123;@link #getState&#125;. * &lt;li&gt; Invoke &#123;@link #release&#125; with saved state as argument, * throwing IllegalMonitorStateException if it fails. * &lt;li&gt; Block until signalled. * &lt;li&gt; Reacquire by invoking specialized version of * &#123;@link #acquire&#125; with saved state as argument. * &lt;/ol&gt; */ public final void awaitUninterruptibly() &#123; Node node = addConditionWaiter(); int savedState = fullyRelease(node); boolean interrupted = false; while (!isOnSyncQueue(node)) &#123; LockSupport.park(this); if (Thread.interrupted()) interrupted = true; &#125; if (acquireQueued(node, savedState) || interrupted) selfInterrupt(); &#125; /* * For interruptible waits, we need to track whether to throw * InterruptedException, if interrupted while blocked on * condition, versus reinterrupt current thread, if * interrupted while blocked waiting to re-acquire. */ /** Mode meaning to reinterrupt on exit from wait */ private static final int REINTERRUPT = 1; /** Mode meaning to throw InterruptedException on exit from wait */ private static final int THROW_IE = -1; /** * Checks for interrupt, returning THROW_IE if interrupted * before signalled, REINTERRUPT if after signalled, or * 0 if not interrupted. */ private int checkInterruptWhileWaiting(Node node) &#123; return Thread.interrupted() ? (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) : 0; &#125; /** * Throws InterruptedException, reinterrupts current thread, or * does nothing, depending on mode. */ private void reportInterruptAfterWait(int interruptMode) throws InterruptedException &#123; if (interruptMode == THROW_IE) throw new InterruptedException(); else if (interruptMode == REINTERRUPT) selfInterrupt(); &#125; /** * Implements interruptible condition wait. * &lt;ol&gt; * &lt;li&gt; If current thread is interrupted, throw InterruptedException. * &lt;li&gt; Save lock state returned by &#123;@link #getState&#125;. * &lt;li&gt; Invoke &#123;@link #release&#125; with saved state as argument, * throwing IllegalMonitorStateException if it fails. * &lt;li&gt; Block until signalled or interrupted. * &lt;li&gt; Reacquire by invoking specialized version of * &#123;@link #acquire&#125; with saved state as argument. * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException. * &lt;/ol&gt; */ public final void await() throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); Node node = addConditionWaiter(); int savedState = fullyRelease(node); int interruptMode = 0; while (!isOnSyncQueue(node)) &#123; LockSupport.park(this); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; &#125; if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode); &#125; /** * Implements timed condition wait. * &lt;ol&gt; * &lt;li&gt; If current thread is interrupted, throw InterruptedException. * &lt;li&gt; Save lock state returned by &#123;@link #getState&#125;. * &lt;li&gt; Invoke &#123;@link #release&#125; with saved state as argument, * throwing IllegalMonitorStateException if it fails. * &lt;li&gt; Block until signalled, interrupted, or timed out. * &lt;li&gt; Reacquire by invoking specialized version of * &#123;@link #acquire&#125; with saved state as argument. * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException. * &lt;/ol&gt; */ public final long awaitNanos(long nanosTimeout) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); Node node = addConditionWaiter(); int savedState = fullyRelease(node); final long deadline = System.nanoTime() + nanosTimeout; int interruptMode = 0; while (!isOnSyncQueue(node)) &#123; if (nanosTimeout &lt;= 0L) &#123; transferAfterCancelledWait(node); break; &#125; if (nanosTimeout &gt;= spinForTimeoutThreshold) LockSupport.parkNanos(this, nanosTimeout); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; nanosTimeout = deadline - System.nanoTime(); &#125; if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode); return deadline - System.nanoTime(); &#125; /** * Implements absolute timed condition wait. * &lt;ol&gt; * &lt;li&gt; If current thread is interrupted, throw InterruptedException. * &lt;li&gt; Save lock state returned by &#123;@link #getState&#125;. * &lt;li&gt; Invoke &#123;@link #release&#125; with saved state as argument, * throwing IllegalMonitorStateException if it fails. * &lt;li&gt; Block until signalled, interrupted, or timed out. * &lt;li&gt; Reacquire by invoking specialized version of * &#123;@link #acquire&#125; with saved state as argument. * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException. * &lt;li&gt; If timed out while blocked in step 4, return false, else true. * &lt;/ol&gt; */ public final boolean awaitUntil(Date deadline) throws InterruptedException &#123; long abstime = deadline.getTime(); if (Thread.interrupted()) throw new InterruptedException(); Node node = addConditionWaiter(); int savedState = fullyRelease(node); boolean timedout = false; int interruptMode = 0; while (!isOnSyncQueue(node)) &#123; if (System.currentTimeMillis() &gt; abstime) &#123; timedout = transferAfterCancelledWait(node); break; &#125; LockSupport.parkUntil(this, abstime); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; &#125; if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode); return !timedout; &#125; /** * Implements timed condition wait. * &lt;ol&gt; * &lt;li&gt; If current thread is interrupted, throw InterruptedException. * &lt;li&gt; Save lock state returned by &#123;@link #getState&#125;. * &lt;li&gt; Invoke &#123;@link #release&#125; with saved state as argument, * throwing IllegalMonitorStateException if it fails. * &lt;li&gt; Block until signalled, interrupted, or timed out. * &lt;li&gt; Reacquire by invoking specialized version of * &#123;@link #acquire&#125; with saved state as argument. * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException. * &lt;li&gt; If timed out while blocked in step 4, return false, else true. * &lt;/ol&gt; */ public final boolean await(long time, TimeUnit unit) throws InterruptedException &#123; long nanosTimeout = unit.toNanos(time); if (Thread.interrupted()) throw new InterruptedException(); Node node = addConditionWaiter(); int savedState = fullyRelease(node); final long deadline = System.nanoTime() + nanosTimeout; boolean timedout = false; int interruptMode = 0; while (!isOnSyncQueue(node)) &#123; if (nanosTimeout &lt;= 0L) &#123; timedout = transferAfterCancelledWait(node); break; &#125; if (nanosTimeout &gt;= spinForTimeoutThreshold) LockSupport.parkNanos(this, nanosTimeout); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; nanosTimeout = deadline - System.nanoTime(); &#125; if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode); return !timedout; &#125; // support for instrumentation /** * Returns true if this condition was created by the given * synchronization object. * * @return &#123;@code true&#125; if owned */ final boolean isOwnedBy(AbstractQueuedSynchronizer sync) &#123; return sync == AbstractQueuedSynchronizer.this; &#125; /** * Queries whether any threads are waiting on this condition. * Implements &#123;@link AbstractQueuedSynchronizer#hasWaiters(ConditionObject)&#125;. * * @return &#123;@code true&#125; if there are any waiting threads * @throws IllegalMonitorStateException if &#123;@link #isHeldExclusively&#125; * returns &#123;@code false&#125; */ protected final boolean hasWaiters() &#123; if (!isHeldExclusively()) throw new IllegalMonitorStateException(); for (Node w = firstWaiter; w != null; w = w.nextWaiter) &#123; if (w.waitStatus == Node.CONDITION) return true; &#125; return false; &#125; /** * Returns an estimate of the number of threads waiting on * this condition. * Implements &#123;@link AbstractQueuedSynchronizer#getWaitQueueLength(ConditionObject)&#125;. * * @return the estimated number of waiting threads * @throws IllegalMonitorStateException if &#123;@link #isHeldExclusively&#125; * returns &#123;@code false&#125; */ protected final int getWaitQueueLength() &#123; if (!isHeldExclusively()) throw new IllegalMonitorStateException(); int n = 0; for (Node w = firstWaiter; w != null; w = w.nextWaiter) &#123; if (w.waitStatus == Node.CONDITION) ++n; &#125; return n; &#125; /** * Returns a collection containing those threads that may be * waiting on this Condition. * Implements &#123;@link AbstractQueuedSynchronizer#getWaitingThreads(ConditionObject)&#125;. * * @return the collection of threads * @throws IllegalMonitorStateException if &#123;@link #isHeldExclusively&#125; * returns &#123;@code false&#125; */ protected final Collection&lt;Thread&gt; getWaitingThreads() &#123; if (!isHeldExclusively()) throw new IllegalMonitorStateException(); ArrayList&lt;Thread&gt; list = new ArrayList&lt;Thread&gt;(); for (Node w = firstWaiter; w != null; w = w.nextWaiter) &#123; if (w.waitStatus == Node.CONDITION) &#123; Thread t = w.thread; if (t != null) list.add(t); &#125; &#125; return list; &#125; &#125; /** * Setup to support compareAndSet. We need to natively implement * this here: For the sake of permitting future enhancements, we * cannot explicitly subclass AtomicInteger, which would be * efficient and useful otherwise. So, as the lesser of evils, we * natively implement using hotspot intrinsics API. And while we * are at it, we do the same for other CASable fields (which could * otherwise be done with atomic field updaters). */ private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long stateOffset; private static final long headOffset; private static final long tailOffset; private static final long waitStatusOffset; private static final long nextOffset; static &#123; try &#123; stateOffset = unsafe.objectFieldOffset (AbstractQueuedSynchronizer.class.getDeclaredField("state")); headOffset = unsafe.objectFieldOffset (AbstractQueuedSynchronizer.class.getDeclaredField("head")); tailOffset = unsafe.objectFieldOffset (AbstractQueuedSynchronizer.class.getDeclaredField("tail")); waitStatusOffset = unsafe.objectFieldOffset (Node.class.getDeclaredField("waitStatus")); nextOffset = unsafe.objectFieldOffset (Node.class.getDeclaredField("next")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; /** * CAS head field. Used only by enq. */ private final boolean compareAndSetHead(Node update) &#123; return unsafe.compareAndSwapObject(this, headOffset, null, update); &#125; /** * CAS tail field. Used only by enq. */ private final boolean compareAndSetTail(Node expect, Node update) &#123; return unsafe.compareAndSwapObject(this, tailOffset, expect, update); &#125; /** * CAS waitStatus field of a node. */ private static final boolean compareAndSetWaitStatus(Node node, int expect, int update) &#123; return unsafe.compareAndSwapInt(node, waitStatusOffset, expect, update); &#125; /** * CAS next field of a node. */ private static final boolean compareAndSetNext(Node node, Node expect, Node update) &#123; return unsafe.compareAndSwapObject(node, nextOffset, expect, update); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
        <category>jdk源码分析</category>
        <category>J.U.C源码</category>
      </categories>
      <tags>
        <tag>jdk源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReentrantLock源码解析]]></title>
    <url>%2F2018%2F01%2F24%2Fjava%2F%E6%BA%90%E7%A0%81%2FJ.U.C%E6%BA%90%E7%A0%81%2FReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724/** * A reentrant mutual exclusion &#123;@link Lock&#125; with the same basic * behavior and semantics as the implicit monitor lock accessed using * &#123;@code synchronized&#125; methods and statements, but with extended * capabilities. * * &lt;p&gt;A &#123;@code ReentrantLock&#125; is &lt;em&gt;owned&lt;/em&gt; by the thread last * successfully locking, but not yet unlocking it. A thread invoking * &#123;@code lock&#125; will return, successfully acquiring the lock, when * the lock is not owned by another thread. The method will return * immediately if the current thread already owns the lock. This can * be checked using methods &#123;@link #isHeldByCurrentThread&#125;, and &#123;@link * #getHoldCount&#125;. * * &lt;p&gt;The constructor for this class accepts an optional * &lt;em&gt;fairness&lt;/em&gt; parameter. When set &#123;@code true&#125;, under * contention, locks favor granting access to the longest-waiting * thread. Otherwise this lock does not guarantee any particular * access order. Programs using fair locks accessed by many threads * may display lower overall throughput (i.e., are slower; often much * slower) than those using the default setting, but have smaller * variances in times to obtain locks and guarantee lack of * starvation. Note however, that fairness of locks does not guarantee * fairness of thread scheduling. Thus, one of many threads using a * fair lock may obtain it multiple times in succession while other * active threads are not progressing and not currently holding the * lock. * Also note that the untimed &#123;@link #tryLock()&#125; method does not * honor the fairness setting. It will succeed if the lock * is available even if other threads are waiting. * * &lt;p&gt;It is recommended practice to &lt;em&gt;always&lt;/em&gt; immediately * follow a call to &#123;@code lock&#125; with a &#123;@code try&#125; block, most * typically in a before/after construction such as: * * &lt;pre&gt; &#123;@code * class X &#123; * private final ReentrantLock lock = new ReentrantLock(); * // ... * * public void m() &#123; * lock.lock(); // block until condition holds * try &#123; * // ... method body * &#125; finally &#123; * lock.unlock() * &#125; * &#125; * &#125;&#125;&lt;/pre&gt; * * &lt;p&gt;In addition to implementing the &#123;@link Lock&#125; interface, this * class defines a number of &#123;@code public&#125; and &#123;@code protected&#125; * methods for inspecting the state of the lock. Some of these * methods are only useful for instrumentation and monitoring. * * &lt;p&gt;Serialization of this class behaves in the same way as built-in * locks: a deserialized lock is in the unlocked state, regardless of * its state when serialized. * * &lt;p&gt;This lock supports a maximum of 2147483647 recursive locks by * the same thread. Attempts to exceed this limit result in * &#123;@link Error&#125; throws from locking methods. * * @since 1.5 * @author Doug Lea */public class ReentrantLock implements Lock, java.io.Serializable &#123; private static final long serialVersionUID = 7373984872572414699L; /** Synchronizer providing all implementation mechanics */ private final Sync sync; /** * Base of synchronization control for this lock. Subclassed * into fair and nonfair versions below. Uses AQS state to * represent the number of holds on the lock. */ abstract static class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = -5179523762034025860L; /** * Performs &#123;@link Lock#lock&#125;. The main reason for subclassing * is to allow fast path for nonfair version. */ abstract void lock(); /** * Performs non-fair tryLock. tryAcquire is implemented in * subclasses, but both need nonfair try for trylock method. */ final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false; &#125; protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free; &#125; protected final boolean isHeldExclusively() &#123; // While we must in general read state before owner, // we don't need to do so to check if current thread is owner return getExclusiveOwnerThread() == Thread.currentThread(); &#125; final ConditionObject newCondition() &#123; return new ConditionObject(); &#125; // Methods relayed from outer class final Thread getOwner() &#123; return getState() == 0 ? null : getExclusiveOwnerThread(); &#125; final int getHoldCount() &#123; return isHeldExclusively() ? getState() : 0; &#125; final boolean isLocked() &#123; return getState() != 0; &#125; /** * Reconstitutes the instance from a stream (that is, deserializes it). */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; s.defaultReadObject(); setState(0); // reset to unlocked state &#125; &#125; /** * Sync object for non-fair locks */ static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = 7316153563782823691L; /** * Performs lock. Try immediate barge, backing up to normal * acquire on failure. */ final void lock() &#123; if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); &#125; protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125; &#125; /** * Sync object for fair locks */ static final class FairSync extends Sync &#123; private static final long serialVersionUID = -3000897897090466540L; final void lock() &#123; acquire(1); &#125; /** * Fair version of tryAcquire. Don't grant access unless * recursive call or no waiters or is first. */ protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false; &#125; &#125; /** * Creates an instance of &#123;@code ReentrantLock&#125;. * This is equivalent to using &#123;@code ReentrantLock(false)&#125;. */ //非公平锁 public ReentrantLock() &#123; sync = new NonfairSync(); &#125; /** * Creates an instance of &#123;@code ReentrantLock&#125; with the * given fairness policy. * * @param fair &#123;@code true&#125; if this lock should use a fair ordering policy */ public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync(); &#125; /** * Acquires the lock. * * &lt;p&gt;Acquires the lock if it is not held by another thread and returns * immediately, setting the lock hold count to one. * * &lt;p&gt;If the current thread already holds the lock then the hold * count is incremented by one and the method returns immediately. * * &lt;p&gt;If the lock is held by another thread then the * current thread becomes disabled for thread scheduling * purposes and lies dormant until the lock has been acquired, * at which time the lock hold count is set to one. */ public void lock() &#123; sync.lock(); &#125; /** * Acquires the lock unless the current thread is * &#123;@linkplain Thread#interrupt interrupted&#125;. * * &lt;p&gt;Acquires the lock if it is not held by another thread and returns * immediately, setting the lock hold count to one. * * &lt;p&gt;If the current thread already holds this lock then the hold count * is incremented by one and the method returns immediately. * * &lt;p&gt;If the lock is held by another thread then the * current thread becomes disabled for thread scheduling * purposes and lies dormant until one of two things happens: * * &lt;ul&gt; * * &lt;li&gt;The lock is acquired by the current thread; or * * &lt;li&gt;Some other thread &#123;@linkplain Thread#interrupt interrupts&#125; the * current thread. * * &lt;/ul&gt; * * &lt;p&gt;If the lock is acquired by the current thread then the lock hold * count is set to one. * * &lt;p&gt;If the current thread: * * &lt;ul&gt; * * &lt;li&gt;has its interrupted status set on entry to this method; or * * &lt;li&gt;is &#123;@linkplain Thread#interrupt interrupted&#125; while acquiring * the lock, * * &lt;/ul&gt; * * then &#123;@link InterruptedException&#125; is thrown and the current thread's * interrupted status is cleared. * * &lt;p&gt;In this implementation, as this method is an explicit * interruption point, preference is given to responding to the * interrupt over normal or reentrant acquisition of the lock. * * @throws InterruptedException if the current thread is interrupted */ public void lockInterruptibly() throws InterruptedException &#123; sync.acquireInterruptibly(1); &#125; /** * Acquires the lock only if it is not held by another thread at the time * of invocation. * * &lt;p&gt;Acquires the lock if it is not held by another thread and * returns immediately with the value &#123;@code true&#125;, setting the * lock hold count to one. Even when this lock has been set to use a * fair ordering policy, a call to &#123;@code tryLock()&#125; &lt;em&gt;will&lt;/em&gt; * immediately acquire the lock if it is available, whether or not * other threads are currently waiting for the lock. * This &amp;quot;barging&amp;quot; behavior can be useful in certain * circumstances, even though it breaks fairness. If you want to honor * the fairness setting for this lock, then use * &#123;@link #tryLock(long, TimeUnit) tryLock(0, TimeUnit.SECONDS) &#125; * which is almost equivalent (it also detects interruption). * * &lt;p&gt;If the current thread already holds this lock then the hold * count is incremented by one and the method returns &#123;@code true&#125;. * * &lt;p&gt;If the lock is held by another thread then this method will return * immediately with the value &#123;@code false&#125;. * * @return &#123;@code true&#125; if the lock was free and was acquired by the * current thread, or the lock was already held by the current * thread; and &#123;@code false&#125; otherwise */ public boolean tryLock() &#123; return sync.nonfairTryAcquire(1); &#125; /** * Acquires the lock if it is not held by another thread within the given * waiting time and the current thread has not been * &#123;@linkplain Thread#interrupt interrupted&#125;. * * &lt;p&gt;Acquires the lock if it is not held by another thread and returns * immediately with the value &#123;@code true&#125;, setting the lock hold count * to one. If this lock has been set to use a fair ordering policy then * an available lock &lt;em&gt;will not&lt;/em&gt; be acquired if any other threads * are waiting for the lock. This is in contrast to the &#123;@link #tryLock()&#125; * method. If you want a timed &#123;@code tryLock&#125; that does permit barging on * a fair lock then combine the timed and un-timed forms together: * * &lt;pre&gt; &#123;@code * if (lock.tryLock() || * lock.tryLock(timeout, unit)) &#123; * ... * &#125;&#125;&lt;/pre&gt; * * &lt;p&gt;If the current thread * already holds this lock then the hold count is incremented by one and * the method returns &#123;@code true&#125;. * * &lt;p&gt;If the lock is held by another thread then the * current thread becomes disabled for thread scheduling * purposes and lies dormant until one of three things happens: * * &lt;ul&gt; * * &lt;li&gt;The lock is acquired by the current thread; or * * &lt;li&gt;Some other thread &#123;@linkplain Thread#interrupt interrupts&#125; * the current thread; or * * &lt;li&gt;The specified waiting time elapses * * &lt;/ul&gt; * * &lt;p&gt;If the lock is acquired then the value &#123;@code true&#125; is returned and * the lock hold count is set to one. * * &lt;p&gt;If the current thread: * * &lt;ul&gt; * * &lt;li&gt;has its interrupted status set on entry to this method; or * * &lt;li&gt;is &#123;@linkplain Thread#interrupt interrupted&#125; while * acquiring the lock, * * &lt;/ul&gt; * then &#123;@link InterruptedException&#125; is thrown and the current thread's * interrupted status is cleared. * * &lt;p&gt;If the specified waiting time elapses then the value &#123;@code false&#125; * is returned. If the time is less than or equal to zero, the method * will not wait at all. * * &lt;p&gt;In this implementation, as this method is an explicit * interruption point, preference is given to responding to the * interrupt over normal or reentrant acquisition of the lock, and * over reporting the elapse of the waiting time. * * @param timeout the time to wait for the lock * @param unit the time unit of the timeout argument * @return &#123;@code true&#125; if the lock was free and was acquired by the * current thread, or the lock was already held by the current * thread; and &#123;@code false&#125; if the waiting time elapsed before * the lock could be acquired * @throws InterruptedException if the current thread is interrupted * @throws NullPointerException if the time unit is null */ public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireNanos(1, unit.toNanos(timeout)); &#125; /** * Attempts to release this lock. * * &lt;p&gt;If the current thread is the holder of this lock then the hold * count is decremented. If the hold count is now zero then the lock * is released. If the current thread is not the holder of this * lock then &#123;@link IllegalMonitorStateException&#125; is thrown. * * @throws IllegalMonitorStateException if the current thread does not * hold this lock */ public void unlock() &#123; sync.release(1); &#125; /** * Returns a &#123;@link Condition&#125; instance for use with this * &#123;@link Lock&#125; instance. * * &lt;p&gt;The returned &#123;@link Condition&#125; instance supports the same * usages as do the &#123;@link Object&#125; monitor methods (&#123;@link * Object#wait() wait&#125;, &#123;@link Object#notify notify&#125;, and &#123;@link * Object#notifyAll notifyAll&#125;) when used with the built-in * monitor lock. * * &lt;ul&gt; * * &lt;li&gt;If this lock is not held when any of the &#123;@link Condition&#125; * &#123;@linkplain Condition#await() waiting&#125; or &#123;@linkplain * Condition#signal signalling&#125; methods are called, then an &#123;@link * IllegalMonitorStateException&#125; is thrown. * * &lt;li&gt;When the condition &#123;@linkplain Condition#await() waiting&#125; * methods are called the lock is released and, before they * return, the lock is reacquired and the lock hold count restored * to what it was when the method was called. * * &lt;li&gt;If a thread is &#123;@linkplain Thread#interrupt interrupted&#125; * while waiting then the wait will terminate, an &#123;@link * InterruptedException&#125; will be thrown, and the thread's * interrupted status will be cleared. * * &lt;li&gt; Waiting threads are signalled in FIFO order. * * &lt;li&gt;The ordering of lock reacquisition for threads returning * from waiting methods is the same as for threads initially * acquiring the lock, which is in the default case not specified, * but for &lt;em&gt;fair&lt;/em&gt; locks favors those threads that have been * waiting the longest. * * &lt;/ul&gt; * * @return the Condition object */ public Condition newCondition() &#123; return sync.newCondition(); &#125; /** * Queries the number of holds on this lock by the current thread. * * &lt;p&gt;A thread has a hold on a lock for each lock action that is not * matched by an unlock action. * * &lt;p&gt;The hold count information is typically only used for testing and * debugging purposes. For example, if a certain section of code should * not be entered with the lock already held then we can assert that * fact: * * &lt;pre&gt; &#123;@code * class X &#123; * ReentrantLock lock = new ReentrantLock(); * // ... * public void m() &#123; * assert lock.getHoldCount() == 0; * lock.lock(); * try &#123; * // ... method body * &#125; finally &#123; * lock.unlock(); * &#125; * &#125; * &#125;&#125;&lt;/pre&gt; * * @return the number of holds on this lock by the current thread, * or zero if this lock is not held by the current thread */ public int getHoldCount() &#123; return sync.getHoldCount(); &#125; /** * Queries if this lock is held by the current thread. * * &lt;p&gt;Analogous to the &#123;@link Thread#holdsLock(Object)&#125; method for * built-in monitor locks, this method is typically used for * debugging and testing. For example, a method that should only be * called while a lock is held can assert that this is the case: * * &lt;pre&gt; &#123;@code * class X &#123; * ReentrantLock lock = new ReentrantLock(); * // ... * * public void m() &#123; * assert lock.isHeldByCurrentThread(); * // ... method body * &#125; * &#125;&#125;&lt;/pre&gt; * * &lt;p&gt;It can also be used to ensure that a reentrant lock is used * in a non-reentrant manner, for example: * * &lt;pre&gt; &#123;@code * class X &#123; * ReentrantLock lock = new ReentrantLock(); * // ... * * public void m() &#123; * assert !lock.isHeldByCurrentThread(); * lock.lock(); * try &#123; * // ... method body * &#125; finally &#123; * lock.unlock(); * &#125; * &#125; * &#125;&#125;&lt;/pre&gt; * * @return &#123;@code true&#125; if current thread holds this lock and * &#123;@code false&#125; otherwise */ public boolean isHeldByCurrentThread() &#123; return sync.isHeldExclusively(); &#125; /** * Queries if this lock is held by any thread. This method is * designed for use in monitoring of the system state, * not for synchronization control. * * @return &#123;@code true&#125; if any thread holds this lock and * &#123;@code false&#125; otherwise */ public boolean isLocked() &#123; return sync.isLocked(); &#125; /** * Returns &#123;@code true&#125; if this lock has fairness set true. * * @return &#123;@code true&#125; if this lock has fairness set true */ public final boolean isFair() &#123; return sync instanceof FairSync; &#125; /** * Returns the thread that currently owns this lock, or * &#123;@code null&#125; if not owned. When this method is called by a * thread that is not the owner, the return value reflects a * best-effort approximation of current lock status. For example, * the owner may be momentarily &#123;@code null&#125; even if there are * threads trying to acquire the lock but have not yet done so. * This method is designed to facilitate construction of * subclasses that provide more extensive lock monitoring * facilities. * * @return the owner, or &#123;@code null&#125; if not owned */ protected Thread getOwner() &#123; return sync.getOwner(); &#125; /** * Queries whether any threads are waiting to acquire this lock. Note that * because cancellations may occur at any time, a &#123;@code true&#125; * return does not guarantee that any other thread will ever * acquire this lock. This method is designed primarily for use in * monitoring of the system state. * * @return &#123;@code true&#125; if there may be other threads waiting to * acquire the lock */ public final boolean hasQueuedThreads() &#123; return sync.hasQueuedThreads(); &#125; /** * Queries whether the given thread is waiting to acquire this * lock. Note that because cancellations may occur at any time, a * &#123;@code true&#125; return does not guarantee that this thread * will ever acquire this lock. This method is designed primarily for use * in monitoring of the system state. * * @param thread the thread * @return &#123;@code true&#125; if the given thread is queued waiting for this lock * @throws NullPointerException if the thread is null */ public final boolean hasQueuedThread(Thread thread) &#123; return sync.isQueued(thread); &#125; /** * Returns an estimate of the number of threads waiting to * acquire this lock. The value is only an estimate because the number of * threads may change dynamically while this method traverses * internal data structures. This method is designed for use in * monitoring of the system state, not for synchronization * control. * * @return the estimated number of threads waiting for this lock */ public final int getQueueLength() &#123; return sync.getQueueLength(); &#125; /** * Returns a collection containing threads that may be waiting to * acquire this lock. Because the actual set of threads may change * dynamically while constructing this result, the returned * collection is only a best-effort estimate. The elements of the * returned collection are in no particular order. This method is * designed to facilitate construction of subclasses that provide * more extensive monitoring facilities. * * @return the collection of threads */ protected Collection&lt;Thread&gt; getQueuedThreads() &#123; return sync.getQueuedThreads(); &#125; /** * Queries whether any threads are waiting on the given condition * associated with this lock. Note that because timeouts and * interrupts may occur at any time, a &#123;@code true&#125; return does * not guarantee that a future &#123;@code signal&#125; will awaken any * threads. This method is designed primarily for use in * monitoring of the system state. * * @param condition the condition * @return &#123;@code true&#125; if there are any waiting threads * @throws IllegalMonitorStateException if this lock is not held * @throws IllegalArgumentException if the given condition is * not associated with this lock * @throws NullPointerException if the condition is null */ public boolean hasWaiters(Condition condition) &#123; if (condition == null) throw new NullPointerException(); if (!(condition instanceof AbstractQueuedSynchronizer.ConditionObject)) throw new IllegalArgumentException("not owner"); return sync.hasWaiters((AbstractQueuedSynchronizer.ConditionObject)condition); &#125; /** * Returns an estimate of the number of threads waiting on the * given condition associated with this lock. Note that because * timeouts and interrupts may occur at any time, the estimate * serves only as an upper bound on the actual number of waiters. * This method is designed for use in monitoring of the system * state, not for synchronization control. * * @param condition the condition * @return the estimated number of waiting threads * @throws IllegalMonitorStateException if this lock is not held * @throws IllegalArgumentException if the given condition is * not associated with this lock * @throws NullPointerException if the condition is null */ public int getWaitQueueLength(Condition condition) &#123; if (condition == null) throw new NullPointerException(); if (!(condition instanceof AbstractQueuedSynchronizer.ConditionObject)) throw new IllegalArgumentException("not owner"); return sync.getWaitQueueLength((AbstractQueuedSynchronizer.ConditionObject)condition); &#125; /** * Returns a collection containing those threads that may be * waiting on the given condition associated with this lock. * Because the actual set of threads may change dynamically while * constructing this result, the returned collection is only a * best-effort estimate. The elements of the returned collection * are in no particular order. This method is designed to * facilitate construction of subclasses that provide more * extensive condition monitoring facilities. * * @param condition the condition * @return the collection of threads * @throws IllegalMonitorStateException if this lock is not held * @throws IllegalArgumentException if the given condition is * not associated with this lock * @throws NullPointerException if the condition is null */ protected Collection&lt;Thread&gt; getWaitingThreads(Condition condition) &#123; if (condition == null) throw new NullPointerException(); if (!(condition instanceof AbstractQueuedSynchronizer.ConditionObject)) throw new IllegalArgumentException("not owner"); return sync.getWaitingThreads((AbstractQueuedSynchronizer.ConditionObject)condition); &#125; /** * Returns a string identifying this lock, as well as its lock state. * The state, in brackets, includes either the String &#123;@code "Unlocked"&#125; * or the String &#123;@code "Locked by"&#125; followed by the * &#123;@linkplain Thread#getName name&#125; of the owning thread. * * @return a string identifying this lock, as well as its lock state */ public String toString() &#123; Thread o = sync.getOwner(); return super.toString() + ((o == null) ? "[Unlocked]" : "[Locked by thread " + o.getName() + "]"); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
        <category>jdk源码分析</category>
        <category>J.U.C源码</category>
      </categories>
      <tags>
        <tag>jdk源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池原理(一)]]></title>
    <url>%2F2018%2F01%2F23%2Fjava%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[一、线程池状态1、状态切换图 2、状态描述 1、running 允许提交并处理任务 2、shutdown 不允许提交新的任务，但是会处理完已提交的任务 3、stop 不允许提交新的任务，也不会处理阻塞队列中未执行的任务，并设置正在执行的线程的中断标志位 4、tidying 所有任务执行完毕，池中工作的线程数为0，等待执行terminatd()钩子方法 5、terminated terminated()钩子方法执行完毕 3、ctl1private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); AtomicInteger保证对该变量操作的原子性 高三位存runState，低29位存线程数,CAPACITY=00011111111111111111111111111111获取runState:c &amp; ~CAPACITY获取workCount:c &amp; CAPACITY 二、构造函数参数1、corePoolSize 线程池中核心线程数的最大值 2、maximumPoolSize 线程池中能拥有最多线程数 3、workQueue 用于缓存任务的阻塞队列 向线程池添加任务时： 1、没有空闲的线程执行，且当前运行的线程数少于corePoolSize，添加新的线程执行2、没有空闲的线程执行，且当前的线程数等于corePoolSize，将任务入队列3、没有空闲的线程执行，且阻塞队列已满，且池中的线程数少于maximumPoolSize，则创建新的线程执行4、没有空闲的线程执行，且阻塞队列已满，且池中的线程数等于maximumPoolSize，则根据Handler指定策略拒绝新任务 4、keepAliveTime 表示空闲线程的存活时间。 5、TimeUnitunit 表示keepAliveTime的单位。 注： 默认清除超过corePoolSize部分线程 6、handler 表示当workQueue已满，且池中的线程数达到maximumPoolSize时，线程池拒绝添加新任务时采取的策略。 @import “hander拒绝策略.csv” 7、workQueue 决定了缓存任务的排队策略。 a、直接提交策略，也即SynchronousQueue可以避免在处理可能具有内部依赖性的请求集时出现锁，如：如果你的任务A1，A2有内部关联，A1需要先运行，那么先提交A1，再提交A2，当使用SynchronousQueue我们可以保证，A1必定先被执行，在A1么有被执行前，A2不可能添加入queue中 b、无界队列策略，即LinkedBlockingQueue 创建的线程就不会超过 corePoolSize。maximumPoolSize 的值也就无效了。如：当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web 页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。 c、有界队列，使用ArrayBlockingQueue 有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O 边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU 使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。 三、线程池的工厂类-Executors类 初始化4种类型的线程池： 1、newFixedThreadPool()说明：初始化一个指定线程数的线程池，其中corePoolSize == maxiPoolSize，使用LinkedBlockingQuene作为阻塞队列特点：即使当线程池没有可执行任务时，也不会释放线程。 2、newCachedThreadPool()说明：初始化一个可以缓存线程的线程池，默认缓存60s，线程池的线程数可达到Integer.MAX_VALUE，即2147483647，内部使用 3、SynchronousQueue作为阻塞队列；特点：在没有任务执行时，当线程的空闲时间超过keepAliveTime，会自动释放线程资源；当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销；因此，使用时要注意控制并发的任务数，防止因创建大量的线程导致而降低性能。 4、newSingleThreadExecutor()说明：初始化只有一个线程的线程池，内部使用LinkedBlockingQueue作为阻塞队列。特点：如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行 5、newScheduledThreadPool()特定：初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据。 总结： 除了newScheduledThreadPool的内部实现特殊一点之外，其它线程池内部都是基于ThreadPoolExecutor类（Executor的子类）实现的。 四、向线程池提交任务（2种） 有两种方式： Executor.execute(Runnable command);ExecutorService.submit(Callable task); 1、execute()内部实现 1.首次通过workCountof()获知当前线程池中的线程数， 如果小于corePoolSize, 就通过addWorker()创建线程并执行该任务；否则，将该任务放入阻塞队列； 2.如果能成功将任务放入阻塞队列中, 如果当前线程池是非RUNNING状态，则将该任务从阻塞队列中移除，然后执行reject()处理该任务；如果当前线程池处于RUNNING状态，则需要再次检查线程池（因为可能在上次检查后，有线程资源被释放），是否有空闲的线程；如果有则执行该任务； 3.如果不能将任务放入阻塞队列中, 说明阻塞队列已满；那么将通过addWoker()尝试创建一个新的线程去执行这个任务；如果addWoker()执行失败，说明线程池中线程数达到maxPoolSize,则执行reject()处理任务； 2、sumbit()内部实现 会将提交的Callable任务会被封装成了一个FutureTask对象 FutureTask类实现了Runnable接口，这样就可以通过Executor.execute()提交FutureTask到线程池中等待被执行，最终执行的是FutureTask的run方法； 比较： 两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中,而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。 五、线程池的其他1、线程池的关闭（2种） ThreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是shutdown()和shutdownNow()，其中： shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务 shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务 2、线程池容量的动态调整 ThreadPoolExecutor提供了动态调整线程池容量大小的方法：setCorePoolSize()和setMaximumPoolSize()]]></content>
      <categories>
        <category>java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中的锁]]></title>
    <url>%2F2018%2F01%2F22%2Fjava%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2Fjava%E4%B8%AD%E7%9A%84%E9%94%81%2F</url>
    <content type="text"><![CDATA[1）当一个线程正在访问一个对象的synchronized方法，那么其他线程不能访问该对象的其他synchronized方法。这个原因很简单，因为一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized方法。 2）当一个线程正在访问一个对象的synchronized方法，那么其他线程能访问该对象的非synchronized方法。这个原因很简单，访问非synchronized方法不需要获得该对象的锁，假如一个方法没用synchronized关键字修饰，说明它不会使用到临界资源，那么其他线程是可以访问这个方法的， 3）如果一个线程A需要访问对象object1的synchronized方法fun1，另外一个线程B需要访问对象object2的synchronized方法fun1，即使object1和object2是同一类型），也不会产生线程安全问题，因为他们访问的是不同的对象，所以不存在互斥问题。 二、Lock1、synchronized的缺陷 当一个线程获取了对应的锁，其它线程只能等待，除非执行完或者线程发生异常，JVM让线程释放锁 两个读操作时，不会发生冲突，也会锁住 Lock可以知道线程有没有成功获取锁 注:每个类也会有一个锁，它可以用来控制对static数据成员的并发访问。 并且如果一个线程执行一个对象的非static synchronized方法，另外一个线程需要执行这个对象所属类的static synchronized方法，此时不会发生互斥现象，因为访问static synchronized方法占用的是类锁，而访问非static synchronized方法占用的是对象锁，所以不存在互斥现象。 从反编译获得的字节码可以看出，synchronized代码块实际上多了monitorenter和monitorexit两条指令 。monitorenter指令执行时会让对象的锁计数加1，而monitorexit指令执行时会让对象的锁计数减1，其实这个与操作系统里面的PV操作很像，操作系统里面的PV操作就是用来控制多个线程对临界资源的访问。对于synchronized方法，执行中的线程识别该方法的 method_info 结构是否有 ACC_SYNCHRONIZED 标记设置，然后它自动获取对象的锁，调用方法，最后释放锁。如果有异常发生，线程自动释放锁。 有一点要注意：对于synchronized方法或者synchronized代码块，当出现异常时，JVM会自动释放当前线程占用的锁，因此不会由于异常导致出现死锁现象。 2、java.util.concurrent.locks包下常用的类1）、locka）、lock()用来获取锁，并且在发生异常时，不会主动释放，使用lock必须在finally中使用unLock释放b）、tryLock()有返回值，表示尝试获取锁，成功true，失败false，立即返回，不会一直等待c）、tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false d）、lockInterruptibly()当通过lockInterruptibly()获取锁时，如果线程正在等待锁，则可以响应中断。中断锁的等待。 2）、ReentrantLock意思是“可重入锁”，ReentrantLock是唯一实现了Lock接口的类 3）、ReadWriteLock12Lock readLock();Lock writeLock(); 一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的ReentrantReadWriteLock实现了ReadWriteLock接口。 4）、ReentrantReadWriteLock三、Lock和synchronized有以下几点不同： 1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现； 2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁； 3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断； 4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。 5）Lock可以提高多个线程进行读操作的效率。 在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。 四、锁的相关概念1、可重入锁 如果锁具备可重入性，则称作为可重入锁。像synchronized和ReentrantLock都是可重入锁，可重入性在我看来实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。 2、可中断锁 在Java中，synchronized就不是可中断锁，而Lock是可中断锁。 如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。 在前面演示lockInterruptibly()的用法时已经体现了Lock的可中断性。 3、公平锁公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。 非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。 在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。 而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。 4、读写锁读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。 正因为有了读写锁，才使得多个线程之间的读操作不会发生冲突。 ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。 可以通过readLock()获取读锁，通过writeLock()获取写锁。]]></content>
      <categories>
        <category>java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReetrankLock与Synchronized]]></title>
    <url>%2F2018%2F01%2F20%2Fjava%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2FReetrankLock%E4%B8%8ESynchronized%2F</url>
    <content type="text"><![CDATA[1、ReentrantLock可重入锁，有一个与锁相关的获取计数器，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，然后需要被释放两次。]]></content>
      <categories>
        <category>java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal原理]]></title>
    <url>%2F2018%2F01%2F20%2Fjava%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2FThreadLocal%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、ThreadLocal概述 ThreadLocal提供了线程本地变量，保证访问到的变量属于当前线程，每个线程都有保存一个变量副本 ThreadLocal提供了线程隔离，将变量和线程绑定，ThreadLocal通常定义为private static 二、ThreadLocal详解&#123;class12345678910111213141516171819private final int threadLocalHashCode = nextHashCode();/** * The next hash code to be given out. Updated atomically. Starts at * zero. */private static AtomicInteger nextHashCode = new AtomicInteger();/** * The difference between successively generated hash codes - turns * implicit sequential thread-local IDs into near-optimally spread * multiplicative hash values for power-of-two-sized tables. */private static final int HASH_INCREMENT = 0x61c88647;/** * Returns the next hash code. */private static int nextHashCode() &#123; return nextHashCode.getAndAdd(HASH_INCREMENT);&#125; 1、threadLocalHashCode 标识每一个ThreadLocal的唯一性，通过CAS操作进行更新，每次hash操作的增量为0x61c88647 每个Thread里面都有一个ThreadLocal.ThreadLocalMap成员变量，也就是说每个线程通过ThreadLocal.ThreadLocalMap与ThreadLocal相绑定，这样可以确保每个线程访问到的thread-local variable都是本线程的。 2、内部实现-ThreadLocalMap&#123;class123456789101112131415161718192021/** * The initial capacity -- MUST be a power of two. * Map的初始容量 */private static final int INITIAL_CAPACITY = 16;/** * The table, resized as necessary. * table.length MUST always be a power of two. * Entry类型的数组，用于存储数据 */private Entry[] table;/** * The number of entries in the table. * 代表表中的存储数目 */private int size = 0;/** * The next size value at which to resize. * 代表需要扩容时对应size的阈值 */private int threshold; // Default to 0 size必须为2的指数：计算hash的时候里面采用了hashCode &amp; (size - 1)的算法，可以减少发生冲突如果发生冲突，选择线性探测法解决冲突，通过nextIndex方法再次计算哈希值 Entry类是ThreadLocalMap的静态内部类，用于存储数据。&#123;class12345678910111213141516/** * The entries in this hash map extend WeakReference, using * its main ref field as the key (which is always a * ThreadLocal object). Note that null keys (i.e. entry.get() * == null) mean that the key is no longer referenced, so the * entry can be expunged from table. Such entries are referred to * as "stale entries" in the code that follows. */static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125; 每个Entry对象都有一个ThreadLocal的弱引用作为key，可以防止内存泄漏，线程结束时，key变为不可达的对象，Entry可以被GC 三、ThreadLocal内存泄漏问题1、实现原理 {width=”556px” height=”307px” title=”threadLocal原理图”} 每个Thread维护一个ThreadLocalMap映射表,key为ThreadLocal实例本身，value为需要存储的Object 2、内存泄漏的原因 ThreadLocalMap使用ThreadLocal的弱引用作为key，如果ThreadLocal外部没有强引用，那么系统GC的时候，ThreadLocal会被回收,会出现key为null的Entry如果当前线程迟迟不结束，就会存在强引用链，Thread ref -&gt; Thread -&gt; ThreadLocalMap -&gt; Entry -&gt; value无法被回收 jdk的防护措施 在ThreadLocal的get(), set(), remove() 都会清除线程ThreadLocalMap里所有key为null的Entry。 jdk的处理的漏洞 1、使用static的ThreadLocal，导致ThreadLocal的生命周期和Thread一样，可能导致内存泄漏2、分配使用了ThreadLocal后，不在调用get(), set(), remove() 3、使用弱引用的原因 官方文档：为了应对非常大和长时间的用途 比较 1、key使用强引用：引用ThreadLocal的对象被回收，ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏2、key使用弱引用：引用ThreadLocal的对象被回收，由于ThreadLocalMap持有ThreadLocal的弱引用，ThreadLocal肯定会被回收。value则在下一次调用get，set，remove时清除。 可以发现： 使用弱引用可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除。 因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。 4、最佳实践 每次使用完ThreadLocal，都调用它的remove()方法，清除数据。]]></content>
      <categories>
        <category>java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾回收]]></title>
    <url>%2F2018%2F01%2F18%2Fjava%2FJVM%2F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[一、Java堆内存分配虚拟机把堆内存划分成新生代（Young Generation）、老年代（Old Generation）和永久代（Permanent Generation）3个区域 1、新生代 新生代由Eden和Survivor(S0,S1)构成，大小通过-Xmn参数指定，默认8：1：1 1、对象首先在Eden中分配，当Eden中没有足够空间时，会触发一次Minor GC，虚拟机提供了-XX:+PrintGCDetails参数，告诉虚拟机在发生垃圾回收时打印内存回收日志。 2、Survivor：意思为幸存者，是新生代和老年代的缓冲区域。当新生代发生GC（Minor GC）时，会将存活的对象移动到S0内存区域，并清空Eden区域，当再次发生Minor GC时，将Eden和S0中存活的对象移动到S1内存区域。 3、存活对象会反复在S0和S1之间移动，当对象从Eden移动到Survivor或者在Survivor之间移动时，对象的GC年龄自动累加，当GC年龄超过默认阈值15时，会将该对象移动到老年代，可以通过参数-XX:MaxTenuringThreshold 对GC年龄的阈值进行设置。 2、老年代老年代的空间大小即-Xmx 与-Xmn 两个参数之差，用于存放经过几次Minor GC之后依旧存活的对象。当老年代的空间不足时，会触发Major GC/Full GC，速度一般比Minor GC慢10倍以上。 3、永久代在JDK8之前的HotSpot实现中，类的元数据如方法数据、方法信息（字节码，栈和变量大小）、运行时常量池、已确定的符号引用和虚方法表等被保存在永久代中，32位默认永久代的大小为64M，64位默认为85M，可以通过参数-XX:MaxPermSize进行设置，一旦类的元数据超过了永久代大小，就会抛出OOM异常。 虚拟机团队在JDK8的HotSpot中，把永久代从Java堆中移除了，并把类的元数据直接保存在本地内存区域（堆外内存），称之为元空间。 这样做有什么好处？对永久代的调优过程非常困难，永久代的大小很难确定，其中涉及到太多因素，如类的总数、常量池大小和方法数量等，而且永久代的数据可能会随着每一次Full GC而发生移动。 而在JDK8中，类的元数据保存在本地内存中，元空间的最大可分配空间就是系统可用内存空间，可以避免永久代的内存溢出问题，不过需要监控内存的消耗情况，一旦发生内存泄漏，会占用大量的本地内存。 ps：JDK7之前的HotSpot，字符串常量池的字符串被存储在永久代中，因此可能导致一系列的性能问题和内存溢出错误。在JDK8中，字符串常量池中只保存字符串的引用。 二、判断对象是否存活1、引用计数法 在对象上添加一个引用计数器，每当有一个对象引用它时，计数器加1，当使用完该对象时，计数器减1，计数器值为0的对象表示不可能再被使用。 问题：不能解决相互引用的问题 2、可达性分析法 通过一系列称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，搜索路径称为 “引用链” 可作为GC Roots的对象本地变量表中引用的对象方法区中静态变量引用的对象方法区中常量引用的对象Native方法引用的对象 在可达性分析法中，判定一个对象objA是否可回收，至少要经历两次标记过程：1、如果对象objA到 GC Roots没有引用链，则进行第一次标记。2、如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法。finalize()方法是对象逃脱死亡的最后机会，GC会对队列中的对象进行第二次标记，如果objA在finalize()方法中与引用链上的任何一个对象建立联系，那么在第二次标记时，objA会被移出“即将回收”集合。 三、垃圾收算法垃圾收集算法主要有：标记-清除、复制和标记-整理。 1、标记-清除算法对待回收的对象进行标记。算法缺点：效率问题，标记和清除过程效率都很低；空间问题，收集之后会产生大量的内存碎片，不利于大对象的分配。 2、复制算法复制算法将可用内存划分成大小相等的两块A和B，每次只使用其中一块，当A的内存用完了，就把存活的对象复制到B，并清空A的内存，不仅提高了标记的效率，因为只需要标记存活的对象，同时也避免了内存碎片的问题，代价是可用内存缩小为原来的一半。 3、标记-整理算法在老年代中，对象存活率较高，复制算法的效率很低。在标记-整理算法中，标记出所有存活的对象，并移动到一端，然后直接清理边界以外的内存。 四、对象标记过程在可达性分析过程中，为了准确找出与GC Roots相关联的对象，必须要求整个执行引擎看起来像是被冻结在某个时间点上，即暂停所有运行中的线程，不可以出现对象的引用关系还在不断变化的情况。 如何快速枚举GC Roots？GC Roots主要在全局性的引用（常量或类静态属性）与执行上下文（本地变量表中的引用）中，很多应用仅仅方法区就上百兆，如果进行遍历查找，效率会非常低下。 在HotSpot中，使用一组称为OopMap的数据结构进行实现。类加载完成时，HotSpot把对象内什么偏移量上是什么类型的数据计算出来存储到OopMap中，通过JIT编译出来的本地代码，也会记录下栈和寄存器中哪些位置是引用。GC发生时，通过扫描OopMap的数据就可以快速标识出存活的对象。 如何安全的GC？线程运行时，只有在到达安全点（Safe Point）才能停顿下来进行GC。 基于OopMap数据结构，HotSpot可以快速完成GC Roots的遍历，不过HotSpot并不会为每条指令都生成对应的OopMap，只会在Safe Point处记录这些信息。 所以Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。 关于Safe Point更多的信息，可以看看这篇文章 JVM的Stop The World，安全点，黑暗的地底世界 发生GC时，如何让所有线程跑到最近的Safe Point再暂停？当发生GC时，不直接对线程进行中断操作，而是简单的设置一个中断标志，每个线程运行到Safe Point的时候，主动去轮询这个中断标志，如果中断标志为真，则将自己进行中断挂起。 这里忽略了一个问题，当发生GC时，运行中的线程可以跑到Safe Point后进行挂起，而那些处于Sleep或Blocked状态的线程在此时无法响应JVM的中断请求，无法到Safe Point处进行挂起，针对这种情况，可以使用安全区域（Safe Region）进行解决。 Safe Region是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。1、当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程；2、当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止； 五、垃圾收集器Java虚拟机规范并没有规定垃圾收集器应该如何实现，用户可以根据系统特点对各个区域所使用的收集器进行组合使用。 上图展示了7种不同分代的收集器，如果两两之间存在连线，说明可以组合使用。 1、Serial收集器（串行GC）Serial 是一个采用单个线程并基于复制算法工作在新生代的收集器，进行垃圾收集时，必须暂停其他所有的工作线程。对于单CPU环境来说，Serial由于没有线程交互的开销，可以很高效的进行垃圾收集动作，是Client模式下新生代默认的收集器。 2、ParNew收集器（并行GC）ParNew其实是serial的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为与Serial一样。 3、Parallel Scavenge收集器（并行回收GC）Parallel Scavenge是一个采用多线程基于复制算法并工作在新生代的收集器，其关注点在于达到一个可控的吞吐量，经常被称为“吞吐量优先”的收集器。 吞吐量 = 用户代码运行时间 /（用户代码运行时间 + 垃圾收集时间） Parallel Scavenge提供了两个参数用于精确控制吞吐量：1、-XX：MaxGCPauseMillis 设置垃圾收集的最大停顿时间2、-XX：GCTimeRatio 设置吞吐量大小 4、Serial Old收集器（串行GC）Serial Old 是一个采用单线程基于标记-整理算法并工作在老年代的收集器，是Client模式下老年代默认的收集器。 5、Parallel Old收集器（并行GC）Parallel Old是一个采用多线程基于标记-整理算法并工作在老年代的收集器。在注重吞吐量以及CPU资源敏感的场合，可以优先考虑Parallel Scavenge和Parallel Old的收集器组合。 6、CMS收集器（并发GC）CMS(Concurrent Mark Sweep)是一种以获取最短回收停顿时间为目标的收集器，工作在老年代，基于“标记-清除”算法实现，整个过程分为以下4步：1、初始标记：这个过程只是标记以下GC Roots能够直接关联的对象，但是仍然会Stop The World；2、并发标记：进行GC Roots Tracing的过程，可以和用户线程一起工作。3、重新标记：用于修正并发标记期间由于用户程序继续运行而导致标记产生变动的那部分记录，这个过程会暂停所有线程，但其停顿时间远比并发标记的时间短；4、并发清理：可以和用户线程一起工作。 CMS收集器的缺点：1、对CPU资源比较敏感，在并发阶段，虽然不会导致用户线程停顿，但是会占用一部分线程资源，降低系统的总吞吐量。2、无法处理浮动垃圾，在并发清理阶段，用户线程的运行依然会产生新的垃圾对象，这部分垃圾只能在下一次GC时收集。3、CMS是基于标记-清除算法实现的，意味着收集结束后会造成大量的内存碎片，可能导致出现老年代剩余空间很大，却无法找到足够大的连续空间分配当前对象，不得不提前触发一次Full GC。 JDK1.5实现中，当老年代空间使用率达到68%时，就会触发CMS收集器，如果应用中老年代增长不是太快，可以通过-XX:CMSInitiatingOccupancyFraction参数提高触发百分比，从而降低内存回收次数提高系统性能。 JDK1.6实现中，触发CMS收集器的阈值已经提升到92%，要是CMS运行期间预留的内存无法满足用户线程需要，会出现一次”Concurrent Mode Failure”失败，这是虚拟机会启动Serial Old收集器对老年代进行垃圾收集，当然，这样应用的停顿时间就更长了，所以这个阈值也不能设置的太高，如果导致了”Concurrent Mode Failure”失败，反而会降低性能，至于如何设置这个阈值，还得长时间的对老年代空间的使用情况进行监控。 7、G1收集器G1（Garbage First）是JDK1.7提供的一个工作在新生代和老年代的收集器，基于“标记-整理”算法实现，在收集结束后可以避免内存碎片问题。 G1优点：1、并行与并发：充分利用多CPU来缩短Stop The World的停顿时间；2、分代收集：不需要其他收集配合就可以管理整个Java堆，采用不同的方式处理新建的对象、已经存活一段时间和经历过多次GC的对象获取更好的收集效果;3、空间整合：与CMS的”标记-清除”算法不同，G1在运行期间不会产生内存空间碎片，有利于应用的长时间运行，且分配大对象时，不会导致由于无法申请到足够大的连续内存而提前触发一次Full GC;4、停顿预测：G1中可以建立可预测的停顿时间模型，能让使用者明确指定在M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。 使用G1收集器时，Java堆的内存布局与其他收集器有很大区别，整个Java堆会被划分为多个大小相等的独立区域Region，新生代和老年代不再是物理隔离了，都是一部分Region（不需要连续）的集合。G1会跟踪各个Region的垃圾收集情况（回收空间大小和回收消耗的时间），维护一个优先列表，根据允许的收集时间，优先回收价值最大的Region，避免在整个Java堆上进行全区域的垃圾回收，确保了G1收集器可以在有限的时间内尽可能收集更多的垃圾。 不过问题来了：使用G1收集器，一个对象分配在某个Region中，可以和Java堆上任意的对象有引用关系，那么如何判定一个对象是否存活，是否需要扫描整个Java堆？其实这个问题在之前收集器中也存在，如果回收新生代的对象时，不得不同时扫描老年代的话，会大大降低Minor GC的效率。 针对这种情况，虚拟机提供了一个解决方案：G1收集器中Region之间的对象引用关系和其他收集器中新生代与老年代之间的对象引用关系被保存在Remenbered Set数据结构中，用来避免全堆扫描。G1中每个Region都有一个对应的Remenbered Set，当虚拟机发现程序对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于相同的Region中，如果不是，则通过CardTable把相关引用信息记录到被引用对象所属Region的Remenbered Set中。]]></content>
      <categories>
        <category>java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[join的使用]]></title>
    <url>%2F2018%2F01%2F14%2Fjava%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2Fjoin%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[join的理解thread.join把指定的线程加入到当前线程，将两个交替执行的线程合并为顺序执行12t.join() //调用join方法，等待线程t执行完毕t.join(1000) //等待t线程，时间1000毫秒，等待完成，当前线程抢占执行 源码解析12345678910111213141516171819202122232425/** * Waits at most &lt;code&gt;millis&lt;/code&gt; milliseconds for this thread to * die. A timeout of &lt;code&gt;0&lt;/code&gt; means to wait forever. */ public final synchronized void join(long millis) throws InterruptedException &#123; long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; if (millis == 0) &#123; while (isAlive()) &#123; wait(0); &#125; &#125; else &#123; while (isAlive()) &#123; long delay = millis - now; if (delay &lt;= 0) &#123; break; &#125; wait(delay); now = System.currentTimeMillis() - base; &#125; &#125; &#125; 当线程调用t.join的时候，当前线程会获得线程对象t的锁，调用对象的wait，知道该对象唤醒当前线程。 123456789101112131415161718192021222324252627public class JoinTest &#123; public static void main(String[] sure) throws InterruptedException &#123; Thread t = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (currentThread()) &#123; for (int i = 1; i &lt;= 5; i++) &#123; try &#123; sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("睡眠" + i); &#125; System.out.println("Join结束"); &#125; &#125; &#125;); long start = System.currentTimeMillis(); t.start(); t.join(1); System.out.println(System.currentTimeMillis() - start); System.out.println("主线程结束"); &#125;&#125; 当有synchronized时，main等待1000ms后，获取不到线程的对象锁，只能等到，线程t执行完成， 三个线程T1,T2,T3,如何确保按顺序执行在每个线程的run方法中用join方法限定了三个线程的执行顺序12345678910111213141516171819202122232425262728293031323334353637public class JoinTest &#123; public static void main(String[] args) &#123; final Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("t1"); &#125; &#125;); final Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; t1.start(); t1.join(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println("t2"); &#125; &#125;); final Thread t3 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; t2.start(); t2.join(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println("t3"); &#125; &#125;); t3.start(); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表设计规范]]></title>
    <url>%2F2017%2F09%2F24%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmysql%2F%E8%A1%A8%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[一、建表###1、从数据库 库名应与项目名一致 命名全部为小写加下划线 ###2、从表上 表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字 不使用保留字 表达是与否概念的字段，必须使用is_xxx的方式命名，数据类型是unsigned tinyint 小数类型为decimal，禁止使用float和double id,create_time,update_time必须字段 表的命名最好是加上“业务名称_表的作用” 合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。 ###3、从索引 主键索引名为pk字段名；唯一索引名为uk字段名；普通索引名则为idx_字段名 业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。 超过三个表禁止join。需要join的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。 利用覆盖索引来进行查询操作，避免回表。 建组合索引的时候，区分度最高的在最左边。 如果有order by的场景，注意利用索引的有序性。 ###4、查询 使用ISNULL()来判断是否为NULL值。 当某一列的值全是NULL时，count(col)的返回结果为0，但sum(col)的返回结果为NULL，因此使用sum()时需注意NPE问题。 count(distinct col) 计算该列除NULL之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为NULL，那么即使另一列有不同的值，也返回为0。]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[桥接模式]]></title>
    <url>%2F2017%2F08%2F26%2F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-7%E7%A7%8D%2F%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在提出桥梁模式的时候指出，桥梁模式的用意是”将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化”。这句话有三个关键词，也就是抽象化、实现化和脱耦。 抽象化：存在于多个实体中的共同的概念性联系，就是抽象化。作为一个过程，抽象化就是忽略一些信息，从而把不同的实体当做同样的实体对待。实现化：抽象化给出的具体实现，就是实现化。脱耦：所谓耦合，就是两个实体的行为的某种强关联。而将它们的强关联去掉，就是耦合的解脱，或称脱耦。在这里，脱耦是指将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联。 123public interface Driver &#123; public void connect();&#125; 1234567public class MysqlDriver implements Driver &#123; @Override public void connect() &#123; System.out.println("connect mysql done!"); &#125;&#125; 1234567public class DB2Driver implements Driver &#123; @Override public void connect() &#123; System.out.println("connect db2 done!"); &#125;&#125; 12345678910111213141516public abstract class DriverManager &#123; private Driver driver; public void connect() &#123; driver.connect(); &#125; public Driver getDriver() &#123; return driver; &#125; public void setDriver(Driver driver) &#123; this.driver = driver; &#125;&#125; 123456public class MyDriverManager extends DriverManager &#123; public void connect() &#123; super.connect(); &#125;&#125; 123456789101112131415public class Client &#123; public static void main(String[] args) &#123; DriverManager driverManager = new MyDriverManager(); Driver driver1 = new MysqlDriver(); driverManager.setDriver(driver1); driverManager.connect(); Driver driver2 = new DB2Driver(); driverManager.setDriver(driver2); driverManager.connect(); &#125;&#125; 执行结果：connect mysql done!connect db2 done! 如果看完代码实例还不是很理解，我们想想如下两个维度扩展：（1）假设我想加一个OracleDriver，这是一个维度（2）假设我们想在连接前后固定输出点什么，我们只需要加一个MyDriverManager2，代码如下：12345678public class MyDriverManager2 extends DriverManager &#123; public void connect() &#123; System.out.println("before connect"); super.connect(); System.out.println("after connect"); &#125;&#125; 再将Client代码中的MyDriverManager 改成 MyDriverManager2 ，执行结果如下：before connectconnect mysql done!after connectbefore connectconnect db2 done!after connect]]></content>
      <categories>
        <category>架构设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型模式-7种</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[享元模式]]></title>
    <url>%2F2017%2F08%2F24%2F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-7%E7%A7%8D%2F%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。 一提到共享池，我们很容易联想到Java里面的JDBC连接池，想想每个连接的特点，我们不难总结出：适用于作共享的一些个对象，他们有一些共有的属性，就拿数据库连接池来说，url、driverClassName、username、password及dbname，这些属性对于每个连接来说都是一样的，所以就适合用享元模式来处理，建一个工厂类，将上述类似属性作为内部数据，其它的作为外部数据，在方法调用时，当做参数传进来，这样就节省了空间，减少了实例的数量。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.util.Vector;public class ConnectionPool &#123; private Vector&lt;Connection&gt; pool; /* 公有属性 */ private String url = "jdbc:mysql://localhost:3306/test"; private String username = "root"; private String password = "root"; private String driverClassName = "com.mysql.jdbc.Driver"; private int poolSize = 100; private static ConnectionPool instance = null; Connection conn = null; /* 构造方法，做一些初始化工作 */ private ConnectionPool() &#123; pool = new Vector&lt;Connection&gt;(poolSize); for (int i = 0; i &lt; poolSize; i++) &#123; try &#123; Class.forName(driverClassName); conn = DriverManager.getConnection(url, username, password); pool.add(conn); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /* 返回连接到连接池 */ public synchronized void release() &#123; pool.add(conn); &#125; /* 返回连接池中的一个数据库连接 */ public synchronized Connection getConnection() &#123; if (pool.size() &gt; 0) &#123; Connection conn = pool.get(0); pool.remove(conn); return conn; &#125; else &#123; return null; &#125; &#125;&#125; 通过连接池的管理，实现了数据库连接的共享，不需要每一次都重新创建连接，节省了数据库重新创建的开销，提升了系统的性能！]]></content>
      <categories>
        <category>架构设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型模式-7种</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合模式]]></title>
    <url>%2F2017%2F08%2F24%2F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-7%E7%A7%8D%2F%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[组合模式，将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。掌握组合模式的重点是要理解清楚 “部分/整体” 还有 ”单个对象“ 与 “组合对象” 的含义。组合模式让你可以优化处理递归或分级数据结构。《设计模式》：将对象组合成树形结构以表示“部分整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 涉及角色：Component：是组合中的对象声明接口，在适当的情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component子部件。Leaf：在组合中表示叶子结点对象，叶子结点没有子结点。Composite：定义有枝节点行为，用来存储子部件，在Component接口中实现与子部件有关操作，如增加(add)和删除(remove)等。 比如现实中公司内各部门的层级关系，请看代码： Component：是组合中的对象声明接口，在适当的情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component子部件。 123456789101112131415161718192021222324252627public abstract class Company &#123; private String name; public Company() &#123; &#125; public Company(String name) &#123; super(); this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; protected abstract void add(Company company); protected abstract void romove(Company company); protected abstract void display(int depth);&#125; Composite：定义有枝节点行为，用来存储子部件，在Component接口中实现与子部件有关操作，如增加(add)和删除(remove)等。 123456789101112131415161718192021222324252627282930313233343536public class ConcreteCompany extends Company &#123; private List&lt;Company&gt; cList; public ConcreteCompany() &#123; cList = new ArrayList(); &#125; public ConcreteCompany(String name) &#123; super(name); cList = new ArrayList(); &#125; @Override protected void add(Company company) &#123; cList.add(company); &#125; @Override protected void display(int depth) &#123; StringBuilder sb = new StringBuilder(""); for (int i = 0; i &lt; depth; i++) &#123; sb.append("-"); &#125; System.out.println(new String(sb) + this.getName()); for (Company c : cList) &#123; c.display(depth + 2); &#125; &#125; @Override protected void romove(Company company) &#123; cList.remove(company); &#125;&#125; Leaf：在组合中表示叶子结点对象，叶子结点没有子结点。 12345678910111213141516171819202122public class HRDepartment extends Company &#123; public HRDepartment(String name) &#123; super(name); &#125; @Override protected void add(Company company) &#123; &#125; @Override protected void display(int depth) &#123; StringBuilder sb = new StringBuilder(""); for (int i = 0; i &lt; depth; i++) &#123; sb.append("-"); &#125; System.out.println(new String(sb) + this.getName()); &#125; @Override protected void romove(Company company) &#123; &#125;&#125; 12345678910111213141516171819202122public class FinanceDepartment extends Company &#123; public FinanceDepartment(String name) &#123; super(name); &#125; @Override protected void add(Company company) &#123; &#125; @Override protected void display(int depth) &#123; StringBuilder sb = new StringBuilder(""); for (int i = 0; i &lt; depth; i++) &#123; sb.append("-"); &#125; System.out.println(new String(sb) + this.getName()); &#125; @Override protected void romove(Company company) &#123; &#125;&#125; 123456789101112131415161718192021222324252627282930313233public class Client &#123; public static void main(String[] args) &#123; Company root = new ConcreteCompany(); root.setName("北京总公司"); root.add(new HRDepartment("总公司人力资源部")); root.add(new FinanceDepartment("总公司财务部")); Company shandongCom = new ConcreteCompany("山东分公司"); shandongCom.add(new HRDepartment("山东分公司人力资源部")); shandongCom.add(new FinanceDepartment("山东分公司账务部")); Company zaozhuangCom = new ConcreteCompany("枣庄办事处"); zaozhuangCom.add(new FinanceDepartment("枣庄办事处财务部")); zaozhuangCom.add(new HRDepartment("枣庄办事处人力资源部")); Company jinanCom = new ConcreteCompany("济南办事处"); jinanCom.add(new FinanceDepartment("济南办事处财务部")); jinanCom.add(new HRDepartment("济南办事处人力资源部")); shandongCom.add(jinanCom); shandongCom.add(zaozhuangCom); Company huadongCom = new ConcreteCompany("上海华东分公司"); huadongCom.add(new HRDepartment("上海华东分公司人力资源部")); huadongCom.add(new FinanceDepartment("上海华东分公司账务部")); Company hangzhouCom = new ConcreteCompany("杭州办事处"); hangzhouCom.add(new FinanceDepartment("杭州办事处财务部")); hangzhouCom.add(new HRDepartment("杭州办事处人力资源部")); Company nanjingCom = new ConcreteCompany("南京办事处"); nanjingCom.add(new FinanceDepartment("南京办事处财务部")); nanjingCom.add(new HRDepartment("南京办事处人力资源部")); huadongCom.add(hangzhouCom); huadongCom.add(nanjingCom); root.add(shandongCom); root.add(huadongCom); root.display(0); &#125;&#125;]]></content>
      <categories>
        <category>架构设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型模式-7种</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板方法模式]]></title>
    <url>%2F2017%2F08%2F22%2F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-8%E7%A7%8D%2F%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一个抽象类中，有一个主方法，再定义1…n个方法，可以是抽象的，也可以是实际的方法，定义一个类，继承该抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用。]]></content>
      <categories>
        <category>架构设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型模式-7种</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[策略模式]]></title>
    <url>%2F2017%2F08%2F22%2F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-8%E7%A7%8D%2F%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。实现：需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现这个接口，如果每个算法有一些一样的操作的话，可以设计一个抽象类，提供辅助函数。有这些实现类继承后直接调用。策略模式的决定权在于用户，系统本身提供不同算法的实现，对各种算法做封装。多用于算法决策系统中，外部用户只需决定用哪个算法即可。 1234567891011121314151617181920212223242526272829303132333435363738394041//首先统一接口：public interface ICalculator &#123; public int calculate(String exp);&#125;//辅助类：public abstract class AbstractCalculator &#123; public int[] split(String exp, String opt) &#123; String array[] = exp.split(opt); int arrayInt[] = new int[2]; arrayInt[0] = Integer.parseInt(array[0]); arrayInt[1] = Integer.parseInt(array[1]); return arrayInt; &#125;&#125;//三个实现类：public class Plus extends AbstractCalculator implements ICalculator &#123; @Override public int calculate(String exp) &#123; int arrayInt[] = split(exp, "\\+"); return arrayInt[0] + arrayInt[1]; &#125;&#125;public class Minus extends AbstractCalculator implements ICalculator &#123; @Override public int calculate(String exp) &#123; int arrayInt[] = split(exp, "\\-"); return arrayInt[0] - arrayInt[1]; &#125;&#125;public class Multiply extends AbstractCalculator implements ICalculator &#123; @Override public int calculate(String exp) &#123; int arrayInt[] = split(exp,"\\*"); return arrayInt[0]*arrayInt[1]; &#125;&#125;]]></content>
      <categories>
        <category>架构设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型模式-7种</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代子模式]]></title>
    <url>%2F2017%2F08%2F21%2F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-8%E7%A7%8D%2F%E8%BF%AD%E4%BB%A3%E5%AD%90%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[迭代器模式就是顺序访问聚集中的对象，一般来说，集合中非常常见，如果对集合类比较熟悉的话，理解本模式会十分轻松。这句话包含两层意思：一是需要遍历的对象，即聚集对象，二是迭代器对象，用于对聚集对象进行遍历访问。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public interface Collection &#123; public Iterator iterator(); /* 取得集合元素 */ public Object get(int i); /* 取得集合大小 */ public int size();&#125;public interface Iterator &#123; // 前移 public Object previous(); // 后移 public Object next(); public boolean hasNext(); // 取得第一个元素 public Object first();&#125;public class MyCollection implements Collection &#123; public String string[] = &#123; "A", "B", "C", "D", "E" &#125;; @Override public Iterator iterator() &#123; return new MyIterator(this); &#125; @Override public Object get(int i) &#123; return string[i]; &#125; @Override public int size() &#123; return string.length; &#125;&#125;public class MyIterator implements Iterator &#123; private Collection collection; private int pos = -1; public MyIterator(Collection collection)&#123; this.collection = collection; &#125; @Override public Object previous() &#123; if(pos &gt; 0)&#123; pos--; &#125; return collection.get(pos); &#125; @Override public Object next() &#123; if(pos&lt;collection.size()-1)&#123; pos++; &#125; return collection.get(pos); &#125; @Override public boolean hasNext() &#123; if(pos&lt;collection.size()-1)&#123; return true; &#125;else&#123; return false; &#125; &#125; @Override public Object first() &#123; pos = 0; return collection.get(pos); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Collection collection = new MyCollection(); Iterator it = (Iterator) collection.iterator(); while(it.hasNext())&#123; System.out.println(it.next()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>架构设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型模式-7种</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[责任链模式]]></title>
    <url>%2F2017%2F08%2F19%2F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-8%E7%A7%8D%2F%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[责任链模式，有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求，所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进行动态的调整。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public interface Handler &#123; public void operator();&#125;public abstract class AbstractHandler &#123; private Handler handler; public Handler getHandler() &#123; return handler; &#125; public void setHandler(Handler handler) &#123; this.handler = handler; &#125;&#125;public class MyHandler extends AbstractHandler implements Handler &#123; private String name; public MyHandler(String name) &#123; this.name = name; &#125; @Override public void operator() &#123; System.out.println(name + "deal!"); if (getHandler() != null) &#123; getHandler().operator(); &#125; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; MyHandler h1 = new MyHandler("h1"); MyHandler h2 = new MyHandler("h2"); MyHandler h3 = new MyHandler("h3"); h1.setHandler(h2); h2.setHandler(h3); h1.operator(); &#125;&#125; 运行结果h1deal!h2deal!h3deal!链接上的请求可以是一条链，可以是一个树，还可以是一个环，模式本身不约束这个，需要我们自己去实现，同时，在一个时刻，命令只允许由一个对象传给另一个对象，而不允许传给多个对象。]]></content>
      <categories>
        <category>架构设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型模式-7种</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[访问者模式]]></title>
    <url>%2F2017%2F08%2F18%2F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-8%E7%A7%8D%2F%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[访问者模式把数据结构和作用于结构上的操作解耦合，使得操作集合可相对自由地演化。访问者模式适用于数据结构相对稳定算法又易变化的系统。因为访问者模式使得算法操作增加变得容易。若系统数据结构对象易于变化，经常有新的数据对象增加进来，则不适合使用访问者模式。访问者模式的优点是增加操作很容易，因为增加操作意味着增加新的访问者。访问者模式将有关行为集中到一个访问者对象中，其改变不影响系统数据结构。其缺点就是增加新的数据结构很困难。 访问者模式算是最复杂也是最难以理解的一种模式了。它表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。 涉及角色：1、Visitor 抽象访问者角色，为该对象结构中具体元素角色声明一个访问操作接口。该操作接口的名字和参数标识了发送访问请求给具体访问者的具体元素角色，这样访问者就可以通过该元素角色的特定接口直接访问它。2、ConcreteVisitor.具体访问者角色，实现Visitor声明的接口。3、Element 定义一个接受访问操作(accept())，它以一个访问者(Visitor)作为参数。4、ConcreteElement 具体元素，实现了抽象元素(Element)所定义的接受操作接口。5、ObjectStructure 结构对象角色，这是使用访问者模式必备的角色。它具备以下特性：能枚举它的元素；可以提供一个高层接口以允许访问者访问它的元素；如有需要，可以设计成一个复合对象或者一个聚集（如一个列表或无序集合）。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162abstract class Element&#123; public abstract void accept(IVisitor visitor); public abstract void doSomething();&#125;class ConcreteElement1 extends Element&#123; public void doSomething()&#123; System.out.println("这是元素1"); &#125; public void accept(IVisitor visitor)&#123; visitor.visit(this); &#125;&#125;class ConcreteElement2 extends Element&#123; public void doSomething()&#123; System.out.println("这是元素2"); &#125; public void accept(IVisitor visitor)&#123; visitor.visit(this); &#125;&#125;interface IVisitor&#123; public void visit(ConcreteElement1el1); public void visit(ConcreteElement2el2);&#125;class Visitor implements IVisitor&#123; public void visit(ConcreteElement1 el1)&#123; el1.doSomething(); &#125; public void visit(ConcreteElement2 el2)&#123; el2.doSomething(); &#125;&#125;class ObjectStruture&#123; public static List&lt;Element&gt; getList()&#123; List&lt;Element&gt;list = new ArrayList&lt;Element&gt;(); Random ran = newRandom(); for(int i = 0 ; i &lt; 10 ; i ++)&#123; int a=ran.nextInt(100); if(a&gt;50)&#123; list.add (newConcreteElement1()); &#125;else&#123; list.add (newConcreteElement2()); &#125; &#125; return list; &#125;&#125;public class Client&#123; public static void main (String[]args)&#123; List&lt;Element&gt; list = ObjectStruture.getList(); for(Elemente:list)&#123; e.accept(newVisitor()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>架构设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型模式-7种</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状态模式]]></title>
    <url>%2F2017%2F08%2F18%2F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-8%E7%A7%8D%2F%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[核心思想就是：当对象的状态改变时，同时改变其行为，很好理解！就拿QQ来说，有几种状态，在线、隐身、忙碌等，每个状态对应不同的操作，而且你的好友也能看到你的状态，所以，状态模式就两点：1、可以通过改变状态来获得不同的行为。2、你的好友能同时看到你的变化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class State &#123; private String value; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; public void method1()&#123; System.out.println("execute the first opt!"); &#125; public void method2()&#123; System.out.println("execute the second opt!"); &#125;&#125;public class Context &#123; private State state; public Context(State state) &#123; this.state = state; &#125; public State getState() &#123; return state; &#125; public void setState(State state) &#123; this.state = state; &#125; public void method() &#123; System.out.println("状态为：" + state.getValue()); if (state.getValue().equals("state1")) &#123; state.method1(); &#125; else if (state.getValue().equals("state2")) &#123; state.method2(); &#125; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; State state = new State(); Context context = new Context(state); //设置第一种状态 state.setValue("state1"); context.method(); //设置第二种状态 state.setValue("state2"); context.method(); &#125;&#125; 运行结果：状态为：state1execute the first opt!状态为：state2execute the second opt!根据这个特性，状态模式在日常开发中用的挺多的，尤其是做网站的时候，我们有时希望根据对象的某一属性，区别开他们的一些功能，比如说简单的权限控制等。]]></content>
      <categories>
        <category>架构设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型模式-7种</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解释器模式]]></title>
    <url>%2F2017%2F08%2F16%2F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-8%E7%A7%8D%2F%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[解释器模式：给定一种语言，定义他的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中句子。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Context &#123; private int num1; private int num2; public Context(int num1, int num2) &#123; this.num1 = num1; this.num2 = num2; &#125; public int getNum1() &#123; return num1; &#125; public void setNum1(int num1) &#123; this.num1 = num1; &#125; public int getNum2() &#123; return num2; &#125; public void setNum2(int num2) &#123; this.num2 = num2; &#125;&#125;public interface Expression &#123; public int interpret(Context context);&#125;public class Minus implements Expression &#123; @Override public int interpret(Context context) &#123; return context.getNum1()-context.getNum2(); &#125;&#125;public class Plus implements Expression &#123; @Override public int interpret(Context context) &#123; return context.getNum1()+context.getNum2(); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; // 计算9+2-8的值 int result = new Minus().interpret((new Context(new Plus() .interpret(new Context(9, 2)), 8))); System.out.println(result); &#125;&#125;]]></content>
      <categories>
        <category>架构设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型模式-7种</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中介者模式]]></title>
    <url>%2F2017%2F08%2F16%2F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-8%E7%A7%8D%2F%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[中介者模式（Mediator）：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 举例：在一个公司里面，有很多部门、员工（我们统称他们互相为Colleague“同事”），为了完成一定的任务，“同事”之间肯定有许多需要互相配合、交流的过程。如果由各个“同事”频繁地到处去与自己有关的“同事”沟通，这样肯定会形成一个多对多的杂乱的联系网络而造成工作效率低下。 此时就需要一位专门的“中介者”给各个“同事”分配任务，以及统一跟进大家的进度并在“同事”之间实时地进行交互，保证“同事”之间必须的沟通交流。很明显我们知道此时的“中介者”担任了沟通“同事”彼此之间的重要角色了，“中介者”使得每个“同事”都变成一对一的联系方式，减轻了每个“同事”的负担，增强工作效率。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127public abstract class AbstractColleague &#123; protected AbstractMediator mediator; /**既然有中介者，那么每个具体同事必然要与中介者有联系， * 否则就没必要存在于 这个系统当中，这里的构造函数相当 * 于向该系统中注册一个中介者，以取得联系 */ public AbstractColleague(AbstractMediator mediator) &#123; this.mediator = mediator; &#125; // 在抽象同事类中添加用于与中介者取得联系（即注册）的方法 public void setMediator(AbstractMediator mediator) &#123; this.mediator = mediator; &#125;&#125;//具体同事Apublic class ColleagueA extends AbstractColleague &#123; //每个具体同事都通过父类构造函数与中介者取得联系 public ColleagueA(AbstractMediator mediator) &#123; super(mediator); &#125; //每个具体同事必然有自己分内的事，没必要与外界相关联 public void self() &#123; System.out.println("同事A --&gt; 做好自己分内的事情..."); &#125; //每个具体同事总有需要与外界交互的操作，通过中介者来处理这些逻辑并安排工作 public void out() &#123; System.out.println("同事A --&gt; 请求同事B做好分内工作 ..."); super.mediator.execute("ColleagueB", "self"); &#125;&#125;//具体同事Bpublic class ColleagueB extends AbstractColleague &#123; public ColleagueB(AbstractMediator mediator) &#123; super(mediator); &#125; public void self() &#123; System.out.println("同事B --&gt; 做好自己分内的事情..."); &#125; public void out() &#123; System.out.println("同事B --&gt; 请求同事A做好分内工作 ..."); super.mediator.execute("ColleagueA", "self"); &#125;&#125;中介者类族：public abstract class AbstractMediator &#123; //中介者肯定需要保持有若干同事的联系方式 protected Hashtable&lt;String, AbstractColleague&gt; colleagues = new Hashtable&lt;String, AbstractColleague&gt;(); //中介者可以动态地与某个同事建立联系 public void addColleague(String name, AbstractColleague c) &#123; this.colleagues.put(name, c); &#125; //中介者也可以动态地撤销与某个同事的联系 public void deleteColleague(String name) &#123; this.colleagues.remove(name); &#125; //中介者必须具备在同事之间处理逻辑、分配任务、促进交流的操作 public abstract void execute(String name, String method);&#125;//具体中介者public class Mediator extends AbstractMediator&#123; //中介者最重要的功能，来回奔波与各个同事之间 public void execute(String name, String method) &#123; if("self".equals(method))&#123; //各自做好分内事 if("ColleagueA".equals(name)) &#123; ColleagueA colleague = (ColleagueA)super.colleagues.get("ColleagueA"); colleague.self(); &#125;else &#123; ColleagueB colleague = (ColleagueB)super.colleagues.get("ColleagueB"); colleague.self(); &#125; &#125;else &#123; //与其他同事合作 if("ColleagueA".equals(name)) &#123; ColleagueA colleague = (ColleagueA)super.colleagues.get("ColleagueA"); colleague.out(); &#125;else &#123; ColleagueB colleague = (ColleagueB)super.colleagues.get("ColleagueB"); colleague.out(); &#125; &#125; &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; //创建一个中介者 AbstractMediator mediator = new Mediator(); //创建两个同事 ColleagueA colleagueA = new ColleagueA(mediator); ColleagueB colleagueB = new ColleagueB(mediator); //中介者分别与每个同事建立联系 mediator.addColleague("ColleagueA", colleagueA); mediator.addColleague("ColleagueB", colleagueB); //同事们开始工作 colleagueA.self(); colleagueA.out(); System.out.println("======================合作愉快，任务完成！\n"); colleagueB.self(); colleagueB.out(); System.out.println("======================合作愉快，任务完成！"); &#125;&#125; 运行结果：同事A –&gt; 做好自己分内的事情 …同事A –&gt; 请求同事B做好分内工作 …同事B –&gt; 做好自己分内的事情 …======================合作愉快，任务完成！ 同事B –&gt; 做好自己分内的事情 …同事B –&gt; 请求同事A做好分内工作 …同事A –&gt; 做好自己分内的事情 …======================合作愉快，任务完成！]]></content>
      <categories>
        <category>架构设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型模式-7种</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[备忘录模式]]></title>
    <url>%2F2017%2F08%2F15%2F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-8%E7%A7%8D%2F%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[保存一个对象的某个状态，以便在适当的时候恢复对象，个人觉得叫备份模式更形象些，通俗的讲下：假设有原始类A，A中有各种属性，A可以决定需要备份的属性，备忘录类B是用来存储A的一些内部状态，类C呢，就是一个用来存储备忘录的，且只能存储，不能修改等操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class Original &#123; private String value; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; public Original(String value) &#123; this.value = value; &#125; public Memento createMemento()&#123; return new Memento(value); &#125; public void restoreMemento(Memento memento)&#123; this.value = memento.getValue(); &#125;&#125;public class Memento &#123; private String value; public Memento(String value) &#123; this.value = value; &#125; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125;&#125;public class Storage &#123; private Memento memento; public Storage(Memento memento) &#123; this.memento = memento; &#125; public Memento getMemento() &#123; return memento; &#125; public void setMemento(Memento memento) &#123; this.memento = memento; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; // 创建原始类 Original origi = new Original("egg"); // 创建备忘录 Storage storage = new Storage(origi.createMemento()); // 修改原始类的状态 System.out.println("初始化状态为：" + origi.getValue()); origi.setValue("niu"); System.out.println("修改后的状态为：" + origi.getValue()); // 回复原始类的状态 origi.restoreMemento(storage.getMemento()); System.out.println("恢复后的状态为：" + origi.getValue()); &#125;&#125; 输出结果：初始化状态为：egg修改后的状态为：niu恢复后的状态为：egg]]></content>
      <categories>
        <category>架构设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型模式-7种</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[责任链模式]]></title>
    <url>%2F2017%2F08%2F15%2F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-8%E7%A7%8D%2F%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[举个例子，司令员下令让士兵去干件事情，从整个事情的角度来考虑，司令员的作用是，发出口令，口令经过传递，传到了士兵耳朵里，士兵去执行。这个过程好在，三者相互解耦，任何一方都不用去依赖其他人，只需要做好自己的事儿就行，司令员要的是结果，不会去关注到底士兵是怎么实现的。 12345678910111213141516171819202122232425262728293031323334353637383940public interface Command &#123; public void exe();&#125;public class MyCommand implements Command &#123; private Receiver receiver; public MyCommand(Receiver receiver) &#123; this.receiver = receiver; &#125; @Override public void exe() &#123; receiver.action(); &#125;&#125;public class Invoker &#123; private Command command; public Invoker(Command command) &#123; this.command = command; &#125; public void action() &#123; command.exe(); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Receiver receiver = new Receiver(); Command cmd = new MyCommand(receiver); Invoker invoker = new Invoker(cmd); invoker.action(); &#125;&#125; 命令模式的目的就是达到命令的发出者和执行者之间解耦，实现请求和执行分开，熟悉Struts的同学应该知道，Struts其实就是一种将请求和呈现分离的技术，其中必然涉及命令模式的思想！]]></content>
      <categories>
        <category>架构设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型模式-7种</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2F2017%2F08%2F15%2F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-8%E7%A7%8D%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[观察者模式定义了对象间的一对多依赖关系，当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。首先观察者必须实现一个观察者的接口，主题类除了包含注册观察者和删除观察者之外，需要实现一个通知的方法，在这个方法里面，主题类发生改变，通知观察者 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public interface Observer &#123; public void update();&#125;public class Observer1 implements Observer &#123; @Override public void update() &#123; System.out.println("observer1 has received!"); &#125;&#125;public class Observer2 implements Observer &#123; @Override public void update() &#123; System.out.println("observer2 has received!"); &#125;&#125;public interface Subject &#123; /*增加观察者*/ public void add(Observer observer); /*删除观察者*/ public void del(Observer observer); /*通知所有的观察者*/ public void notifyObservers(); /*自身的操作*/ public void operation();&#125;public abstract class AbstractSubject implements Subject &#123; private Vector&lt;Observer&gt; vector = new Vector&lt;Observer&gt;(); @Override public void add(Observer observer) &#123; vector.add(observer); &#125; @Override public void del(Observer observer) &#123; vector.remove(observer); &#125; @Override public void notifyObservers() &#123; Enumeration&lt;Observer&gt; enumo = vector.elements(); while(enumo.hasMoreElements())&#123; enumo.nextElement().update(); &#125; &#125;&#125;public class MySubject extends AbstractSubject &#123; @Override public void operation() &#123; System.out.println("update self!"); notifyObservers(); &#125;&#125;]]></content>
      <categories>
        <category>架构设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型模式-7种</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[外观模式]]></title>
    <url>%2F2017%2F08%2F14%2F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-7%E7%A7%8D%2F%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[外观模式是为了解决类与类之间的依赖关系的，像spring一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口。 12345678910public class CPU &#123; public void startup() &#123; System.out.println("cpu startup!"); &#125; public void shutdown() &#123; System.out.println("cpu shutdown!"); &#125;&#125; 12345678910public class Disk &#123; public void startup() &#123; System.out.println("disk startup!"); &#125; public void shutdown() &#123; System.out.println("disk shutdown!"); &#125;&#125; 12345678910public class Memory &#123; public void startup() &#123; System.out.println("memory startup!"); &#125; public void shutdown() &#123; System.out.println("memory shutdown!"); &#125;&#125; 12345678910111213141516171819202122232425262728public class Computer &#123; private CPU cpu; private Memory memory; private Disk disk; public Computer() &#123; cpu = new CPU(); memory = new Memory(); disk = new Disk(); &#125; public void startup() &#123; System.out.println("start the computer!"); cpu.startup(); memory.startup(); disk.startup(); System.out.println("start computer finished!"); &#125; public void shutdown() &#123; System.out.println("begin to close the computer!"); cpu.shutdown(); memory.shutdown(); disk.shutdown(); System.out.println("computer closed!"); &#125;&#125; 1234567public class Test &#123; public static void main(String[] args) &#123; Computer computer = new Computer(); computer.startup(); computer.shutdown(); &#125;&#125;]]></content>
      <categories>
        <category>架构设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型模式-7种</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F2017%2F08%2F13%2F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-7%E7%A7%8D%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[代理模式就是多出一个代理类，替原对象进行一些操作。代理类就像中介。123456789101112131415161718192021222324252627282930313233343536public interface Sourceable &#123; public void method();&#125;public class Source implements Sourceable &#123; @Override public void method() &#123; System.out.println("the original method!"); &#125;&#125;public class Proxy implements Sourceable &#123; private Source source; public Proxy() &#123; super(); this.source = new Source(); &#125; @Override public void method() &#123; before(); source.method(); atfer(); &#125; private void atfer() &#123; System.out.println("after proxy!"); &#125; private void before() &#123; System.out.println("before proxy!"); &#125;&#125;public class ProxyTest &#123; public static void main(String[] args) &#123; Sourceable source = new Proxy(); source.method(); &#125;&#125;]]></content>
      <categories>
        <category>架构设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型模式-7种</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰器模式]]></title>
    <url>%2F2017%2F08%2F13%2F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-7%E7%A7%8D%2F%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[装饰模式：在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。装饰模式的特点：（1）、装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。（2）、装饰对象包含一个真实对象的引用（reference）（3）、装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。（4）、装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。继承不能做到这一点，继承的功能是静态的，不能动态增删。 12345678910111213141516171819202122232425262728293031323334353637383940414243public interface Sourceable &#123; public void method();&#125;public class Source implements Sourceable &#123; @Override public void method() &#123; System.out.println("the original method!"); &#125;&#125;public class Decorator implements Sourceable &#123; private Sourceable source; public Decorator(Sourceable source) &#123; super(); this.source = source; &#125; @Override public void method() &#123; System.out.println("before decorator!"); source.method(); System.out.println("after decorator!"); &#125;&#125;public class DecoratorTest &#123; public static void main(String[] args) &#123; //（1） 装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。 //（2） 装饰对象包含一个真实对象的引用（reference） //（3） 装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。 //（4） 装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。 // 在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。 // 继承不能做到这一点，继承的功能是静态的，不能动态增删。 Sourceable source = new Source(); Sourceable obj = new Decorator(source); obj.method(); &#125;&#125;]]></content>
      <categories>
        <category>架构设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型模式-7种</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[适配器模式]]></title>
    <url>%2F2017%2F08%2F13%2F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-7%E7%A7%8D%2F%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[适配器模式主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。有点抽象，我们来看看详细的内容。 1、类的适配器模式类的适配器模式核心思想就是：有一个Source类，拥有一个方法，待适配，目标接口是Targetable，通过Adapter类，将Source的功能扩展到Targetable里。123456789101112131415161718192021222324252627public class Source &#123; public void method1() &#123; System.out.println("this is original method!"); &#125;&#125;public interface Targetable &#123; /* 与原类中的方法相同 */ public void method1(); /* 新类的方法 */ public void method2();&#125;public class Adapter extends Source implements Targetable &#123; public void method2() &#123; System.out.println("this is the targetable method!"); &#125;&#125;public class AdapterTest &#123; public static void main(String[] args) &#123; Targetable target = new Adapter(); target.method1(); target.method2(); &#125;&#125; 2、对象的适配器模式对象的适配器模式的基本思路和类的适配器模式相同，只是将Adapter类作修改成Wrapper，这次不继承Source类，而是持有Source类的实例，以达到解决兼容性的问题。12345678910111213141516171819202122232425262728public class Wrapper implements Targetable &#123; private Source source; public Wrapper(Source source) &#123; super(); this.source = source; &#125; @Override public void method2() &#123; System.out.println("this is the targetable method!"); &#125; @Override public void method1() &#123; source.method1(); &#125;&#125;public class AdapterTest &#123; public static void main(String[] args) &#123; Source source = new Source(); Targetable target = new Wrapper(source); target.method1(); target.method2(); &#125;&#125; 3、接口的适配器模式接口的适配器是这样的：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行了。]]></content>
      <categories>
        <category>架构设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型模式-7种</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型模式]]></title>
    <url>%2F2017%2F08%2F12%2F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-5%E7%A7%8D%2F%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。说道复制对象，我将结合对象的浅复制和深复制来说一下，首先需要了解对象深、浅复制的概念：浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。 1234567891011121314151617181920212223242526272829303132333435363738394041public class Prototype implements Cloneable, Serializable &#123; private static final long serialVersionUID = 1L; private int base; private Integer obj; /* 浅复制 */ public Object clone() throws CloneNotSupportedException &#123; // 因为Cloneable接口是个空接口，你可以任意定义实现类的方法名 // 如cloneA或者cloneB，因为此处的重点是super.clone()这句话 // super.clone()调用的是Object的clone()方法 // 而在Object类中，clone()是native（本地方法）的 Prototype proto = (Prototype) super.clone(); return proto; &#125; /* 深复制 */ public Object deepClone() throws IOException, ClassNotFoundException &#123; /* 写入当前对象的二进制流 */ ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); /* 读出二进制流产生的新对象 */ ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); return ois.readObject(); &#125; public int getBase() &#123; return base; &#125; public void setBase(int base) &#123; this.base = base; &#125; public Integer getObj() &#123; return obj; &#125; public void setObj(Integer obj) &#123; this.obj = obj; &#125;&#125; 测试1234567891011121314public class Test &#123; public static void main(String[] args) throws CloneNotSupportedException, ClassNotFoundException, IOException &#123; Prototype prototype = new Prototype(); prototype.setBase(1); prototype.setObj(new Integer(2)); /* 浅复制 */ Prototype prototype1 = (Prototype) prototype.clone(); /* 深复制 */ Prototype prototype2 = (Prototype) prototype.deepClone(); System.out.println(prototype1.getObj()==prototype1.getObj()); System.out.println(prototype1.getObj()==prototype2.getObj()); &#125;&#125;]]></content>
      <categories>
        <category>架构设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式-5种</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建造者模式]]></title>
    <url>%2F2017%2F08%2F12%2F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-5%E7%A7%8D%2F%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示 Product（要创建的复杂对象） 12345public class Person &#123; private String head; private String body; private String foot; //get…set…方法 Builder（给出一个抽象接口，以规范产品对象的各个组成成分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建） 123456public interface PersonBuilder &#123; void buildHead(); void buildBody(); void buildFoot(); Person buildPerson();&#125; ConcreteBuilder（实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。 在建造过程完成后，提供产品的实例） 123456789101112131415161718192021public class ManBuilder implements PersonBuilder &#123; Person person; public ManBuilder() &#123; person = new Person(); &#125; public void buildBody() &#123; person.setBody("建造男人的身体"); &#125; public void buildFoot() &#123; person.setFoot("建造男人的脚"); &#125; public void buildHead() &#123; person.setHead("建造男人的头"); &#125; public Person buildPerson() &#123; return person; &#125;&#125; Director（调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。 12345678public class PersonDirector &#123; public Person constructPerson(PersonBuilder pb) &#123; pb.buildHead(); pb.buildBody(); pb.buildFoot(); return pb.buildPerson(); &#125;&#125; 测试 123456789public class Test &#123; public static void main(String[] args) &#123; PersonDirector pd = new PersonDirector(); Person person = pd.constructPerson(new ManBuilder()); System.out.println(person.getBody()); System.out.println(person.getFoot()); System.out.println(person.getHead()); &#125;&#125;]]></content>
      <categories>
        <category>架构设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式-5种</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式（7种）]]></title>
    <url>%2F2017%2F08%2F11%2F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-5%E7%A7%8D%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%887%E7%A7%8D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[解决问题保证一个类在内存中的对象唯一性比如：多程序读取一个配置文件时，建议配置文件封装成对象。会方便操作其中数据，又要保证多个程序读到的是同一个配置文件对象，就需要该配置文件对象在内存中是唯一的。Runtime()方法就是单例设计模式进行设计的解析RuntimeRuntime类封装了运行时的环境，每一个java应用程序都有一个Runtime实例，保证应用程序能够与其运行的环境相连接 1、单例模式，饿汉式，线程安全12345678public static class Singleton &#123; private final static Singleton INSTANCE = new Singleton(); private Singleton() &#123;&#125; public static Singleton getInstance() &#123; return INSTANCE; &#125;&#125; 2、单例模式，懒汉式，线程不安全12345678910public static class Singleton2 &#123; private static Singleton2 instance = null; private Singleton2() &#123;&#125; public static Singleton2 getInstance() &#123; if (instance == null) &#123; instance = new Singleton2(); &#125; return instance; &#125;&#125; 3、单例模式，饿汉式，线程安全，多线程环境下效率不高12345678910public static class Singleton3 &#123; private static Singleton3 instance = null; private Singleton3() &#123;&#125; public static synchronized Singleton3 getInstance() &#123; if (instance == null) &#123; instance = new Singleton3(); &#125; return instance; &#125;&#125; 4、单例模式，饿汉式，变种，线程安全12345678910public static class Singleton4 &#123; private static Singleton4 instance = null; static &#123; instance = new Singleton4(); &#125; private Singleton4() &#123;&#125; public static Singleton4 getInstance() &#123; return instance; &#125;&#125; 5、单例模式，懒汉式，使用静态内部类，线程安全【推荐】利用了classloder的机制来保证初始化instance时只有一个线程。是Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。 123456789public static class Singleton5 &#123; private final static class SingletonHolder &#123; private static final Singleton5 INSTANCE = new Singleton5(); &#125; private Singleton5() &#123;&#125; public static Singleton5 getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 6、使用枚举方式，线程安全【推荐】不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象12345public enum Singleton6 &#123; INSTANCE; public void whateverMethod() &#123; &#125;&#125; 7、静态内部类，使用双重校验锁，线程安全【推荐】1234567891011121314public static class Singleton7 &#123; private volatile static Singleton7 instance = null; private Singleton7() &#123;&#125; public static Singleton7 getInstance() &#123; if (instance == null) &#123; synchronized (Singleton7.class) &#123; if (instance == null) &#123; instance = new Singleton7(); &#125; &#125; &#125; return instance; &#125;&#125;]]></content>
      <categories>
        <category>架构设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式-5种</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象工厂模式]]></title>
    <url>%2F2017%2F08%2F11%2F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-5%E7%A7%8D%2F%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂方法模式的问题是，类的创建依赖于工厂类，也就是说，如果要扩展程序，需要修改工厂类，违背了开闭原则，就是，对修改关闭，对扩展开放。所以抽象工厂模式就是解决这个问题的：创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂就可以了，不需要修改。123456789101112131415161718public interface Provider &#123; public MyInterface produce();&#125;public class MyFactoryOne implements Provider &#123; @Override public MyInterface produce() &#123; return new MyClassOne(); &#125;&#125;public class MyFactoryTwo implements Provider &#123; @Override public MyInterface produce() &#123; return new MyClassTwo(); &#125;&#125;]]></content>
      <categories>
        <category>架构设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式-5种</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂方法模式]]></title>
    <url>%2F2017%2F08%2F11%2F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-5%E7%A7%8D%2F%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂方法模式就是专门创建实例的factory，其中包括：普通工厂，多个工厂方法模式，静态工厂模式 1、普通工厂普通工厂就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。123456789101112public class MyFactory &#123; public MyInterface produce(String type) &#123; if ("One".equals(type)) &#123; return new MyClassOne(); &#125; else if ("Two".equals(type)) &#123; return new MyClassTwo(); &#125; else &#123; System.out.println("没有要找的类型"); return null; &#125; &#125;&#125; 2、多个工厂方法模式多个工厂方法模式，是对普通工厂方法模式的改进，提供多个工厂方法，分别创建对象12345678public class MyFactory &#123; public MyInterface produceOne() &#123; return new MyClassOne(); &#125; public MyInterface produceTwo() &#123; return new MyClassTwo(); &#125;&#125; 3、静态工厂模式静态工厂方法模式，将工厂方法模式里的方法设置为静态的，不需要创建实例，直接调用]]></content>
      <categories>
        <category>架构设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式-5种</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式6大原则]]></title>
    <url>%2F2017%2F08%2F11%2F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F6%E5%A4%A7%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[1、单一职责原则不要存在多于一个导致类变更的原因。也就是说一个类只负责一个职责比如说：类A负责两个不同的职责：P1和P2，当p1的需求发生改变时，需要修改A，可能导致原来的职责P2不可用。解决：建两个类 2、里氏代换原则简单的说就是：a、 子类的能力必须大于父类，即父类可以使用的方法，子类都可以使用 3、依赖倒置原则(the Dependency Inversion Principle DIP)高层模块不应该依赖底层模块，两者都应该依赖于抽象细节应该依赖于抽象简单就是：面向接口编程假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类： 而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口：这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖。一个常见的问题就是编译A模块时需要直接包含到B模块的cpp文件，而编译B时同样要直接包含到A的cpp文件。 4、接口隔离原则(the Interface Segregation Principle ISP)模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来 5、迪米特法则一个类应该对自己需要耦合或调用的类知道的最少，内部如何复杂没关系，我只需知道提供了哪些public方法就可以了。 6、开闭原则对扩展开放，对修改关闭。在程序需要进行扩展的时候，不能去修改原有的代码，实现热插拔。]]></content>
      <categories>
        <category>架构设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式-5种</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[佳句赏析_2]]></title>
    <url>%2F2017%2F03%2F11%2F%E8%AF%BB%E4%B9%A6%E8%A7%82%E5%BD%B1%2F%E4%B9%A6%E7%B1%8D%2F%E4%BD%B3%E5%8F%A5%E8%B5%8F%E6%9E%90_2%2F</url>
    <content type="text"><![CDATA[1，找到你害怕的点，你就能成功了。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[佳句赏析_1]]></title>
    <url>%2F2017%2F03%2F06%2F%E8%AF%BB%E4%B9%A6%E8%A7%82%E5%BD%B1%2F%E4%B9%A6%E7%B1%8D%2F%E4%BD%B3%E5%8F%A5%E8%B5%8F%E6%9E%90_1%2F</url>
    <content type="text"><![CDATA[1、如果曾经有一个人为了你而等待，不管是三年还是三个月，请不要那样轻率地选择拒绝。这世间的缘分并不像空气那样廉价，再平凡不过的相遇与相识，亦是前世的修行在今生的回报。在亲情以外，没有谁人能够轻易而又不求回报地为一个人付出一段寂寞的等待。即使没有欣喜的结果，也一度温暖过冷若冰霜的心灵。 2、有时候，同样的一件事情，我们可以去安慰别人，却说服不了自己。每个人，在困惑苦闷的时候，都需要身边有朋友能够开解一下自己，其实，并非我们不懂得那些道理，只是我们特别需要听到别人把它再复述出来，以来验证和坚定那些道理的真理性。 3、有些事，我们明知道是错的，也要去坚持，因为不甘心；有些人，我们明知道是爱的，也要去放弃，因为没结局；有时候，我们明知道无路可走，却还在前行，因为这已成了一种无法改变的习惯… 4、假如你想要一件东西，就放他走，它若能回来找你，就永远属于你，它若不回来，那根本就不是你的 ————莫言 5、最好的浪漫，就是平淡的相处。你知道对方就在那里，很踏实。所有的时间都得以安放，像是忘记你们正在谈恋爱。 ——————张皓宸《我与世界只差一个你》 6、投硬币，想扔第二次的时候，其实就已经知道答案了。 ——————张皓宸《我与世界只差一个你》 7、爱是对方给了你一巴掌，你还会关心她手为什么这么凉。 ——————张皓宸《我与世界只差一个你》 8、写了那么多状态，发了那么多照片，收到那么多赞，却少了你那一个，不爽。 ——————张皓宸《我与世界只差一个你》 9、因为是你 晚一点也没关系 ——————张皓宸《我与世界只差一个你》 10、Ctrl＋Alt＋Del＝重启 ————张皓宸《我与世界只差一个你》 11、我没法保证不让你的世界下雨，但我带了伞。 ——————张皓宸《我与世界只差一个你》 12、一直都觉得如果此生都没能跟你在一起，那也算是虚度了爱情。 ————张皓宸《我与世界只差一个你》 13、人生中最重要的三件事从轻到重排列我 爱 你爱 你你《我与世界只差一个你》 14、时间会让人相遇把你和我变成我们晚一点没关系——————张皓宸《我与世界只差一个你》 15、女人如衣服，朋友如手足，那是古人说的话，不给你衣服穿，你还有脸出门吗。 ——————张皓宸《我与世界只差一个你》 16、那些错过的，就像史铁生说过的：“我什么也没忘，但有些事只适合收藏.” ——————张皓宸《我与世界只差一个你》 17、心里住着一个人，久了就会成为习惯. ——————张锆宸《我与世界只差一个你》 18、Facing the Sea with Spring Blossoms 面朝大海，春暖花开 ——海子 19、我还是很喜欢你，像庄周梦蝶翼，相思遥递。我还是很在乎你，像玄宗寻杨姬，遥遥无期。 20、我好像丢了一样很重要的东西，我再也找不到。———— 乐小米-凉生，我们可不可以不忧伤 21、没有智慧的勇气，是鲁莽。没有宽容的勇气，是偏执。没有爱的勇气，是残暴。——裟椤双树 《浮生物语 猎狮》 22、什么叫君子动口不动手？最典型的就是：我只吃饭不洗碗…… 23、凡所有相,皆是虚妄。————《金刚经》（往事随风，封存记忆。） 24、我们淋着同一天空的雨，却撑着不同的伞。 25、文艺就是首先否认自己所做事情的所有世俗定义，再加上一些诗意我不是在写程序，我只是想让这些代码看起来不那么孤独。 26、湿透的衣裳，终究会干。可以遗忘的，都不再重要。——————尼采 27、心疼去看医生，医生说是装了不该装的人，得赶紧卸载，程序正在卸载中，可过程有些漫长 28、在吗^^给你个大惊喜Y(＾＾)Y我不爱你了 开心吧(^_^) 29、没有实力的愤怒毫无意义！ 30、别说你是单身狗，狗到你这个年龄已经死了 31、一个安静的夜晚，我独自一人，有些空虚，有些凄凉。坐在星空下，抬头仰望美丽天空，感觉真实却又虚幻，闪闪烁烁，似乎看来还有些跳动。美的一切总在瞬间，如同“海市蜃楼”般，也只是刹那间的一闪而过，当天空变得明亮，而这星星也早已一同退去……————————路遥 《平凡的世界》 32、早睡是一门失传许久的民间艺术，建议申遗。 33、如果你对我是淡淡的，对别人是浓浓的，叫我如何去安心…… 34、妈妈告诉我，不能交不三不四的朋友，所以我的朋友都很二 35、自古红颜多薄命，因为没人在意丑哔活多久哇]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[finalize方法]]></title>
    <url>%2F2017%2F02%2F25%2Fjava%2F%E6%BA%90%E7%A0%81%2FObject%E7%B1%BB%2Ffinalize%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、finalize的作用finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。finalize()与C++中的析构函数不是对应的。C++中的析构函数调用的时机是确定的（对象离开作用域或delete掉），但Java中的finalize的调用具有不确定性不建议用finalize方法完成“非内存资源”的清理工作，但建议用于：① 清理本地对象(通过JNI创建的对象)；② 作为确保某些非内存资源(如Socket、文件等)释放的一个补充：在finalize方法中显式调用其他资源释放方法。 二、finalize的问题一些与finalize相关的方法，由于一些致命的缺陷，已经被废弃了，如System.runFinalizersOnExit()方法、Runtime.runFinalizersOnExit()方法System.gc()与System.runFinalization()方法增加了finalize方法执行的机会，但不可盲目依赖它们Java语言规范并不保证finalize方法会被及时地执行、而且根本不会保证它们会被执行finalize方法可能会带来性能问题。因为JVM通常在单独的低优先级线程中完成finalize的执行对象再生问题：finalize方法中，可将待回收对象赋值给GC Roots可达的对象引用，从而达到对象再生的目的finalize方法至多由GC执行一次(用户当然可以手动调用对象的finalize方法，但并不影响GC对finalize的行为) 三、finalize的执行过程(生命周期)(1) 首先，大致描述一下finalize流程：当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。(2) 具体的finalize流程：对象可由两种状态，涉及到两类状态空间，一是终结状态空间 F = {unfinalized, finalizable, finalized}；二是可达状态空间 R = {reachable, finalizer-reachable, unreachable}。各状态含义如下：unfinalized: 新建对象会先进入此状态，GC并未准备执行其finalize方法，因为该对象是可达的finalizable: 表示GC可对该对象执行finalize方法，GC已检测到该对象不可达。正如前面所述，GC通过F-Queue队列和一专用线程完成finalize的执行finalized: 表示GC已经对该对象执行过finalize方法reachable: 表示GC Roots引用可达finalizer-reachable(f-reachable)：表示不是reachable，但可通过某个finalizable对象可达unreachable：对象不可通过上面两种途径可达 四、注册finalizer类类A重写了finalize方法，在new A() 的时候首先标记它是一个Finalizer类，然后调用Object的空构造方法，在这里Hotspot在初始化Object的时候讲return指令替换为_return_register_finalizer指令，该指令是Hotspot扩展的指令，在处理该指令时，调用Finalizer.register方法，可以很小的侵入性代价1234567891011121314151617181920212223242526272829303132333435363738final class Finalizer extends FinalReference&lt;Object&gt; &#123; // 引用队列 private static ReferenceQueue&lt;Object&gt; queue = new ReferenceQueue&lt;&gt;(); // 静态的Finalizer链 private static Finalizer unfinalized = null; private static final Object lock = new Object(); private Finalizer next = null, prev = null; private boolean hasBeenFinalized() &#123; return (next == this); &#125; /** * unfinalized链不为空，让自己指向unfinalized，unfinalized的prev指向自己 * unfinalized指向自己 * 最终unfinalized将指向最后加进来的对象，并且这个链包含所有实现finalize方法的对象 */ private void add() &#123; synchronized (lock) &#123; if (unfinalized != null) &#123; this.next = unfinalized; unfinalized.prev = this; &#125; unfinalized = this; &#125; &#125; private Finalizer(Object finalizee) &#123; super(finalizee, queue); add(); &#125; /* Invoked by VM */ // 这个register就是在new Object()的时候进行调用的 static void register(Object finalizee) &#123; new Finalizer(finalizee); &#125;&#125; register除了把实现finalize方法的对象加到一个名为unfinalized的链表中外，还在构造方法中调用了super(finalizee, queue);，最终进入了Reference的构造方法中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192class FinalReference&lt;T&gt; extends Reference&lt;T&gt; &#123; public FinalReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123; super(referent, q); &#125;&#125;public abstract class Reference&lt;T&gt; &#123; // 用于保存对象的引用，GC会根据不同Reference来特别对待 private T referent; /* Treated specially by GC */ // 如果需要通知机制，则保存的对对应的队列 volatile ReferenceQueue&lt;? super T&gt; queue; /* 这个用于实现一个单向循环链表，用以将保存需要由ReferenceHandler处理的引用 */ Reference next; transient private Reference&lt;T&gt; discovered; /* used by VM */ static private class Lock &#123; &#125;; private static Lock lock = new Lock(); // 此属性保存一个PENDING的队列，配合上述next一起使用 private static Reference&lt;Object&gt; pending = null; /* High-priority thread to enqueue pending References */ private static class ReferenceHandler extends Thread &#123; ReferenceHandler(ThreadGroup g, String name) &#123; super(g, name); &#125; public void run() &#123; for (;;) &#123; Reference&lt;Object&gt; r; synchronized (lock) &#123; if (pending != null) &#123; // 取得当前pending的Reference链 r = pending; // pending指向Reference链的下一个元素discovered pending = r.discovered; r.discovered = null; &#125; else &#123; try &#123; try &#123; lock.wait(); &#125; catch (OutOfMemoryError x) &#123; &#125; &#125; catch (InterruptedException x) &#123; &#125; continue; &#125; &#125; // Fast path for cleaners if (r instanceof Cleaner) &#123; ((Cleaner)r).clean(); continue; &#125; ReferenceQueue&lt;Object&gt; q = r.queue; // 入队列 if (q != ReferenceQueue.NULL) q.enqueue(r); &#125; &#125; &#125; static &#123; ThreadGroup tg = Thread.currentThread().getThreadGroup(); for (ThreadGroup tgn = tg; tgn != null; tg = tgn, tgn = tg.getParent()); Thread handler = new ReferenceHandler(tg, "Reference Handler"); /* If there were a special system-only priority greater than * MAX_PRIORITY, it would be used here */ handler.setPriority(Thread.MAX_PRIORITY); handler.setDaemon(true); handler.start(); &#125; public T get() &#123; return this.referent; &#125; public void clear() &#123; this.referent = null; &#125; public boolean isEnqueued() &#123; return (this.queue == ReferenceQueue.ENQUEUED); &#125; public boolean enqueue() &#123; return this.queue.enqueue(this); &#125; Reference(T referent) &#123; this(referent, null); &#125; Reference(T referent, ReferenceQueue&lt;? super T&gt; queue) &#123; this.referent = referent; this.queue = (queue == null) ? ReferenceQueue.NULL : queue; &#125;&#125; Reference中有两个变量pending和discovered，我们它们两个没有地方可以赋值，都是由GC来操作的，下面是状态图：Reference内部有一个线程ReferenceHandler，一旦使用了Reference，则会启动该线程。该线程会拿到pending的Reference，把它加入到ReferenceQueue中。并把queue的状态设为ENQUEUED，并通过Reference的next属性把对象串起来，犹如一个链表。下面是ReferenceQueue的enqueue() 1234567891011121314151617181920boolean enqueue(Reference&lt;? extends T&gt; r) &#123; synchronized (lock) &#123; ReferenceQueue&lt;?&gt; queue = r.queue; if ((queue == NULL) || (queue == ENQUEUED)) &#123; return false; &#125; assert queue == this; r.queue = ENQUEUED; // r的next节点指向当前头结点 r.next = (head == null) ? r : head; // 头结点指向当前对象r head = r; queueLength++; if (r instanceof FinalReference) &#123; sun.misc.VM.addFinalRefCount(1); &#125; lock.notifyAll(); return true; &#125;&#125; 五、finalize方法导致内存溢出JVM会为每一个Finalizable对象创建一个看门狗（watchdog）。这是Finalizer类的一个实例。而所有的这些看门狗又会为Finalizer类所引用。由于存在这么一个引用链，因此整个的这些对象都是存活的。那现在Eden区已经满了，而所有对象又都存在引用，GC没辙了只能把它们全拷贝到Suvivor区。更糟糕的是，一旦连Survivor区也满了，只能存到老生代里面了。你应该还记得，Eden区使用的是一种”抛弃一切”的清理策略，而老生代的GC则完全不同，它采用的是一种开销更大的方式。 为什么会出现溢出？因为Finalizer线程和主线程相比它的优先级要低。这意味着分配给它的CPU时间更少，因此它的处理速度没法赶上新对象创建的速度。这就是问题的根源——对象创建的速度要比Finalizer线程调用finalize()结束它们的速度要快，这导致最后堆中所有可用的空间都被耗尽了。结果就是——java.lang.OutOfMemoryError 结论：JVM创建Finalizable对象JVM创建 java.lang.ref.Finalizer实例，指向刚创建的对象。java.lang.ref.Finalizer类持有新创建的java.lang.ref.Finalizer的实例。这使得下一次新生代GC无法回收这些对象。新生代GC无法清空Eden区，因此会将这些对象移到Survivor区或者老生代。垃圾回收器发现这些对象实现了finalize()方法。因为会把它们添加到java.lang.ref.Finalizer.ReferenceQueue队列中。Finalizer线程会处理这个队列，将里面的对象逐个弹出，并调用它们的finalize()方法。finalize()方法调用完后，Finalizer线程会将引用从Finalizer类中去掉，因此在下一轮GC中，这些对象就可以被回收了。Finalizer线程会和我们的主线程进行竞争，不过由于它的优先级较低，获取到的CPU时间较少，因此它永远也赶不上主线程的步伐。程序消耗了所有的可用资源，最后抛出OutOfMemoryError异常。 五、Java9中的垃圾回收机制finalize机制本身就是存在问题的。finalize机制可能会导致性能问题，死锁和线程挂起。finalize中的错误可能导致内存泄漏；如果不在需要时，也没有办法取消垃圾回收；并且没有指定不同执行finalize对象的执行顺序。此外，没有办法保证finlize的执行时间。遇到这些情况，对象调用finalize方法只有被无限期延后。Java9中finalize方法已经被废弃。占有非堆资源的对象实例，类应该提供一个方法以明确释放这些资源，如果合适的话他们也应该实现AutoCloseable接口。java.lang.ref.Cleaner和java.lang.ref.PhantomReference提供更灵活和有效的方式，在对象无法再访问时释放资源。]]></content>
      <categories>
        <category>java</category>
        <category>jdk源码分析</category>
        <category>Object类</category>
      </categories>
      <tags>
        <tag>jdk源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hashcode方法]]></title>
    <url>%2F2017%2F02%2F25%2Fjava%2F%E6%BA%90%E7%A0%81%2FObject%E7%B1%BB%2Fhashcode%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、hashcode方法的作用为了配合基于散列的集合一起正常运行，包括HashSet，HashMap，和HashTable 问：当向集合中插入对象时，如何判断集合中是否已存在该对象？单纯使用equals比较，效率低。当集合要添加新的对象时，先调用对象的hashcodef方法，得到对应的hashcode值，实际上在HashMap的具体实现中会用一个table保存已经存进去对象的hashcode值，如果没有可以直接存，如果存在hashcode值则调用equals进行比较。java的hashcodef方法是根据一定的规则，将与对象相关的信息（如对象的存储地址，对象的字段等）映射成一个数值，称为散列值。]]></content>
      <categories>
        <category>java</category>
        <category>jdk源码分析</category>
        <category>Object类</category>
      </categories>
      <tags>
        <tag>jdk源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[concurrent包结构]]></title>
    <url>%2F2017%2F02%2F25%2Fjava%2F%E6%BA%90%E7%A0%81%2FJ.U.C%E6%BA%90%E7%A0%81%2Fconcurrent%E5%8C%85%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[一、Aomic数据类型java.util.concurrent.atomic包里面，实现了原子化操作的数据类型，包括 Boolean, Integer, Long, 和Referrence这四种类型以及这四种类型的数组类型。 二、锁java.util.concurrent.lock包里面，实现了并发操作中的几种类型的锁 三、java集合框架中的一些数据结构的并发实现实现的数据结构主要有List, Queue和Map 四、多线程任务执行Callable 被执行的任务Executor 执行任务Future 异步提交任务的返回数据 五、线程管理类主要是对线程集合的管理的实现，有CyclicBarrier, CountDownLatch,Exchanger等一些类]]></content>
      <categories>
        <category>java</category>
        <category>jdk源码分析</category>
        <category>J.U.C源码</category>
      </categories>
      <tags>
        <tag>jdk源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[clone方法]]></title>
    <url>%2F2017%2F02%2F24%2Fjava%2F%E6%BA%90%E7%A0%81%2FObject%E7%B1%BB%2Fclone%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[理解源码中的clone方法1protected native Object clone() throws CloneNotSupportedException; 1、Object类的clone方法是一个native方法，native方法的效率一般远高于非native方法这就是为什么要用clone方法，而不是先new一个类，然后把原始对象中的信息复制到新对象中。 2、Object类中的clone方法被protected修饰。重载clone方法，重载的需要设置为public 3、Object.clone方法返回一个Object对象。需要强制类型转换才能得到需要的类型。 浅层复制和深层复制概念浅层复制：被复制的对象的所有成员属性都有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。浅层复制仅仅复制所考虑的对象，而不复制它所引用的对象深层复制：被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象。而不是原来那些被引用的对象。深层复制要复制的对象引用的对象都复制一遍。 java中对象的克隆1）在派生类中实现Cloneable接口2）为了获取对象的一份拷贝，可以利用Object类的clone方法3）在派生类中覆盖积累的clone方法，声明为public4）在派生类的clone方法中，调用super.clone(). 实现cloneable接口12public interface Cloneable &#123;&#125; Cloneable接口仅仅是一个标志，而且这个标志也仅仅是针对 Object类中 clone()方法的，如果 clone 类没有实现 Cloneable 接口，并调用了 Object 的 clone() 方法（也就是调用了 super.Clone() 方法），那么Object 的 clone() 方法就会抛出 CloneNotSupportedException 异常。 利用串行化来实现深层复制把对象写到流中的过程是串行化(Serilization)过程，而把对象从流中读出来是并行化(Deserialization)过程。应当指出的是，写在流中的是对象的一个拷贝，而原来对象仍然存在JVM里面。在Java语言里深层复制一个对象，常常可以先使对象实现Serializable接口，然后把对象（实际上只是对象的一个拷贝）写到一个流中，再从流中读出来，便可以重建对象。这样做的前提是对象以及对象内部所有引用到的对象都是可串行化的，否则，就需要仔细考察那些不可串行化的对象是否设成transient，从而将之排除在复制过程之外。]]></content>
      <categories>
        <category>java</category>
        <category>jdk源码分析</category>
        <category>Object类</category>
      </categories>
      <tags>
        <tag>jdk源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[29-交叉字符串]]></title>
    <url>%2F2017%2F02%2F23%2F%E7%AE%97%E6%B3%95%2Flintcode%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F29-%E4%BA%A4%E5%8F%89%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目给出三个字符串:s1、s2、s3，判断s3是否由s1和s2交叉构成。样例比如 s1 = “aabcc” s2 = “dbbca” - 当 s3 = &quot;aadbbcbcac&quot;，返回 true. - 当 s3 = &quot;aadbbbaccc&quot;， 返回 false. 分析s1取一部分，s2取一部分，最后是否匹配s3dp[i][j]，表示s1取前i位（第i位之前的字符串也必须是构成s3）s2取前j位（第j位之前的字符串也必须是构成s3），表示是否能组成s3的前i+j位s1, s2只有两个字符串，因此可以展平为一个二维地图，判断是否能从左上角走到右下角。当s1到达第i个元素，s2到达第j个元素:地图上往右一步就是s2[j-1]匹配s3[i+j-1]。地图上往下一步就是s1[i-1]匹配s3[i+j-1]。示例：s1=”aa”,s2=”ab”,s3=”aaba”。标1的为可行。最终返回右下角。矩阵中红色的数值1表示dp[s1==0][s2==1]是构成s3的，所以1表示true. 代码12]]></content>
      <categories>
        <category>算法</category>
        <category>lintcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object类源码分析]]></title>
    <url>%2F2017%2F02%2F23%2Fjava%2F%E6%BA%90%E7%A0%81%2FObject%E7%B1%BB%2FObject%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[1、getClass方法final native获得运行时类型 2、hashCode方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。 一般必须满足obj1.equals(obj2)==true。可以推出obj1.hash- Code()==obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。 3、equals方法一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。 4、clone方法protected native实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。 5、toString方法一般子类都有覆盖 6、notify方法final native唤醒在该对象上等待的某个线程 7、notifyAll方法唤醒在该对象上等待的所有线程 8、wait方法final nativewait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。调用该方法后当前线程进入睡眠状态，直到以下事件发生。（1）其他线程调用了该对象的notify方法。（2）其他线程调用了该对象的notifyAll方法。（3）其他线程调用了interrupt中断该线程。（4）时间间隔到了。 9、finalize方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。]]></content>
      <categories>
        <category>java</category>
        <category>jdk源码分析</category>
        <category>Object类</category>
      </categories>
      <tags>
        <tag>jdk源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[token认证]]></title>
    <url>%2F2017%2F01%2F31%2Fweb%E5%BC%80%E5%8F%91%2Ftoken%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[1、需要token的原因token由应用管理，可以避开同源策略可以避免CSRF攻击token可以是无状态的，可以在多个服务之间共享 2、token时序图]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>web开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[91-最小调整代价]]></title>
    <url>%2F2017%2F01%2F30%2F%E7%AE%97%E6%B3%95%2Flintcode%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F91-%E6%9C%80%E5%B0%8F%E8%B0%83%E6%95%B4%E4%BB%A3%E4%BB%B7%2F</url>
    <content type="text"><![CDATA[题目给一个整数数组，调整每个数的大小，使得相邻的两个数的差不大于一个给定的整数target，调整每个数的代价为调整前后的差的绝对值，求调整代价之和最小是多少。样例对于数组[1, 4, 2, 3]和target=1，最小的调整方案是调整为[2, 3, 2, 3]，调整代价之和是2。返回2。 思路]]></content>
      <categories>
        <category>算法</category>
        <category>lintcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Selector]]></title>
    <url>%2F2017%2F01%2F29%2Fjava%2FNIO%2FSelector%2F</url>
    <content type="text"><![CDATA[1、为什么使用Selector选择器提供选择执行已经就绪的任务的能力，是的多元IO成为可能。就绪选择和多元执行能够有效率的同时管理多个IO通道（channel）。selector充当一个监视者，需要将之前创建的一个或者多个可选择的通道注册到选择器对象中。一个表示通道和选择器的键将会被返回。选择键会记住您关心的通道。它们也会追踪对应的通道是否已经就绪当您调用一个选择器对象的select()方法时,相关的键会被更新,用来检查所有被注册到该选择器的通道。可以获取一个键的集合,从而找到当时已经就绪的通道。通过遍历这些键,您可以选择出每个从上次您调用 select( )开始直到现在,已经就绪的通道。 只需要用一个线程来处理所有通道，因为线程上下文切换的开销很大，而且每个线程都要占用系统的一些资源。 相比于传统的socket监控传统解决方案就是为每个socket创建一个线程，并使得线程可以在read()调用中阻塞，知道数据可用。事实上将每个被阻塞的线程当做了socket监控器。并将java虚拟机的调度当做了通知机制。所以线程数量增长时，性能损耗和复杂性会尤为突出。 2、选择器属性 选择器(Selector)选择器类管理者一个被注册的通道的集合信息和他们的就绪状态。通道和选择器一起被注册，并且使用选择器来更新通道的就绪状态，当这么做的时候可以将被激发的线程挂起，直到有就绪的通道。 可选择通道(SelectableChannel)SelectableChannel可以被注册到Selector对象上，同时可以指定对哪个选择器而言，哪种操作是感兴趣的。一个通道可以被注册到多个选择器上，但对每个选择器而言只能被注册一次。 选择键(SelectionKey)选择键封装了特定的通道和特定的选择器的注册关系。选择键对象被SelectableChannel.register()返回并提供一个表示这种注册关系的标记，选择键包含了两个比特集(以整数的形式进行编码),指示了该注册关系所关心的通道操作,以及通道已经准备好的操作。 3、键对象键对象表示了一种特定的注册关系。当应该终结这种关系的时候，可以调用SelectionKey对象的cancel方法，可以通过isValid方法检查它是否仍然表示一种有效的关系。当键被取消时,它将被放在相关的选择器的已取消的键的集合里。注册不会立即被取消,但键会立即失效。当再次调用 select( )方法时(或者一个正在进行的 select()调用结束时),已取消的键的集合中的被取消的键将被清理掉,并且相应的注销也将完成。通道会被注销,而新的SelectionKey 将被返回。 SelectionKey 类定义了四个便于使用的布尔方法来为您测试这些比特值:isReadable( ),isWritable( ),isConnectable( ), 和 isAcceptable( )。每一个方法都与使用特定掩码来测试 readyOps( )方法的结果的效果相同。例如：if (key.isWritable( ))等价于:if ((key.readyOps( ) &amp; SelectionKey.OP_WRITE) != 0)这四个方法在任意一个 SelectionKey 对象上都能安全地调用。不能在一个通道上注册一个它不支持的操作,这种操作也永远不会出现在 ready 集合中。调用一个不支持的操作将总是返回 false,因为这种操作在该通道上永远不会准备好。 4、停止选择过程1、调用wakeup（）调用 Selector 对象的 wakeup( )方法将使得选择器上的第一个还没有返回的选择操作立即返回。如果当前没有在进行中的选择,那么下一次对 select( )方法的一种形式的调用将立即返回。后续的选择操作将正常进行。在选择操作之间多次调用 wakeup( )方法与调用它一次没有什么不同。有时这种延迟的唤醒行为并不是您想要的。您可能只想唤醒一个睡眠中的线程,而使得后续的选择继续正常地进行。您可以通过在调用 wakeup( )方法后调用 selectNow( )方法来绕过这个问题。尽管如此,如果您将您的代码构造为合理地关注于返回值和执行选择集合,那么即使下一个 select( )方法的调用在没有通道就绪时就立即返回,也应该不会有什么不同。不管怎么说,您应该为可能发生的事件做好准备。2、调用 close( )如果选择器的 close( )方法被调用,那么任何一个在选择操作中阻塞的线程都将被唤醒,就像wakeup( )方法被调用了一样。与选择器相关的通道将被注销,而键将被取消。3、调用 interrupt( )如果睡眠中的线程的 interrupt( )方法被调用,它的返回状态将被设置。如果被唤醒的线程之后将试图在通道上执行 I/O 操作,通道将立即关闭,然后线程将捕捉到一个异常。这是由于在第三章中已经探讨过的通道的中断语义。使用 wakeup( )方法将会优雅地将一个在 select( )方法中睡眠的线程唤醒。如果您想让一个睡眠的线程在直接中断之后继续执行,需要执行一些步骤来清理中断状态 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122public class SelectSockets &#123; public static int PORT_NUMBER = 1234; public static void main(String[] argv) throws Exception &#123; new SelectSockets().go(argv); &#125; public void go(String[] argv) throws Exception &#123; int port = PORT_NUMBER; if (argv.length &gt; 0) &#123; // 覆盖默认的监听端口 port = Integer.parseInt(argv[0]); &#125; System.out.println("Listening on port " + port); ServerSocketChannel serverChannel = ServerSocketChannel.open();// 打开一个未绑定的serversocketchannel ServerSocket serverSocket = serverChannel.socket();// 得到一个ServerSocket去和它绑定 Selector selector = Selector.open();// 创建一个Selector供下面使用 serverSocket.bind(new InetSocketAddress(port));//设置server channel将会监听的端口 serverChannel.configureBlocking(false);//设置非阻塞模式 serverChannel.register(selector, SelectionKey.OP_ACCEPT);//将ServerSocketChannel注册到Selector while (true) &#123; // This may block for a long time. Upon returning, the // selected set contains keys of the ready channels. int n = selector.select(); if (n == 0) &#123; continue; // nothing to do &#125; java.util.Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();// Get an iterator over the set of selected keys //在被选择的set中遍历全部的key while (it.hasNext()) &#123; SelectionKey key = (SelectionKey) it.next(); // 判断是否是一个连接到来 if (key.isAcceptable()) &#123; ServerSocketChannel server = (ServerSocketChannel) key.channel(); SocketChannel channel = server.accept(); registerChannel(selector, channel, SelectionKey.OP_READ);//注册读事件 sayHello(channel);//对连接进行处理 &#125; //判断这个channel上是否有数据要读 if (key.isReadable()) &#123; readDataFromSocket(key); &#125; //从selected set中移除这个key，因为它已经被处理过了 it.remove(); &#125; &#125; &#125; // ---------------------------------------------------------- /** * Register the given channel with the given selector for the given * operations of interest */ protected void registerChannel(Selector selector, SelectableChannel channel, int ops) throws Exception &#123; if (channel == null) &#123; return; // 可能会发生 &#125; // 设置通道为非阻塞 channel.configureBlocking(false); // 将通道注册到选择器上 channel.register(selector, ops); &#125; // ---------------------------------------------------------- // Use the same byte buffer for all channels. A single thread is // servicing all the channels, so no danger of concurrent acccess. //对所有的通道使用相同的缓冲区。单线程为所有的通道进行服务，所以并发访问没有风险 private ByteBuffer buffer = ByteBuffer.allocateDirect(1024); /** * Sample data handler method for a channel with data ready to read. * 对于一个准备读入数据的通道的简单的数据处理方法 * * @param key A SelectionKey object associated with a channel determined by * the selector to be ready for reading. If the channel returns * an EOF condition, it is closed here, which automatically * invalidates the associated key. The selector will then * de-register the channel on the next select call. * &lt;p&gt; * 一个选择器决定了和通道关联的SelectionKey object是准备读状态。如果通道返回EOF，通道将被关闭。 * 并且会自动使相关的key失效，选择器然后会在下一次的select call时取消掉通道的注册 */ protected void readDataFromSocket(SelectionKey key) throws Exception &#123; SocketChannel socketChannel = (SocketChannel) key.channel(); int count; buffer.clear(); // 清空Buffer // Loop while data is available; channel is nonblocking //当可以读到数据时一直循环，通道为非阻塞 while ((count = socketChannel.read(buffer)) &gt; 0) &#123; buffer.flip(); // 将缓冲区置为可读 // Send the data; don't assume it goes all at once //发送数据，不要期望能一次将数据发送完 while (buffer.hasRemaining()) &#123; socketChannel.write(buffer); &#125; // WARNING: the above loop is evil. Because // it's writing back to the same nonblocking // channel it read the data from, this code can // potentially spin in a busy loop. In real life // you'd do something more useful than this. //这里的循环是无意义的，具体按实际情况而定 buffer.clear(); // Empty buffer &#125; if (count &lt; 0) &#123; // Close channel on EOF, invalidates the key //读取结束后关闭通道，使key失效 socketChannel.close(); &#125; &#125; // ---------------------------------------------------------- /** * Spew a greeting to the incoming client connection. * * @param channel The newly connected SocketChannel to say hello to. */ private void sayHello(SocketChannel channel) throws Exception &#123; buffer.clear(); buffer.put("Hi there!\r\n".getBytes()); buffer.flip(); channel.write(buffer); &#125;&#125; 5、并发性选择器对象是线程安全的，但它们包含的键集合不是。通过keys()和selectKeys()返回的键的集合是Selector对象内部的私有的Set对象集合的直接引用。已注册的键的集合是只读的。修改会有UnSupportedOperationException如果一个线程修改了选择键，可能会破坏另一个线程的Iterator。报ConcurrentModificationException。解决：在执行选择操作时，选择器在Selector对象上进行同步。然后是已注册的键的集合,最后是已选择的键的集合,按照这样的顺序。已取消的键的集合也在选择过程的的第 1步和第 3 步之间保持同步(当与已取消的键的集合相关的通道被注销时)。 在多线程的场景中,如果您需要对任何一个键的集合进行更改,不管是直接更改还是其他操作带来的副作用,您都需要首先以相同的顺序,在同一对象上进行同步。锁的过程是非常重要的。如果竞争的线程没有以相同的顺序请求锁,就将会有死锁的潜在隐患。如果您可以确保否其他线程不会同时访问选择器,那么就不必要进行同步了。 Selector 类的 close()方法与 slect()方法的同步方式是一样的,因此也有一直阻塞的可能性。在选择过程还在进行的过程中,所有对close()的调用都会被阻塞,直到选择过程结束,或者执行选择的线程进入睡眠。在后面的情况下,执行选择的线程将会在执行关闭的线程获得锁时立即被唤醒,并关闭选择器。]]></content>
      <categories>
        <category>java</category>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring的IOC容器]]></title>
    <url>%2F2017%2F01%2F28%2Fjava%E6%A1%86%E6%9E%B6%2Fspring%2Fspring%E7%9A%84IOC%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、IOC容器启动1、读取xml配置文件，解析各种bean的定义，分别转换成BeanDefinition。其中保存bean的各种信息 如beanClass保存bean的class属性，scop保存bean是否单例， abstractFlag保存该bean是否抽象，lazyInit保存是否延迟初始化，autowireMode保存是否自动装配。。。2、通过BeanDefinitionRegistry将这些Bean注册到BeanFactory。 BeanFactory的实现类DefaultListableBeanFactory实现了BeanDefinitionRegistry 接口 BeanDefinition注册到DefaultListableBeanFactory，保存在一个ConcurrentHashMap中。 这里spring提供了一个扩展的切口，允许我们通过实现BeanFactoryPostProcessor插入自定义的代码 比如spring的实现PropertyPlaceholderConfigurer，可以在xml中配置占位符，将${username}替换成实际值接下去注册BeanPostProcessor和spring的listener 二、bean的初始化1234567891011121314151617181920212223242526272829301、我都ioc容器。nameSpaceHandle AbstractBeanFactory 初始化XmlBeanDefintionReader BeanDefinitionDelegate解析Resource。加载配置文件得bean到内存BeanDefinition集合中。初始化DefaultListableBeanFactory对象。接下去注册BeanPostProcessor和spring的listener2、接着就是初始化。先是为每个bean创建ObjectFactory。用来创建bean实例的工厂类。接着判断依赖。singleton 初始化后就在bean的一个内存map中。加载类的时候用一个earlyExposeObject具体叫啥忘了反正一个标志变量用来说明spring正在加载类。循环依赖的时候会判断这个值然后初始化这个实例。防止抛异常。protot**e就是存objectFactory。每次引用都初始化。3、接着就是objectFactory中的createBean方法。在SingletonBeanFactory类中。有策略模式用来创建bean实例。然后就是调用beanPostProcessor的接口或者这个接口的子类。每个return的值都是这个bean的值，所以aop的入口也是这个，而且这个BeanPostProcessor的类有顺序的。spring在初始化时有排序可以实现ordered接口。这个点很隐藏，4、ioc容器创建成功。关键是DefaultListableBeanFactory AbstractBeanFactory AutowireCapableBeanFactory SingletonBeanFactory。这几个beanFactory每个子类都做些自己的事。5、然后就分析设计模式，工厂模式，单例模式，装饰者模式，还有模板方法模式，动态代理模式，还有适配器模式。6、接着是aop实现，带着他从源码走起，首先看aop的jar包。spring bundle的nameSpaceHandler解析类。发现自定义的bean标签的解析入口。点进去发现aop标签AspectJAwareAdvisorAuto 首先看的是aop的jar包。发现spring bundle看到nameSpaceHandler解析类。发现自定义的bean标签的解析入口在这里。点进去发现加载aop标签时会初始化一个7、AspectJAwareAdvisorAutoProxyCreator的类。挖他的父类。发现就是实现了一个BeanPostProcessor的子类。Smart啥的Processor忘了。在afterPostInitialize这个方法里，Proxy去处理了bean。所以每个bean的加载。这个Creator得排序是最靠后的所以每个bean都能处理到。也就是我刚刚说的排序问题。8、然后就是加载配置中的Advisor PointCut。PointCut用来设置具体包类方法的位置。Advisor用来处理切点和切面主体的逻辑，after before beforeThrown啥的，然后通过jdk或者cglib对bean的class代理实例化一个新的类。然后用一个targetSource的类。里面记录原来bean的信息。然后把原来bean和它的信息设置到targetSource9、这个targetSource就等于装饰者模式。表面上其实已经是个新bean了。但是逻辑都在targetSource。套了一层用来处理逻辑。10、接着就是事务11、控制反转。我的理解就是模板方法的特性。父类控制子类。ioc容器就是用配置的方法组装bean。通过一个容器或者说是集合取出需要的bean。aop就是动态代理咯。很多逻辑或者很多一样的逻辑。写在代码里很繁琐就需要面向切面咯。或者讲一下jdk。对接口代理。12、ProxyGenerator的类中具体实现。有个属性可以通过system.Property设置。让他把class编译出来。cglib就是asm库了。通过ClassWriter ClassVisitor FieldVisitor MethodVisitor这些个核心类对字节码进行代码编写然后用类加载器加载出来并实例化，当然操作类就是个Enhancer增强。具体在DebuggingClassWriter中。也有个输出参13、这个是面向接口和普通类都可以代理的。当然不能是final修饰的。参数设置输出后会编译出输出的类。可以看到他是继承你要的类实现一个CallBack或者是Factory啥的。反正是MethodInterceptor的父类。]]></content>
      <categories>
        <category>java框架</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BIO和NIO]]></title>
    <url>%2F2017%2F01%2F27%2Fjava%2FNIO%2FBIO%E5%92%8CNIO%2F</url>
    <content type="text"><![CDATA[一、IO和File1、File类 File类是IO包中唯一d代表磁盘文件本身的对象 2、RandomAccessFile RandomAccessFile类支持”随机访问”方式，可以跳转到文件的任意位置处读写数据。要访问一个文件的时候，不想把文件从头读到尾，而是希望像访问一个数据库一样地访问一个文本文件，使用RandomAccessFile类是最佳选择。 3、字节流 操作字节流步骤 1、使用File类找到一个对象2、通过File类的对象去实例化字节流或字符流的子类3、进行字节（字符）的读、写操作4、关闭文件流 4、字符流 字符流本身就是一种特殊的字节流，之所以要专门有字符流，是因为Java中有大量对于字符的操作，所以专门有字符流。字节流和字符流的转换是以InputStreamReader和OutputStreamWriter为媒介的，InputStreamReader可以将一个字节流中的字节解码成字符，OutputStreamWriter可以将写入的字符编码成自节后写入一个字节流。 字符流和字节流最大的区别在于，字节流在操作时本身不会用到缓冲区（内存），是文件本身直接操作的，而字符流操作时使用了缓冲区，通过缓冲区再操作文件。 在关闭字符流时会强制性地将缓冲区中的内容进行输出，但是如果没有关闭，缓冲区中的内容是无法输出的。 二、NIO1、缓冲区详见[Java NIO-缓冲区][1] 2、通道 channel用于在字节缓冲区和位于通道另一侧的实体之间有效的传输数据 通常情况下，通道与操作系统的文件描述符（FileDescriptor）和文件句柄（FileHandler）有着一对一的关系。Channel类提供维持平台独立性所需的抽象过程，不然仍然会模拟现代操作系统本身的I/O性能。通道是一种途径，借助该途径，可以用最小的总开销来访问操作系统本身的I/O服务。缓冲区则是通道内部用来发送和接收数据的端点， 通道可以是单向的也可以是双向的。一个Channel类可能实现定义read()方法的ReadableByteChannel接口，而另一个Channel类也许实现WritableByteChannel接口以提供write()方法。实现这两种接口其中之一的类都是单向的，只能在一个方向上传输数据。如果一个类同时实现这两个接口，那么它是双向的，可以双向传输数据，就像上面的ByteChannel。 通道可以以阻塞（blocking）或非阻塞（nonblocking）模式运行，非阻塞模式的通道永远不会让调用的线程休眠，请求的操作要么立即完成，要么返回一个结果表明未进行任何操作。只有面向流的（stream-oriented）的通道，如sockets和pipes才能使用非阻塞模式。比方说非阻塞的通道SocketChannel 通道是访问I/O服务的导管，I/O可以分为广义的两大类：File I/O和Stream I/O。那么相应的，通道也有两种类型，它们是文件（File）通道和套接字（Socket）通道。 a、文件通道一个FileChannel对象却只能通过在一个打开的RandomAccessFile、FileInputStream或FileOutputStream对象上调用getChannel()方法来获取，开发者不能直接创建一个FileChannel 文件通道总是阻塞式的，因此不能被置于非阻塞模式下。 FileChannel对象是线程安全的，多个进程可以在同一个实例上并发调用方法而不会引起任何问题，不过并非所有的操作都是多线程的。影响通道位置或者影响文件的操作都是单线程的，如果有一个线程已经在执行会影响通道位置或文件大小的操作，那么其他尝试进行此类操作之一的线程必须等待，并发行为也会受到底层操作系统或文件系统的影响。 b、Socket通道 1、NIO的Socket通道类可以运行于非阻塞模式并且是可选择的，这两个性能可以激活大程序（如网络服务器和中间件组件）巨大的可伸缩性和灵活性，因此，再也没有为每个Socket连接使用一个线程的必要了。这一特性避免了管理大量线程所需的上下文交换总开销，借助NIO类，一个或几个线程就可以管理成百上千的活动Socket连接了并且只有很少甚至没有性能损失 2、全部Socket通道类（DatagramChannel、SocketChannel和ServerSocketChannel）在被实例化时都会创建一个对应的Socket对象，就是我们所熟悉的来自java.net的类（Socket、ServerSocket和DatagramSocket），这些Socket可以通过调用socket()方法从通道类获取，此外，这三个java.net类现在都有getChannel()方法 3、每个Socket通道（在java.nio.channels包中）都有一个关联的java.net.socket对象，反之却不是如此，如果使用传统方式（直接实例化）创建了一个Socket对象，它就不会有关联的SocketChannel并且它的getChannel()方法将总是返回null]]></content>
      <categories>
        <category>java</category>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Channel和Buffer]]></title>
    <url>%2F2017%2F01%2F27%2Fjava%2FNIO%2FChannel%E5%92%8CBuffer%2F</url>
    <content type="text"><![CDATA[1、Channel概述1、java NIO的通道类似于流，可以从通道中读取数据，和写入数据到通道。流的读写是单向的2、通道可以异步的读写3、通道的数据总是先读到一个Buffer，或者从一个Buffer中写入4、Channel主要有四种实现，FileChannel从文件中读写数据DatagramChannel能通过UDP读写网络中的数据SocketChannel能通过TCP读写网络中的数据ServerSocketChannel可以监听新进来的TCP连接 2、BufferBuffer对象是固定数量的数据的容器。作用是一个存储器或者分段运输区。通道是IO传输发生时的入口，而缓冲区是数据的来源或目标。 byteBuffer可以看做一个内部含有byte数组的一个对象，其中含有4个属性容量（Capacity）：缓冲区能够容纳的数据元素的最大数量。这一个容量在缓冲区创建时被设定，并且永远不能改变。上界(Limit)：缓冲区的第一个不能被读或写的元素。或者说,缓冲区中现存元素的计数。位置(Position)：下一个要被读或写的元素的索引。位置会自动由相应的 get()和 put()函数更新。标记(Mark)：下一个要被读或写的元素的索引。位置会自动由相应的 get()和 put()函数更新。 常见方法如下所示:flip(): 写模式转换成读模式rewind()：将 position 重置为 0 ，一般用于重复读。clear() ：清空 buffer ，准备再次被写入 (position 变成 0 ， limit 变成 capacity) 。compact(): 将未读取的数据拷贝到 buffer 的头部位。mark(): reset():mark 可以标记一个位置， reset 可以重置到该位置。Buffer 常见类型：ByteBuffer、MappedByteBuffer、CharBuffer、DoubleBuffer、FloatBuffer、IntBuffer、LongBuffer、ShortBuffer 。]]></content>
      <categories>
        <category>java</category>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[excel操作]]></title>
    <url>%2F2017%2F01%2F26%2F%E5%B7%A5%E5%85%B7%2Fexcel%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1、求多个积的和公式SUMPRODUCT(E2:E7,F2:F7)]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reactor线程模型]]></title>
    <url>%2F2017%2F01%2F26%2Fjava%E6%A1%86%E6%9E%B6%2Fnetty%2Freactor%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1、reactor的第三种模型 将Reactor分成两部分，mainReactor负责监听server socket，accept新连接，并将建立的socket分派给subReactor，subReactor负责多路分离已建立的socket，读写网络数据，而对业务的处理则给worker线程池去处理。通常，subReactor个数和cpu个数相同 2、Netty所使用的线程模型 类似上述（去掉线程池），Netty的Boss类充当mainReactor，NioWorker类充当subReactor。 在处理新来的请求时，NioWorker读取已收到的数据到ChannelBuffer中，之后触发ChannelPipeline中的ChannelHandler流，处理业务流程]]></content>
      <categories>
        <category>java框架</category>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些技巧]]></title>
    <url>%2F2017%2F01%2F12%2Fpython%2F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1、分享目录终端路径切换到某文件夹下，python -m SimpleHTTPServer 8000 然后浏览器打开 localhost:8000，可以开启一个简易的web服务器]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些技巧]]></title>
    <url>%2F2017%2F01%2F12%2Fpython%2F%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[1 拆箱代码如下: a, b, c = 1, 2, 3a, b, c(1, 2, 3)a, b, c = [1, 2, 3]a, b, c(1, 2, 3)a, b, c = (2 * i + 1 for i in range(3))a, b, c(1, 3, 5)a, (b, c), d = [1, (2, 3), 4]a1b2c3d42 拆箱变量交换 代码如下 a, b = 1, 2a, b = b, aa, b(2, 1)3 扩展拆箱（只兼容python3） 代码如下: a, *b, c = [1, 2, 3, 4, 5]a1b[2, 3, 4]c54 负数索引 代码如下: a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]a[-1]10a[-3]85 切割列表 代码如下: a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]a[2:8][2, 3, 4, 5, 6, 7]6 负数索引切割列表 代码如下: a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]a[-4:-2][7, 8]7指定步长切割列表 代码如下: a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]a[::2][0, 2, 4, 6, 8, 10]a[::3][0, 3, 6, 9]a[2:8:2][2, 4, 6]8 负数步长切割列表 代码如下: a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]a[::-1][10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]a[::-2][10, 8, 6, 4, 2, 0]9 列表切割赋值 代码如下: a = [1, 2, 3, 4, 5]a[2:3] = [0, 0]a[1, 2, 0, 0, 4, 5]a[1:1] = [8, 9]a[1, 8, 9, 2, 0, 0, 4, 5]a[1:-1] = []a[1, 5]10 命名列表切割方式 代码如下: a = [0, 1, 2, 3, 4, 5]LASTTHREE = slice(-3, None)LASTTHREEslice(-3, None, None)a[LASTTHREE][3, 4, 5]11 列表以及迭代器的压缩和解压缩 代码如下: a = [1, 2, 3]b = [‘a’, ‘b’, ‘c’]z = zip(a, b)z[(1, ‘a’), (2, ‘b’), (3, ‘c’)]zip(*z)[(1, 2, 3), (‘a’, ‘b’, ‘c’)]12 列表相邻元素压缩器 代码如下: a = [1, 2, 3, 4, 5, 6]zip(([iter(a)] 2))[(1, 2), (3, 4), (5, 6)] group_adjacent = lambda a, k: zip(([iter(a)] k))group_adjacent(a, 3)[(1, 2, 3), (4, 5, 6)]group_adjacent(a, 2)[(1, 2), (3, 4), (5, 6)]group_adjacent(a, 1)[(1,), (2,), (3,), (4,), (5,), (6,)] zip(a[::2], a[1::2])[(1, 2), (3, 4), (5, 6)] zip(a[::3], a[1::3], a[2::3])[(1, 2, 3), (4, 5, 6)] group_adjacent = lambda a, k: zip(*(a[i::k] for i in range(k)))group_adjacent(a, 3)[(1, 2, 3), (4, 5, 6)]group_adjacent(a, 2)[(1, 2), (3, 4), (5, 6)]group_adjacent(a, 1)[(1,), (2,), (3,), (4,), (5,), (6,)]13 在列表中用压缩器和迭代器滑动取值窗口 代码如下: def n_grams(a, n):… z = [iter(a[i:]) for i in range(n)]… return zip(*z)…a = [1, 2, 3, 4, 5, 6]n_grams(a, 3)[(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6)]n_grams(a, 2)[(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]n_grams(a, 4)[(1, 2, 3, 4), (2, 3, 4, 5), (3, 4, 5, 6)]14 用压缩器反转字典 代码如下: m = {‘a’: 1, ‘b’: 2, ‘c’: 3, ‘d’: 4}m.items()[(‘a’, 1), (‘c’, 3), (‘b’, 2), (‘d’, 4)]zip(m.values(), m.keys())[(1, ‘a’), (3, ‘c’), (2, ‘b’), (4, ‘d’)]mi = dict(zip(m.values(), m.keys()))mi{1: ‘a’, 2: ‘b’, 3: ‘c’, 4: ‘d’}15 列表展开 代码如下: a = [[1, 2], [3, 4], [5, 6]]list(itertools.chain.from_iterable(a))[1, 2, 3, 4, 5, 6] sum(a, [])[1, 2, 3, 4, 5, 6] [x for l in a for x in l][1, 2, 3, 4, 5, 6] a = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]][x for l1 in a for l2 in l1 for x in l2][1, 2, 3, 4, 5, 6, 7, 8] a = [1, 2, [3, 4], [[5, 6], [7, 8]]]flatten = lambda x: [y for l in x for y in flatten(l)] if type(x) is list else [x]flatten(a)[1, 2, 3, 4, 5, 6, 7, 8]16 生成器表达式 代码如下: g = (x 2 for x in xrange(10))next(g)0next(g)1next(g)4next(g)9sum(x 3 for x in xrange(10))2025sum(x ** 3 for x in xrange(10) if x % 3 == 1)40817 字典推导 代码如下: m = {x: x ** 2 for x in range(5)}m{0: 0, 1: 1, 2: 4, 3: 9, 4: 16} m = {x: ‘A’ + str(x) for x in range(10)}m{0: ‘A0’, 1: ‘A1’, 2: ‘A2’, 3: ‘A3’, 4: ‘A4’, 5: ‘A5’, 6: ‘A6’, 7: ‘A7’, 8: ‘A8’, 9: ‘A9’}18 用字典推导反转字典 代码如下: m = {‘a’: 1, ‘b’: 2, ‘c’: 3, ‘d’: 4}m{‘d’: 4, ‘a’: 1, ‘b’: 2, ‘c’: 3}{v: k for k, v in m.items()}{1: ‘a’, 2: ‘b’, 3: ‘c’, 4: ‘d’}19 命名元组 代码如下: Point = collections.namedtuple(‘Point’, [‘x’, ‘y’])p = Point(x=1.0, y=2.0)pPoint(x=1.0, y=2.0)p.x1.0p.y2.020 继承命名元组 代码如下: class Point(collections.namedtuple(‘PointBase’, [‘x’, ‘y’])):… slots = ()… def add(self, other):… return Point(x=self.x + other.x, y=self.y + other.y)…p = Point(x=1.0, y=2.0)q = Point(x=2.0, y=3.0)p + qPoint(x=3.0, y=5.0)21 操作集合 代码如下: A = {1, 2, 3, 3}Aset([1, 2, 3])B = {3, 4, 5, 6, 7}Bset([3, 4, 5, 6, 7])A | Bset([1, 2, 3, 4, 5, 6, 7])A &amp; Bset([3])A - Bset([1, 2])B - Aset([4, 5, 6, 7])A ^ Bset([1, 2, 4, 5, 6, 7])(A ^ B) == ((A - B) | (B - A))True22 操作多重集合 代码如下: A = collections.Counter([1, 2, 2])B = collections.Counter([2, 2, 3])ACounter({2: 2, 1: 1})BCounter({2: 2, 3: 1})A | BCounter({2: 2, 1: 1, 3: 1})A &amp; BCounter({2: 2})A + BCounter({2: 4, 1: 1, 3: 1})A - BCounter({1: 1})B - ACounter({3: 1})23 统计在可迭代器中最常出现的元素 代码如下: A = collections.Counter([1, 1, 2, 2, 3, 3, 3, 3, 4, 5, 6, 7])ACounter({3: 4, 1: 2, 2: 2, 4: 1, 5: 1, 6: 1, 7: 1})A.most_common(1)[(3, 4)]A.most_common(3)[(3, 4), (1, 2), (2, 2)]24 两端都可操作的队列 代码如下: Q = collections.deque()Q.append(1)Q.appendleft(2)Q.extend([3, 4])Q.extendleft([5, 6])Qdeque([6, 5, 2, 1, 3, 4])Q.pop()4Q.popleft()6Qdeque([5, 2, 1, 3])Q.rotate(3)Qdeque([2, 1, 3, 5])Q.rotate(-3)Qdeque([5, 2, 1, 3])25 有最大长度的双端队列 代码如下: last_three = collections.deque(maxlen=3)for i in xrange(10):… last_three.append(i)… print ‘, ‘.join(str(x) for x in last_three)…00, 10, 1, 21, 2, 32, 3, 43, 4, 54, 5, 65, 6, 76, 7, 87, 8, 926 可排序词典 代码如下: m = dict((str(x), x) for x in range(10))print ‘, ‘.join(m.keys())1, 0, 3, 2, 5, 4, 7, 6, 9, 8m = collections.OrderedDict((str(x), x) for x in range(10))print ‘, ‘.join(m.keys())0, 1, 2, 3, 4, 5, 6, 7, 8, 9m = collections.OrderedDict((str(x), x) for x in range(10, 0, -1))print ‘, ‘.join(m.keys())10, 9, 8, 7, 6, 5, 4, 3, 2, 127 默认词典 代码如下: m = dict()m[‘a’]Traceback (most recent call last): File ““, line 1, in KeyError: ‘a’ m = collections.defaultdict(int)m[‘a’]0m[‘b’]0m = collections.defaultdict(str)m[‘a’]‘’m[‘b’] += ‘a’m[‘b’]‘a’m = collections.defaultdict(lambda: ‘[default value]’)m[‘a’]‘[default value]’m[‘b’]‘[default value]’28 默认字典的简单树状表达 代码如下: import jsontree = lambda: collections.defaultdict(tree)root = tree()root[‘menu’][‘id’] = ‘file’root[‘menu’][‘value’] = ‘File’root[‘menu’][‘menuitems’][‘new’][‘value’] = ‘New’root[‘menu’][‘menuitems’][‘new’][‘onclick’] = ‘new();’root[‘menu’][‘menuitems’][‘open’][‘value’] = ‘Open’root[‘menu’][‘menuitems’][‘open’][‘onclick’] = ‘open();’root[‘menu’][‘menuitems’][‘close’][‘value’] = ‘Close’root[‘menu’][‘menuitems’][‘close’][‘onclick’] = ‘close();’print json.dumps(root, sort_keys=True, indent=4, separators=(‘,’, ‘: ‘)){ “menu”: { “id”: “file”, “menuitems”: { “close”: { “onclick”: “close();”, “value”: “Close” }, “new”: { “onclick”: “new();”, “value”: “New” }, “open”: { “onclick”: “open();”, “value”: “Open” } }, “value”: “File” }}29 对象到唯一计数的映射 代码如下: import itertools, collectionsvalue_to_numeric_map = collections.defaultdict(itertools.count().next)value_to_numeric_map[‘a’]0value_to_numeric_map[‘b’]1value_to_numeric_map[‘c’]2value_to_numeric_map[‘a’]0value_to_numeric_map[‘b’]130 最大和最小的几个列表元素 代码如下: a = [random.randint(0, 100) for __ in xrange(100)]heapq.nsmallest(5, a)[3, 3, 5, 6, 8]heapq.nlargest(5, a)[100, 100, 99, 98, 98]31 两个列表的笛卡尔积 代码如下: for p in itertools.product([1, 2, 3], [4, 5]):(1, 4)(1, 5)(2, 4)(2, 5)(3, 4)(3, 5)for p in itertools.product([0, 1], repeat=4):… print ‘’.join(str(x) for x in p)…000000010010001101000101011001111000100110101011110011011110111132 列表组合和列表元素替代组合 代码如下: for c in itertools.combinations([1, 2, 3, 4, 5], 3):… print ‘’.join(str(x) for x in c)…123124125134135145234235245345for c in itertools.combinations_with_replacement([1, 2, 3], 2):… print ‘’.join(str(x) for x in c)…11121322233333 列表元素排列组合 代码如下: for p in itertools.permutations([1, 2, 3, 4]):… print ‘’.join(str(x) for x in p)…12341243132413421423143221342143231423412413243131243142321432413412342141234132421342314312432134 可链接迭代器 代码如下: a = [1, 2, 3, 4]for p in itertools.chain(itertools.combinations(a, 2), itertools.combinations(a, 3)):… print p…(1, 2)(1, 3)(1, 4)(2, 3)(2, 4)(3, 4)(1, 2, 3)(1, 2, 4)(1, 3, 4)(2, 3, 4)for subset in itertools.chain.from_iterable(itertools.combinations(a, n) for n in range(len(a) + 1))… print subset…()(1,)(2,)(3,)(4,)(1, 2)(1, 3)(1, 4)(2, 3)(2, 4)(3, 4)(1, 2, 3)(1, 2, 4)(1, 3, 4)(2, 3, 4)(1, 2, 3, 4)35 根据文件指定列类聚 代码如下: import itertoolswith open(‘contactlenses.csv’, ‘r’) as infile:… data = [line.strip().split(‘,’) for line in infile]…data = data[1:]def print_data(rows):… print ‘n’.join(‘t’.join(‘{: &lt;16}’.format(s) for s in row) for row in rows)… print_data(data)young myope no reduced noneyoung myope no normal softyoung myope yes reduced noneyoung myope yes normal hardyoung hypermetrope no reduced noneyoung hypermetrope no normal softyoung hypermetrope yes reduced noneyoung hypermetrope yes normal hardpre-presbyopic myope no reduced nonepre-presbyopic myope no normal softpre-presbyopic myope yes reduced nonepre-presbyopic myope yes normal hardpre-presbyopic hypermetrope no reduced nonepre-presbyopic hypermetrope no normal softpre-presbyopic hypermetrope yes reduced nonepre-presbyopic hypermetrope yes normal nonepresbyopic myope no reduced nonepresbyopic myope no normal nonepresbyopic myope yes reduced nonepresbyopic myope yes normal hardpresbyopic hypermetrope no reduced nonepresbyopic hypermetrope no normal softpresbyopic hypermetrope yes reduced nonepresbyopic hypermetrope yes normal none data.sort(key=lambda r: r[-1])for value, group in itertools.groupby(data, lambda r: r[-1]):… print ‘———–’… print ‘Group: ‘ + value… print_data(group) …Group: hardyoung myope yes normal hardyoung hypermetrope yes normal hardpre-presbyopic myope yes normal hard presbyopic myope yes normal hardGroup: noneyoung myope no reduced noneyoung myope yes reduced noneyoung hypermetrope no reduced noneyoung hypermetrope yes reduced nonepre-presbyopic myope no reduced nonepre-presbyopic myope yes reduced nonepre-presbyopic hypermetrope no reduced nonepre-presbyopic hypermetrope yes reduced nonepre-presbyopic hypermetrope yes normal nonepresbyopic myope no reduced nonepresbyopic myope no normal nonepresbyopic myope yes reduced nonepresbyopic hypermetrope no reduced nonepresbyopic hypermetrope yes reduced none presbyopic hypermetrope yes normal noneGroup: softyoung myope no normal softyoung hypermetrope no normal softpre-presbyopic myope no normal softpre-presbyopic hypermetrope no normal softpresbyopic hypermetrope no normal]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2017%2F01%2F12%2Fpython%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1、re.match查找只有当被搜索字符串的开头匹配模式的时候它才能查找到匹配对象。 re.match(r’dog’, ‘dog cat dog’) &lt;_sre.SRE_Match object at 0xb743e720&lt;match = re.match(r’dog’, ‘dog cat dog’)match.group(0)‘dog’①使用 match.start 和 match.end 方法 说明：匹配的内容在原始字符串中的开始和结束位置match = re.search(r’dog’, ‘dog cat dog’)match.start()0match.end()3②mathch.group 通过数字分组contactInfo = ‘Doe, John: 555-1212’match = re.search(r’(\w+), (\w+): (\S+)’, contactInfo)match.group(1)‘Doe’match.group(2)‘John’match.group(3)‘555-1212’match.group(0)‘Doe, John: 555-1212’第0个组被预留来存放所有匹配对象③match.group 通过别名来分组match = re.search(r’(?P\w+), (?P\w+): (?P\S+)’, contactInfo)match.group(‘last’)‘Doe’match.group(‘first’)‘John’match.group(‘phone’)‘555-1212’④findall()方法将返回一个元组的集合，其中每个元组中的第N个元素对应了正则表达式中的第N个分组。re.findall(r’(\w+), (\w+): (\S+)’, contactInfo)[(‘Doe’, ‘John’, ‘555-1212’)] 2、re.search查找和match()类似，不过search()方法不会限制我们只从字符串的开头查找匹配search(r’cat’, ‘dog cat dog’) match.group(0)‘cat’ 3、re.findall – 所有匹配对象得到一个所有匹配模式的列表，而不是得到match的对象[‘dog’, ‘dog’] re.findall(r’cat’, ‘dog cat dog’)[‘cat’]]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8新特性]]></title>
    <url>%2F2017%2F01%2F12%2Fjava%2Fjava8%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kafka常用命令]]></title>
    <url>%2F2016%2F12%2F31%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2Fkafka%2Fkafka%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一、安装启动1、启动命令kafka-server-start.sh /usr/local/cloud/kafka/config/server.properties &amp; 停止命令 2、创建topickafka-topics.sh –create –zookeeper master1ha:2181,master2:2181,master2ha:2181/kafka –replication-factor 3 –partitions 5 –topic my-replicated-topic5 3、查看当前服务器中的所有topickafka-topics.sh –describe –zookeeper master1ha:2181,master2:2181,master2ha:2181/kafka –topic my-replicated-topic5 4、终端发布，消费信息生产消息kafka-console-producer.sh –broker-list master1ha:9092,master2:9092,master2ha:9092 –topic my-replicated-topic5消费消息kafka-console-consumer.sh –zookeeper master1ha:2181,master2:2181,master2ha:2181/kafka –from-beginning –topic my-replicated-topic5 二、维护常用命令1、查看所有topic./kafka-topics.sh -zookeeper cloud002:2181 –list 2、创建topickafka-topics.sh –create –zookeeper node05:2181 –replication-factor 1 –partitions 3 –topic first 3、查看topic详细信息kafka-topics.sh –zookeeper node05:2181 –topic “test” –describe./kafka-topics.sh –zookeeper cloud001:2181 –topic “order_real” –describe 4、查看kafka中的消息内容kafka-console-consumer.sh –zookeeper node05:2181 –topic test –from-beginnin./kafka-console-consumer.sh –zookeeper 10.24.248.189:2181,10.24.248.186:2181,10.24.248.187:2181 –topic order_real –from-beginnin ./kafka-console-consumer.sh -zookeeper cloud001:2181 –topic funpayDev –from-beginnin 5、生产消息./kafka-console-producer.sh –broker-list localhost:59091 –topic orderlog]]></content>
      <categories>
        <category>大数据</category>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spark shell比较两个文件]]></title>
    <url>%2F2016%2F10%2F19%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2Fspark%2Fspark%20shell%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[val orderIdData = sc.textFile(“hdfs:///test/vhjy/orderall.csv”)val orderIds = orderIdData.map(.split(‘,’)(0)) val anhuiOrderData = sc.textFile(“hdfs:///test/vhjy/orderanhui.txt”)val anhuiOrderIds = anhuiOrderData.map(.split(‘,’)(0)) 取差集val addOrderIds = orderIds.subtract(anhuiOrderIds)addOrderIds.repartition(1).saveAsTextFile(“hdfs:///test/vhjy/addOrderId”)]]></content>
      <categories>
        <category>大数据</category>
        <category>spark</category>
      </categories>
      <tags>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入排序]]></title>
    <url>%2F2016%2F09%2F27%2F%E7%AE%97%E6%B3%95%2F%E6%8E%92%E5%BA%8F%2F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1、直接插入排序将一个记录插入到已排序好的有序表中，得到一个新的，记录数加1的有序表写程序时，要设立哨兵，用于临时存储和判断数组边界。优化：二分插入排序，2-路插入排序12345678910111213141516171819202122232425/** * 插入排序 * 从第一个元素开始，该元素可以认为已经被排序 * 取出下一个元素，在已经排序的元素序列中从后向前扫描 * 如果该元素（已排序）大于新元素，将该元素移到下一位置 * 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 * 将新元素插入到该位置中 * 重复步骤2 * * @param numbers 待排序数组 */public static void insertSort(int[] numbers) &#123; int size = numbers.length; int temp = 0; int j = 0; for (int i = 0; i &lt; size; i++) &#123; temp = numbers[i]; //假如temp比前面的值小，则将前面的值后移 for (j = i; j &gt; 0 &amp;&amp; temp &lt; numbers[j - 1]; j--) &#123; numbers[j] = numbers[j - 1]; &#125; numbers[j] = temp; &#125;&#125; 2、希尔排序（缩小增量排序）选择一个增量，将序列分成一些子序列，对子序列进行插入排序，缩小增量继续，直到这个增量为1时，有序1234567891011121314151617181920212223242526272829/** * 希尔排序的原理:根据需求，如果你想要结果从大到小排列，它会首先将数组进行分组，然后将较大值移到前面，较小值 * 移到后面，最后将整个数组进行插入排序，这样比起一开始就用插入排序减少了数据交换和移动的次数，可以说希尔排序是加强 * 版的插入排序 * 拿数组5, 2, 8, 9, 1, 3，4来说，数组长度为7，当increment为3时，数组分为两个序列 * 5，2，8和9，1，3，4，第一次排序，9和5比较，1和2比较，3和8比较，4和比其下标值小increment的数组值相比较 * 此例子是按照从大到小排列，所以大的会排在前面，第一次排序后数组为9, 2, 8, 5, 1, 3，4 * 第一次后increment的值变为3/2=1,此时对数组进行插入排序， * 实现数组从大到小排 */public static void shellSort(int[] data) &#123; int j = 0; int temp = 0; //每次将步长缩短为原来的一半 for (int increment = data.length / 2; increment &gt; 0; increment /= 2) &#123; for (int i = increment; i &lt; data.length; i++) &#123; temp = data[i]; for (j = i; j &gt;= increment; j -= increment) &#123; if (temp &gt; data[j - increment])//如想从小到大排只需修改这里 &#123; data[j] = data[j - increment]; &#125; else &#123; break; &#125; &#125; data[j] = temp; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序]]></title>
    <url>%2F2016%2F09%2F26%2F%E7%AE%97%E6%B3%95%2F%E6%8E%92%E5%BA%8F%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1、简单选择排序在序列是，选出最小的与第一位交换，剩下的再找最小的与第二位交换，重复直到最后一个和倒数第二个比较为止1234567891011121314151617181920212223242526/** * 选择排序算法 * 在未排序序列中找到最小元素，存放到排序序列的起始位置 * 再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。 * 以此类推，直到所有元素均排序完毕。 * * @param numbers */public static void selectSort(int[] numbers) &#123; int size = numbers.length; //数组长度 int temp = 0; //中间变量 for (int i = 0; i &lt; size; i++) &#123; int k = i; //待确定的位置 //选择出应该在第i个位置的数 for (int j = size - 1; j &gt; i; j--) &#123; if (numbers[j] &lt; numbers[k]) &#123; k = j; &#125; &#125; //交换两个数 temp = numbers[i]; numbers[i] = numbers[k]; numbers[k] = temp; &#125;&#125; 2、选择排序改进（二元选择排序）每趟循环可以确定最大最小两个元素，减少循环次数 3、堆排序（树形选择排序）先把要排序的序列看做二叉树，调整顺序，成为最大或最小堆，输出堆顶元素,再重新调整，直到有序，复杂度为：O(nlogn)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 思想:初始时把要排序的数的序列看作是一棵顺序存储的二叉树，调整它们的存储序，使之成为一个堆， * 这时堆的根节点的数最大。然后将根节点与堆的最后一个节点交换。然后对前面(n-1)个数重新调整使之成为堆。 * 依此类推，直到只有两个节点的堆，并对 它们作交换，最后得到有n个节点的有序序列。 * 从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。 * 一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。 */public class HeapSort &#123; public static void main(String[] args) &#123; int[] a = &#123;49, 38, 65, 97, 76, 13, 27, 49, 78, 34, 12, 64&#125;; int arrayLength = a.length; //循环建堆 for (int i = 0; i &lt; arrayLength - 1; i++) &#123; //建堆 buildMaxHeap(a, arrayLength - 1 - i); //交换堆顶和最后一个元素 swap(a, 0, arrayLength - 1 - i); System.out.println(Arrays.toString(a)); &#125; &#125; //对data数组从0到lastIndex建大顶堆 public static void buildMaxHeap(int[] data, int lastIndex) &#123; //从lastIndex处节点（最后一个节点）的父节点开始 for (int i = (lastIndex - 1) / 2; i &gt;= 0; i--) &#123; //k保存正在判断的节点 int k = i; //如果当前k节点的子节点存在 while (k * 2 + 1 &lt;= lastIndex) &#123; //k节点的左子节点的索引 int biggerIndex = 2 * k + 1; //如果biggerIndex小于lastIndex，即biggerIndex+1代表的k节点的右子节点存在 if (biggerIndex &lt; lastIndex) &#123; //若果右子节点的值较大 if (data[biggerIndex] &lt; data[biggerIndex + 1]) &#123; //biggerIndex总是记录较大子节点的索引 biggerIndex++; &#125; &#125; //如果k节点的值小于其较大的子节点的值 if (data[k] &lt; data[biggerIndex]) &#123; //交换他们 swap(data, k, biggerIndex); //将biggerIndex赋予k，开始while循环的下一次循环，重新保证k节点的值大于其左右子节点的值 k = biggerIndex; &#125; else &#123; break; &#125; &#125; &#125; &#125; //交换 private static void swap(int[] data, int i, int j) &#123; int tmp = data[i]; data[i] = data[j]; data[j] = tmp; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[交换排序]]></title>
    <url>%2F2016%2F09%2F25%2F%E7%AE%97%E6%B3%95%2F%E6%8E%92%E5%BA%8F%2F%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1、冒泡排序当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换123456789101112131415161718192021/** * 冒泡排序 * 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 * 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 * 针对所有的元素重复以上的步骤，除了最后一个。 * 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 * @param numbers 需要排序的整型数组 */public static void bubbleSort(int[] numbers) &#123; int temp = 0; int size = numbers.length; for (int i = 0; i &lt; size - 1; i++) &#123; for (int j = 0; j &lt; size - 1 - i; j++) &#123; if (numbers[j] &gt; numbers[j + 1]) &#123; //交换两数位置 temp = numbers[j]; numbers[j] = numbers[j + 1]; numbers[j + 1] = temp; &#125; &#125; &#125;&#125; 2、冒泡排序改进可以加一个记录，就是数据交换的位置，下一趟排序，就可以直接从那个位置开始 3、快速排序选择一个基准，将序列分成两部分，比基准大的，和比基准小的，基准位置确定，再对前后两部分递归排序12345678910111213141516171819202122232425262728293031323334353637/** * 1、查找出中轴（默认是最低位low）的在numbers数组排序后所在位置 * * @param numbers 带查找数组 * @param low 开始位置 * @param high 结束位置 * @return 中轴所在位置 */public static int getMiddle(int[] numbers, int low, int high) &#123; int temp = numbers[low]; //数组的第一个作为中轴 while (low &lt; high) &#123; while (low &lt; high &amp;&amp; numbers[high] &gt; temp) &#123; high--; &#125; numbers[low] = numbers[high];//比中轴小的记录移到低端 while (low &lt; high &amp;&amp; numbers[low] &lt; temp) &#123; low++; &#125; numbers[high] = numbers[low]; //比中轴大的记录移到高端 &#125; numbers[low] = temp; //中轴记录到尾 return low; // 返回中轴的位置&#125;/** * 2、递归形式的分治排序算法 * @param numbers 带排序数组 * @param low 开始位置 * @param high 结束位置 */public static void quickSort(int[] numbers, int low, int high) &#123; if (low &lt; high) &#123; int middle = getMiddle(numbers, low, high); //将numbers数组进行一分为二 quickSort(numbers, low, middle - 1); //对低字段表进行递归排序 quickSort(numbers, middle + 1, high); //对高字段表进行递归排序 &#125;&#125; 4、快排改进对长度大于一个值得时候，选择快排，小于一个值得时候，选择插入，8]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2F2016%2F09%2F24%2F%E7%AE%97%E6%B3%95%2F%E6%8E%92%E5%BA%8F%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[将两个或者两个以上有序序列合并，多次合并后有序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 归并排序 * 简介:将两个（或两个以上）有序表合并成一个新的有序表 即把待排序序列分为若干个子序列， * 每个子序列是有序的。然后再把有序子序列合并为整体有序序列 * 时间复杂度为O(nlogn) * 稳定排序方式 * * @param nums 待排序数组 * @return 输出有序数组 */public static int[] sort(int[] nums, int low, int high) &#123; int mid = (low + high) / 2; if (low &lt; high) &#123; // 左边 sort(nums, low, mid); // 右边 sort(nums, mid + 1, high); // 左右归并 merge(nums, low, mid, high); &#125; return nums;&#125;/** * 将数组中low到high位置的数进行排序 * * @param nums 待排序数组 * @param low 待排的开始位置 * @param mid 待排中间位置 * @param high 待排结束位置 */public static void merge(int[] nums, int low, int mid, int high) &#123; int[] temp = new int[high - low + 1]; int i = low;// 左指针 int j = mid + 1;// 右指针 int k = 0; // 把较小的数先移到新数组中 while (i &lt;= mid &amp;&amp; j &lt;= high) &#123; if (nums[i] &lt; nums[j]) &#123; temp[k++] = nums[i++]; &#125; else &#123; temp[k++] = nums[j++]; &#125; &#125; // 把左边剩余的数移入数组 while (i &lt;= mid) &#123; temp[k++] = nums[i++]; &#125; // 把右边边剩余的数移入数组 while (j &lt;= high) &#123; temp[k++] = nums[j++]; &#125; // 把新数组中的数覆盖nums数组 for (int k2 = 0; k2 &lt; temp.length; k2++) &#123; nums[k2 + low] = temp[k2]; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac常用快捷键]]></title>
    <url>%2F2016%2F09%2F18%2F%E5%B7%A5%E5%85%B7%2Fmac%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA常用快捷键]]></title>
    <url>%2F2016%2F09%2F18%2F%E5%B7%A5%E5%85%B7%2FIDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[1、列编辑command+shift+小键盘的* 2、大小写切换command+shift+u 3.插件GsonFormatoption+s，将json转成bean]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装jdk]]></title>
    <url>%2F2016%2F07%2F14%2Flinux%2F%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%2F%E5%AE%89%E8%A3%85jdk%2F</url>
    <content type="text"><![CDATA[一、linux1、下载解压到/usr/localhttp://download.oracle.com/otn/java/jdk/7u80-b15/jdk-7u80-linux-x64.tar.gz 2、修改配置vim /etc/profile export JAVA_HOME=/usr/local/jdk-defaultexport CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/bin]]></content>
      <categories>
        <category>linux</category>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器加速优化-锐速]]></title>
    <url>%2F2016%2F07%2F14%2Flinux%2F%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8A%A0%E9%80%9F%E4%BC%98%E5%8C%96-%E9%94%90%E9%80%9F%2F</url>
    <content type="text"><![CDATA[1、查看linux支持内核列表uname -rcentos6.8 —— 2.6.32-696.3.2.el6.x86_64 2、检查VPS是什么虚拟化技术安装vitr-what查看VPS的虚拟化技术执行命令：virt-what如果不是OpenVZ，可以继续 3、根据内核版本安装锐速wget -N –no-check-certificate https://github.com/91yun/serverspeeder/raw/master/serverspeeder-v.sh &amp;&amp; bash serverspeeder-v.sh CentOS 6.8 2.6.32-642.el7.x86_64 x64 3.11.20.4 serverspeeder_68642 4、卸载锐速chattr -i /serverspeeder/etc/apx* &amp;&amp; /serverspeeder/bin/serverSpeeder.sh uninstall -f 5、使用命令#重启锐速/serverspeeder/bin/serverSpeeder.sh restart #启动锐速/serverspeeder/bin/serverSpeeder.sh start #停止锐速/serverspeeder/bin/serverSpeeder.sh stop #查看锐速运行情况/serverspeeder/bin/serverSpeeder.sh status]]></content>
      <categories>
        <category>linux</category>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-安装mysql]]></title>
    <url>%2F2016%2F06%2F18%2Flinux%2F%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%2F%E5%AE%89%E8%A3%85mysql%2F</url>
    <content type="text"><![CDATA[一、二进制免编译包安装参考：http://www.apelearn.com/bbs/forum.php?mod=viewthread&amp;tid=10105&amp;highlight=mysql5.71、下载地址： http://mirrors.sohu.com/mysql/MySQL-5.7/ 文件名还glibc的为免编译的二进制安装包 文件: mysql-5.7.13-linux-glibc2.5-x86_64.tar.gz mysql-5.6.30-linux-glibc2.5-x86_64.tar.gz 2、官网下载：http://dev.mysql.com/downloads/mysql/ Select Platform: 选择 --&gt; linux - Generic 然后选择 (mysql-5.7.13-linux-glibc2.5-x86_64.tar.gz) Linux - Generic (glibc 2.5) (x86, 64-bit), Compressed TAR Archive5.7.13610.2MDownload(mysql-5.7.13-linux-glibc2.5-x86_64.tar.gz) 二：卸载旧版本使用下面的命令检查是否安装有MySQL Serverrpm -qa | grep mysql 显示： mysql-libs-5.1.71-1.el6.x86_64有的话通过下面的命令来卸载掉rpm -e mysql-libs-5.1.71-1.el6.x86_64 //普通删除模式rpm -e –nodeps mysql-libs-5.1.71-1.el6.x86_64 // 强力删除模式，如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除 或者 yum remove mysql-libs-5.1.71-1.el6.x86_64 //yum卸载 三、安装1. 下载包cd /usr/local/srcwget http://mirrors.sohu.com/mysql/MySQL-5.7/mysql-5.7.17-linux-glibc2.5-x86_64.tar.gz 2. 解压tar zxvf mysql-5.7.12-linux-glibc2.5-x86_64.tar.gz mv mysql-5.7.12-linux-glibc2.5-x86_64 /usr/local/mysql 3. 初始化 // mysql_install_db 已经不再推荐使用了，建议改成 mysqld –initialize 完成实例初始化。使用下面的命令查看是否有mysql用户及用户组 cat /etc/passwd 查看用户列表 cat /etc/group 查看用户组列表 如果没有就创建useradd -M -s /sbin/nologin mysql //-M 不建立使用者目录 mkdir -p /data/mysql chown mysql /data/mysql cd /usr/local/mysql ./bin/mysqld –initialize –user=mysql –datadir=/data/mysql //旧方法： ./scripts/mysql_install_db –user=mysql –datadir=/data/mysql 注意，这一步最后一行会有一个提示 [Note] A temporary password is generated for root@localhost: Bs1i(,kXwg 最后面的字符串为root密码。 ./bin/mysql_ssl_rsa_setup –datadir=/data/mysql 4. 拷贝配置文件和启动脚本注：在启动MySQL服务时，会按照一定次序搜索my.cnf，先在/etc目录下找，找不到则会搜索”$basedir/my.cnf”，在本例中就是 /usr/local/mysql/my.cnf，这是新版MySQL的配置文件的默认位置！cp support-files/my-default.cnf /etc/my.cnf vim /etc/my.cnf //编辑或者修改[mysqld] // 在这里修改 basedir = /usr/local/mysql datadir = /data/mysql port = 3306 socket = /tmp/mysql.sock //注意路径不能出错，否则启动出错 上次少了/ cp support-files/mysql.server /etc/init.d/mysqld vi /etc/init.d/mysqld //编辑或者修改 basedir=/usr/local/mysql datadir=/data/mysql 5. 启动服务/etc/init.d/mysqld start启动出错的话可以查看日志：less /data/mysql/localhost.localdomain.err加入开机启动 chkconfig –add mysqld chkconfig mysqld on service mysqld start 6. 设置root密码使用初始化密码登录 /usr/local/mysql/bin/mysql -uroot -p’Bs1i(,kXwg’ //进入后直接设置密码 mysql&gt;set password = password(‘mypass’); //注意分号一定要设置一下新密码 退出来，再使用新的密码登录就可以了 还有一种情况，就是不知道初始化密码 vi /etc/my.cnf 在[mysqld]下面增加一行 skip-grant-tables 重启 /etc/init.d/mysqld restart /usr/local/mysql/bin/mysql -uroot mysql&gt; update user set authentication_string=password(‘root’) where user=’root’; 退出来后，更改my.cnf，去掉刚加的 skip-grant-tables 重启 /etc/init.d/mysqld restart 此时就可以使用新的密码了。 远程连接需要修改权限grant all privileges on . to root@’%’ identified by ‘’;flush privileges;]]></content>
      <categories>
        <category>linux</category>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-shadowsocks服务端安装]]></title>
    <url>%2F2016%2F06%2F13%2Flinux%2F%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%2Fshadowsocks%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[1、安装shadowsockspip install shadowsocks 2、创建/etc/shadowsocks.json123456789&#123; &quot;server&quot;:&quot;127.0.0.1&quot;, &quot;server_port&quot;:8388, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;zhangjun&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;rc4-md5&quot;&#125; 3、启动12ssserver -c /etc/shadowsocks.json -d startssserver -c /etc/shadowsocks.json -d stop 4、加速优化4.1 内核参数优化首先，将 Linux 内核升级到 3.5 或以上。第一步，增加系统文件描述符的最大限数编辑文件 limits.confvi /etc/security/limits.conf增加以下两行12soft nofile 51200hard nofile 51200 启动shadowsocks服务器之前，设置以下参数ulimit -n 51200 4.2 调整内核参数修改配置文件 /etc/sysctl.conf123456789101112131415161718fs.file-max = 51200net.core.rmem_max = 67108864net.core.wmem_max = 67108864net.core.netdev_max_backlog = 250000net.core.somaxconn = 4096net.ipv4.tcp_syncookies = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_tw_recycle = 0net.ipv4.tcp_fin_timeout = 30net.ipv4.tcp_keepalive_time = 1200net.ipv4.ip_local_port_range = 10000 65000net.ipv4.tcp_max_syn_backlog = 8192net.ipv4.tcp_max_tw_buckets = 5000net.ipv4.tcp_fastopen = 3net.ipv4.tcp_rmem = 4096 87380 67108864net.ipv4.tcp_wmem = 4096 65536 67108864net.ipv4.tcp_mtu_probing = 1net.ipv4.tcp_congestion_control = hybla 修改后执行 sysctl -p 使配置生效]]></content>
      <categories>
        <category>linux</category>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据一致性的理论]]></title>
    <url>%2F2016%2F06%2F13%2F%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E5%8F%AF%E7%94%A8%2F%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E7%90%86%E8%AE%BA%E5%8F%8A%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[一、分布式事务需求来源1、跨数据库 数据库拆分带来的分布式事务 –&gt; 保证跨库操作的原子性基于单个JVM 2、跨应用 应用拆分带来的分布式事务，保证跨应用业务操作的原子性跨JVM 二、CAP理论 C数据一致性 ：所有节点拥有数据的最新版本 A可用性 ：数据具备高可用性 P分区容忍性 ：容忍网络出现分区，分区之前的网络不可达 三、解决方案1、弱一致性 有可能某个时刻数据非一致，但保证最终一致。 &emsp;a、由外围系统重试。自身实现幂等，保证最终的一致性。&emsp;&emsp;&emsp;被调用方无需关心一致性问题。只需实现幂等，无耦合 &emsp;b、依赖于事务型消息，通过消息重试，保证最终一致性&emsp;&emsp;&emsp;上层系统无重试，补偿，只依赖系统自身保证一致性。在用户解冻结后，发送事务型消息，只要消息发送和用户解冻成功即可返回外围系统成功。而后面账户的解冻依赖于消息中心的消息投递。失败了，有消息系统重试，直到成功。 &emsp;c、依赖于调度系统，通过调度任务重试，保证最终一致性&emsp;&emsp;&emsp;上层业务无补偿，无重试，在完成用户解冻后，落地一张异步的任务表，由定时任务定时扫描去调用账务解冻。&emsp;&emsp;&emsp;是否重试和终止，由系统自身决定，灵活性更高。 2、强一致性 需要保证数据的一致性是实时的，每一时刻都保持一致。引入协调者中间协调者从全局把控业务涉及的系统，是否存在部分失败及最终提交还是回滚。 &emsp;a、2pc&emsp;&emsp;&emsp;由一方进行提议(propose)并收集其他节点的反馈(vote)，再根据反馈决定提交(commit)或中止(abort)事务 问题： 第二阶段，由于网络问题，某参与者或者协调者宕机，导致一直等待占用资源，数据不一致若协调者是集群，可能协调者和部分参与者都宕机，选出新的协调者是无法知晓事务状态，导致数据不一致 &emsp;b、tcc&emsp;&emsp;&emsp;TCC分别对应Try，Confirm和Cancel三种操作 Try:预留业务资源 1、完成所有业务检查（一致性） 2、预留必须业务资源（准隔离性） Confirm：确认执行业务。 1、真正执行业务 2、不做任何业务检查 3、只使用Try阶段预留的业务资源 Cancel：取消执行业务 释放Try阶段预留的业务资源 确保幂等性： 通过唯一键值做处理，每次调用的时候传入唯一键值，判断业务是否已被操作 通过状态机处理给业务数据设置状态，判断是否执行 例子： 支付系统接收到会员的支付请求后，需要扣减会员账户余额、增加会员积分（暂时假设需要同步实现）增加商户账户余额 再假设：会员系统、商户系统、积分系统是独立的三个子系统，无法通过传统的事务方式进行处理。 TRYING阶段：我们需要做的就是会员资金账户的资金预留，即：冻结会员账户的金额（订单金额）CONFIRMING阶段：我们需要做的就是会员积分账户增加积分余额，商户账户增加账户余额CANCELING阶段：该阶段需要执行的就是解冻释放我们扣减的会员余额 &emsp;c、3pc&emsp;&emsp;第一阶段协调者询问参与者是否可以执行事务，参与者就分析自身是否能够成功执行事务操作，可以则返回yes,否则no&emsp;&emsp;第二阶段参与者收到后则开始执行事务操作，执行成功后反馈yes给协调者反之no&emsp;&emsp;第三阶段协调者根据参与者的反馈选择发起abort或者commit命令 增加了超时机制： 第二阶段，如果协调者超时没有接受到参与者的反馈，则自动认为失败，发送abort命令第三阶段，如果参与者超时没有接受到协调者的反馈，则自动认为成功开始提交事务（基于概率） 比较 相对于2pc，3pc解决了单点问题。参与者接收不到协调者的信息会默认commit，不会阻塞。但可能由于网络问题，参与者没有接收到abort信息，却默认提交。导致数据不一致]]></content>
      <categories>
        <category>分布式高可用</category>
      </categories>
      <tags>
        <tag>分布式高可用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-更新python]]></title>
    <url>%2F2016%2F06%2F10%2Flinux%2F%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%2F%E6%9B%B4%E6%96%B0python%2F</url>
    <content type="text"><![CDATA[1、下载解压下载wget https://www.python.org/ftp/python/2.7.14/Python-2.7.14.tgz 解压tar -zxvf Python-2.7.14.tgz 建安装的文件夹mkdir /usr/local/python2.7.14cd Python-2.7.14 2、安装依赖，修改配置安装依赖yum install openssl openssl-devel zlib-devel gcc -y 修改下载包文件vim ./Modules/Setup.dist 找到#zlib zlibmodule.c -I$(prefix)/include -L$(exec_prefix)/lib -lz去掉注释并保存 3、编译安装./configure –prefix=/usr/local/python2.7.14 –with-zlibmake &amp;&amp; make install 修改链接mv /usr/bin/python /usr/bin/python2.6.6 ln -s /usr/local/python2.7.14/bin/python2.7 /usr/bin/python2.7 4、修改yum配置文件保留旧版本，yum依赖Python2.6，改下yum的配置文件，指定旧的Python版本就可以了。vim /usr/bin/yum，将第一行的#!/usr/bin/python修改成#!/usr/bin/python2.6.6 5、安装最新版本的pipwget https://bootstrap.pypa.io/get-pip.pypython get-pip.pymv /usr/bin/pip /usr/bin/pip2.6.6ln -s /usr/local/python2.7.14/bin/pip2.7 /usr/bin/pip2.7]]></content>
      <categories>
        <category>linux</category>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ftp命令使用]]></title>
    <url>%2F2016%2F05%2F21%2Flinux%2F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2Fftp%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1、 “开始”-“运行”输入“cmd“，打开命令提示符； 2、进入 ftp在命令提示符内输入”ftp“并回车，进入 ftp 提示符 ftp&gt; , 3、在 ftp&gt;输入 open 192.168.80.17 回车； /如果你的 FTP 服务器不是用的 21 默认端口，假如端口是 10021，那么此步的命令应在后面空格加 10021，即“open 192.168.80.17 10021“/ 4、用户/提示输入用户名 / 5、密码/ 提示输入密码，密码不会显示，输完密码后回车即可 / 6、dir/ 成功登陆后就可以用 dir查看 FTP服务器中的文件目录/ 7、lcd d:\test/定位本地默认文件夹，在前面事先在 D：盘创建好的 / 8、!dir/ 查看本地文件夹中有文件及目录 /9、prompt/打开和关闭交互模式，关闭交互模式时使用 mget 等不会提示 / 10、mget .(下载)/ 将 FTP服务器默认目录中的所有文件下载到当前目录下（d:\test) / 11、bye/退出 FTP服务器 / 行内ftp下载连接 174.100.100.1 ftpopen 10.24.0.149cqdownl_ba6D3znYKlcd /data/txtdir]]></content>
      <categories>
        <category>linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用shell命令学习-02]]></title>
    <url>%2F2016%2F05%2F21%2Flinux%2F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F%E5%B8%B8%E7%94%A8shell%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-02%2F</url>
    <content type="text"><![CDATA[lsof 1、查看已删除文件被占用情况lsof全名list opened files，也就是列举系统中已经被打开的文件。inux环境中，不论什么事物都是文件，设备是文件，文件夹是文件，甚至sockets也是文件 lsof是linux最常常使用的命令之中的一个，通常的输出格式为： 引用COMMAND PID USER FD TYPE DEVICE SIZE NODE NAME 常见包含例如以下几个字段：许多其他的可见manual。1、COMMAND默认以9个字符长度显示的命令名称。可使用+c參数指定显示的宽度，若+c后跟的參数为零，则显示命令的全名2、PID：进程的ID号3、PPID父进程的IP号，默认不显示，当使用-R參数可打开。4、PGID进程组的ID编号，默认也不会显示，当使用-g參数时可打开。5、USER命令的执行UID或系统中登陆的username称。默认显示为username，当使用-l參数时，可显示UID。6、FD是文件的File Descriptor number lsof | grep delete可以查看已删除但任被线程占用的文件 2、端口占用命令 lsof -i tcp:port （port替换成端口号，比如6379）可以查看该端口被什么程序占用，并显示PID，方便kill]]></content>
      <categories>
        <category>linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解压缩相关]]></title>
    <url>%2F2016%2F05%2F20%2Flinux%2F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F%E8%A7%A3%E5%8E%8B%E7%BC%A9%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[1、rarunrar x test.rar rar常用命令主要有: e 将文件解压到当前目录 例:rar e test.rar 注:用e解压的话，不仅原来的file1.txt和file2.txt被解压到当前目录，就连dir1里面的所有文件 也被解压到当前目录下，不能保持压缩前的目录结构，如果想保持压缩前的目录结构，用x解压 x 带路径解压文档中内容到当前目录 例:rar x test.rar 这样解压的话，dir1就会保持原来的目录结构 a 添加文件到操作文档例:rar a test.rar file1.txt 若test.rar文件不存在，则打包file1.txt文件成test.rar 例:rar a test.rar file2.txt 若test.rar文件已经存在，则添加file2.txt文件到test.rar中 (这样test.rar中就有两个文件了） 注，如果操作文档中已有某文件的一份拷贝，则a命令更新该文件，对目录也可以进行操作 例:rar a test.rar dir1 c 对操作文档添加说明注释 rar c test.rar （会出现Reading comment from stdin字样，然后输入一行或多行注释，以ctrl+d结束） cf 添加文件注释，类似上面的c，不过这个是对压缩文档中每个文件进行注释 cw 将文档注释写入文件 例:rar cw test.rar comment.txt d 从文档中删除文件 例:rar d test.rar file1.txt k 锁定文档 例:rar k test.rar 锁定文档后，该文档就无法进行任何更新操作了 r 修复文档 例:rar r test.rar 当rar文件有问题时，可以尝试用该命令进行修复（鬼知道有多少用） s 转换文档成自解压文档 例:rar s test.rar 会生成一个test.sfx的可执行文档，运行它的效果就相当于rar x test.rar， 适合于向没有rar的用户传输文件 t 检测文档 例:rar t test.rar 检测test.rar的完整性，一般压缩完大型文件准备传输前最好用这个命令来确保文件的正确性 zipzip -e 加密 1、把/home目录下面的mydata目录压缩为mydata.zipzip -r mydata.zip mydata #压缩mydata目录2、把/home目录下面的mydata.zip解压到mydatabak目录里面unzip mydata.zip -d mydatabak3、把/home目录下面的abc文件夹和123.txt压缩成为abc123.zipzip -r abc123.zip abc 123.txt4、把/home目录下面的wwwroot.zip直接解压到/home目录里面unzip wwwroot.zip5、把/home目录下面的abc12.zip、abc23.zip、abc34.zip同时解压到/home目录里面unzip abc*.zip6、查看把/home目录下面的wwwroot.zip里面的内容unzip -v wwwroot.zip7、验证/home目录下面的wwwroot.zip是否完整unzip -t wwwroot.zip8、把/home目录下面wwwroot.zip里面的所有文件解压到第一级目录unzip -j wwwroot.zip主要参数-c：将解压缩的结果-l：显示压缩文件内所包含的文件-p：与-c参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换-t：检查压缩文件是否正确-u：与-f参数类似，但是除了更新现有的文件外，也会将压缩文件中的其它文件解压缩到目录中-v：执行是时显示详细的信息-z：仅显示压缩文件的备注文字-a：对文本文件进行必要的字符转换-b：不要对文本文件进行字符转换-C：压缩文件中的文件名称区分大小写-j：不处理压缩文件中原有的目录路径-L：将压缩文件中的全部文件名改为小写-M：将输出结果送到more程序处理-n：解压缩时不要覆盖原有的文件-o：不必先询问用户，unzip执行后覆盖原有文件-P：使用zip的密码选项-q：执行时不显示任何信息-s：将文件名中的空白字符转换为底线字符-V：保留VMS的文件版本信息-X：解压缩时同时回存文件原来的UID/GID]]></content>
      <categories>
        <category>linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim命令]]></title>
    <url>%2F2016%2F05%2F20%2Flinux%2F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2Fvim%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1、全局替换:%s/源字符串/目的字符串/g:%s/USERADD/USERMODIFY/g]]></content>
      <categories>
        <category>linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用shell命令学习-01]]></title>
    <url>%2F2016%2F05%2F20%2Flinux%2F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F%E5%B8%B8%E7%94%A8shell%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-01%2F</url>
    <content type="text"><![CDATA[du,find,rz 1、16进制随机数，并转为大写12345str=`openssl rand -hex 16`$(echo `openssl rand -hex 16` | tr '[:lower:]' '[:upper:]')openssl rand -hex 16` | tr '[:lower:]' '[:upper:]’ 2、查找文本中n个出现频率最高的单词1234567891011#!/bin/bashend=$1cat $2 |tr -cs "[a-z][A-Z]" "[\012*]" | tr A-Z a-z | sort | uniq -c | sort -k1nr -k2 | head -n"$end" 3、dudu -sh /* 查看某目录下文件夹所占磁盘大小 4、排查问题grep –color=always -n -B1 -A1 “clp_7a93a2a059b7f18d” credit-20170606-info.log 5、查询目录下所有文件并处理find -name “.log” -exec cat &gt; /tmp/2.log {} \;find . | grep Log | grep java 递归查找当前目录find -name “.log” -exec cat &gt; /tmp/2.log {} \; 6、rz命令上传大文件rz -be]]></content>
      <categories>
        <category>linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[货币战争]]></title>
    <url>%2F2016%2F04%2F02%2F%E8%AF%BB%E4%B9%A6%E8%A7%82%E5%BD%B1%2F%E4%B9%A6%E7%B1%8D%2F%E8%B4%A7%E5%B8%81%E6%88%98%E4%BA%89%2F</url>
    <content type="text"><![CDATA[刚看的时候很震撼，慢慢的找出一些重点触发感慨]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经济学]]></title>
    <url>%2F2016%2F03%2F13%2F%E8%AF%BB%E4%B9%A6%E8%A7%82%E5%BD%B1%2F%E4%B9%A6%E7%B1%8D%2F%E7%BB%8F%E6%B5%8E%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[终于吐着血看完，太痛苦了，我果然只适合看武侠小说 1、经济学是一门帮助您增强洞察能力和保障选择效率的学问。 2、坚持不懈地将“最优化行为”、“市场均衡”和“稳定性偏好假设”结合起来，经济学提供了各种范示，可以帮助我们在确定目标、选择手段和保证效率之间获得一种均衡。 3、正因为如此，我们才需要寻找一种一般性的参照“解”。日常生活中，你看到的是情怀各异的芸芸众生，是特殊；而在经济学中，你遇到的将是具有“自利”目标和“理性”手段的“经济人”，是一般。找到了一般，显然有助于我们比照出特殊。 4、事实上，当今许多杰出的经济学家都曾写信告诉我们：在获取博士学位的奋斗过程中，他们一直依靠着这本《经济学》。 5、骑士时代已经过去，随之而来的是智者、经济学家和计算机天才的世界。 6、经济学研究的是一个社会如何利用稀缺的资源以生产有价值的物品和劳务，并将它们在不同的人中间进行分配。这定义的背后隐含着经济学的两大核心思想：即物品和资源是稀缺的；社会必须有效地加以利用。 7、稀缺是指这样一个状态：相对于需求，物品总是有限的。 8、所有的社会都是指令经济和市场经济的不同比例的组合，因此也可以说所有的社会都是混合经济。 9、靠牺牲当前消费而获得的增长，如果人们愿意储蓄——节制眼前消费以备未来消费，那么，社会就能够将资源用于新的资本形成。较多的基本存量会将生产可能性边界向外推移，有助于经济的快速增长。 10、效用是一种科学构想，经济学家用它来解释：理性的消费者如何将其有限的资源，分配在能给他们带来最大满足的各种商品上。 11、17世纪的哲学家弗朗西斯.培根认为，人类最纯洁的娱乐是园艺。 12、 等边际效用法则：它并不仅仅是一条经济学规律，而且也是一条关于理性选择的规律。 13、某种经济可能有很高的效率，运用其资源生产大量的大炮和黄油，但是，黄油大多为少数富裕的人所消费，或者被用于饲养它们的卷毛狗，而大炮仅仅是用以保护富人的黄油。 14、垄断者，通过经常保持市场存货的不足……以远远高于正常的价格出售他们的产品，从而无论在工资还是在利润等方面都增大企业的回报。 ——亚当.斯密《国富论》 15、经济学的最重要的教益之一是：你应该注意决策的边际成本和边际收益，并忽略过去的或沉淀的成本。这一点可以表述如下：让过去的事情成为过去，不要向后看，不要为已溅出的牛奶而哭泣，不要为昨日的损失而悲叹，对于任何一个决策，要准确地计算你将为之付出的成本，并把它和你将因之而增加的收益相权衡，根据边际成本和边际收益来进行决策。 16、这就是边际原则，它是指人们通过仅仅考虑和计算某一决策的边际成本与边际收益，来达到收益或利润或满足程度的最大化。有无数的场合可以利用边际原则。我们已经认识到，企业追求利润最大化的条件是符合边际成本等于边际收益的边际原则。另一个例子是投资决策，无论你是决定投资一家公司，还是出售一套房屋，你都应该把过去的盈利或亏损忽略不计，只需根据边际成本和边际收益做决策。边际原则是经济学中最富有启迪的工具之一。 17、投机商的活动是怎样有益于社会的呢？他们的经济作用就是将各种商品从数量丰富的时期“运送”至商品稀缺的时期。这种“运送”将会跨越空间、时间或者不确定的自然因素。即使投机商们从来没见到过一桶油或一卡车鸡蛋，但他们还是可以帮助平抑这些商品在时间和空间上的差价。他们所做的工作就是：在商品数量充足、价格低的时间或地点买进，然后在商品数量稀缺、价格高的时间或者地点卖出。（感觉是传统意义上的，但和“套利”又非常相似） 18、若一个人损失一定量的收入而产生的痛苦感大于他为得到同等数量的收入而产生的满足感，则他就是一个风险规避着。 19、策略性思维是在不断了解对手的过程中战胜对手的一门艺术。 ——埃维纳什.迪克西和巴里.纳勒巴夫《策略性思考》 20、博弈论所分析的是两个或两个以上的比赛者或参与者能够共同影响每一参加者的行动或策略的方式。 你在玩扑克牌时偶尔也应当耍一点小聪明，不仅要在自己手气差的时候能够赢，而且在手气好的时候也要保证其他的对手不会因为输得过多而退出牌局。 21、一旦你开始考虑他人会如何对自己的行动进行反应时，你便进入了博弈论的领域。 22、在经济学中，我们一般都假定企业要是利润最大化，而消费者要使效用最大化。 23、博弈论的指导思想是：假设你的对手在研究你的策略，并采取自身最大利益行动的时候，你如何选择最有效的策略。 24、在选择策略时，最简单的一种选择是占优策略，即无论其他博弈者采用何种战略，该博弈者的策略总是最好的。 25、追逐个人利益的结果，是他经常增进社会利益，其效果要比他真的想要增进社会的利益时更好。 26、一个无效率的胜者全得均衡产生了收入的最大的不平等。 27、当自由市场者主张市场激励导致社会有效结果时，我们认为胜者全得市场吸引了过多的参与者，导致了无效率的消费和投资，并且经常使文化堕落…….顶级工薪的剧增根源于胜者全得市场的逐渐流行。法兰克和库克强调“位置角逐控制”的必要性（例如改革法律体系），建议采用消费累进税，以降低娱乐、体育和商业的巨额报酬所引发的过渡竞争及其所带来的浪费。 28、尽管比较优势理论有其局限性，但它是经济学中最为深刻的真理之一。那些忽视比较优势的国家在生活水平和经济增长方面会因此而付出沉重的代价。 29、一个民族的精神风貌、文化程度、社会结构以及政策可能酿成的行为方式，所有这些甚至更多，都记录在她它的财政史上。那些明白怎样读懂这个历史所蕴含的信息的人们，比从其他任何地方都能更清醒地预感到震撼世界的惊雷。 ——约瑟夫.熊彼得 30、你不必精于赚钱，但你必须了解怎样才能赚钱。 ——马克.吐温 31、虽然政府在文明社会中扮演一个核心的角色，但我们必须不断地重新评估政府政策的目标和手段。政府对政治权利的垄断，使得政府应当肩负特殊的责任以保证效率。公共基金中，浪费在一些项目上的每一美元，原本都可以用来促进科学研究和减少饥饿。由于税收无效率而浪费掉的每一个美元，势必都会减少人们改善住房或上大学的机会。经济学的基本前提是在于资源的稀缺性，这一点应当平等地适用于私人资金和公共资金，而后者必须接受纳税人的监督。 32、当你能衡量你所谈论的东西并能用数字加以表达时，你才真的对它有了几分了解；而当你还不能衡量、不能用数字来表达它时，你的了解就是肤浅和不能令人满意的。尽管这种了解也许是认知的开始，但是在思想上则很难说你已经步入了科学的阶段。 ——凯尔文勋爵 33、相对于收入而言，高的消费一般都会引致低的投资和慢的增长；而高的储蓄则会引致高的投资和快的增长。 34、企业为什么要进行投资呢？归根结底，企业只有在预计到购买资本品会给它带来利润，也即会带来大于投资成本的收益的时候，才会进行投资。这个简短的论断包含了理解投资的三个基本要素：收益、成本和预期。 35、产出、通货膨胀率、利率和就业的波动构成了商业周期，商业周期是所有市场经济的共同特征。 36、商业周期是国民总产出、总收入、总就业量的波动，持续时间通常为2~10年，它以大多数经济部门的扩张或收缩为标志。 37、一个重要的理论是乘数-加速数原理。根据该原理，产出的快速增长刺激了投资，大规模的投资反过来又刺激产出增长得更多。 这个过程一直持续下去，直至潜在经济能力完全被利用殆尽。 38、我们赖以生存的经济社会的突出问题，一方面是由于不能提供充分就业，另一方面则是因为武断而又不公平地分配财富和收入。 —— 约翰.梅纳徳.凯恩斯《就业、利息与货币通论》 39、凯恩斯主义的政策，首先体现为宏观经济政策对实际经济目标所做出的显著贡献，尤其是对现实充分就业和国民收入实际增长这样的目标；其次，凯恩斯主义者要求积极主动的管理；第三，凯恩斯主义者希望将财政政策和货币政策紧密结合起来，共同促进宏观经济目标的实现。 40、政府还有另外一个和财政政策具有同样威力的武器：货币政策。 41、投资者有时可以分为两种：根据公司实际情况进行投资的投资者和竭力想要猜透市场心理的投资者。根据公司情况投资的理论认为资产应该依据它们的内在价值来估价。根据公司状况进行投资的方法是缓慢但安全的致富之路。 42、个人金融策略：1、了解你的投资；2、分散，分散，这是金融预言家的法则，分散投资的依据在于通过将资金投资到各个不同项目的办法，你能够在降低风险的同时继续获得高收益；3、考虑普通股指数基金，证券市场上的投资者可以通过购买许多种普通股股票组成投资组合来获得较高的收益并把风险降到最低；4、最小化不必要的花费和税收；5、使你的投资与你的风险偏好相一致。 43、我相信唯物主义。……..那些还未曾享受过这些东西便离开了尘世的人们也许很有可能会如圣人一般地高雅、会如诗人一般地丰富，然而那却是因为他们本来就高雅、就丰富，而绝对不是因为他们被剥夺了这些物质享受。 ——弗朗西斯.哈克特 44、经济学家认为，并非所有的自然资源都是天赐之福。美国、加拿大、挪威这样的国家曾经用它们的自然财富构造了坚实的工业扩张基础。而在某些国家，这些财富只是腐败的政府官员或军阀掠夺、寻租的目标。 45、一个开放经济的定义是：拥有低的贸易壁垒，开放的金融环境和私有化的市场；而封闭经济则反之。 46、要建立和维持一个健康的经济环境，政府的作用至关重要。政府必须推崇法治，强调合同的有效性，并使其管制有利于竞争和创新。通过对教育、医疗、交通设施的投资，政府在开发人力资源过程中可以起到重要的作用。但在那些政府没有比较优势的部门，则必须依靠私人部门，对那些市场不灵信号明显的领域，政府应当集中精力加以管理；而对那些政府具有相对劣势的部门，政府则应当放松管制和解除干预，让私人部门发挥作用。 47、马克思在1848年的《共产党宣言》中写道：“让统治阶级在共产主义的革命中发抖吧，无产阶级在这场斗争中所失去的只是他们的锁链。”统治阶级确实在马克思主义的影响下颤抖了一个多世纪！（多么伟大的畅想，多么遗憾地失败了）]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说话的梗]]></title>
    <url>%2F2016%2F02%2F19%2F%E7%94%9F%E6%B4%BB%2F%E9%98%85%E5%8E%86%2F%E8%AF%B4%E8%AF%9D%E7%9A%84%E6%A2%97%2F</url>
    <content type="text"><![CDATA[1、故事很复杂，又没有字幕，不太适合说给你听2、笑话https://www.zhihu.com/question/50053278]]></content>
      <categories>
        <category>生活</category>
        <category>沟通</category>
      </categories>
      <tags>
        <tag>沟通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输出式学习]]></title>
    <url>%2F2016%2F02%2F11%2F%E7%94%9F%E6%B4%BB%2F%E9%98%85%E5%8E%86%2F%E8%BE%93%E5%87%BA%E5%BC%8F%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[今天在知乎上看到问题，为什么我每天阅读大量的新闻、深度分析、故事和笑话，和别人在一起的时候却从来想不出话题？及相关问题，如何从思维上彻底改变学习模式？ 看完所有答案后留下此篇日志 1、 ![http://47.88.53.111:8002/%E7%94%9F%E6%B4%BB/]]]></content>
      <categories>
        <category>生活</category>
        <category>阅历</category>
      </categories>
      <tags>
        <tag>阅历</tag>
      </tags>
  </entry>
</search>
